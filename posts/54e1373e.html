<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="MySQL语法介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql">
<meta property="og:url" content="http://example.com/posts/54e1373e.html">
<meta property="og:site_name" content="blogWxy">
<meta property="og:description" content="MySQL语法介绍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220914170628495.png">
<meta property="og:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220922141332424.png">
<meta property="og:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221107193949559.png">
<meta property="og:image" content="http://example.com/C:/Users/Asus/Desktop/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/assets/image-20220428165219836.png">
<meta property="og:image" content="http://example.com/C:/Users/Asus/Desktop/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/assets/image-20220630141206134.png">
<meta property="og:image" content="http://example.com/C:/Users/Asus/Desktop/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/assets/image-20220608183730027.png">
<meta property="og:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221116104458850.png">
<meta property="og:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221116111012657.png">
<meta property="og:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221116150602298.png">
<meta property="og:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221116151952907.png">
<meta property="og:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221116152508558.png">
<meta property="og:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221111111829683.png">
<meta property="og:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221111160024208.png">
<meta property="article:published_time" content="2025-04-01T08:32:48.000Z">
<meta property="article:modified_time" content="2025-04-02T06:17:15.035Z">
<meta property="article:author" content="Wxy">
<meta property="article:tag" content="sql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220914170628495.png">

<link rel="canonical" href="http://example.com/posts/54e1373e.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Mysql | blogWxy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blogWxy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/54e1373e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Wxy">
      <meta itemprop="description" content="故事开始于2025/2/24 15：47">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blogWxy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Mysql
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-01 16:32:48" itemprop="dateCreated datePublished" datetime="2025-04-01T16:32:48+08:00">2025-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-02 14:17:15" itemprop="dateModified" datetime="2025-04-02T14:17:15+08:00">2025-04-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>80k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:25</span>
            </span>
            <div class="post-description">MySQL语法介绍</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库是存储在计算机中，有组织，可共享的大量数据的集合，数据库中的数据按照一定的数据模型组织，描述和存储，具有娇小的冗长度，较好的数据独立性和易扩展性，并可以为各种用户共享，所以数据库具有，永久存储、有组织和可共享这三个基本特点。</p>
<p>除了有数据库外还得有数据库管理系统，才能对数据更好的管理。</p>
<h2 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h2><blockquote>
<p>科学的组织和存储数据，可以高效的获得和维护数据。</p>
</blockquote>
<p>数据库管理系统和操作系统一样是计算机的基础的软件，也是一个大型复杂的软件系统，主要功能包括这几个方面：数据的操作功能，数据库的事务管理和运行管理、数据定义功能、数据组织、存储和管理数据的建立和维护功能。</p>
<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p>是指在计算机系统中引入数据库后的系统。</p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><blockquote>
<p>结构化查询语言</p>
</blockquote>
<p>SQL是目前广泛使用的关系数据库语言标准语言。</p>
<h2 id="SQL的组成部分"><a href="#SQL的组成部分" class="headerlink" title="SQL的组成部分"></a>SQL的组成部分</h2><ul>
<li>数据操作语言（DML）</li>
</ul>
<blockquote>
<p>实现对数据的操作，用于检索或修改数据。</p>
</blockquote>
<ul>
<li>数据定义语言 （DDL）</li>
</ul>
<blockquote>
<p>用于定义数据的结构，创建、修改或删除数据库对象。</p>
</blockquote>
<ul>
<li>数据控制语言 （DCL）</li>
</ul>
<blockquote>
<p>用于控制数据库用户的权限。</p>
</blockquote>
<ul>
<li>事务语言 （TCL）</li>
</ul>
<blockquote>
<p>定义了包含事务开始和结束的相关命令。</p>
</blockquote>
<ul>
<li>DLL包含的子部分<ul>
<li>完整性约束</li>
<li>视图定义</li>
</ul>
</li>
</ul>
<p>SQL的优点：</p>
<ul>
<li>几乎所有的数据库都支持SQL语言。</li>
<li>简单易学。</li>
<li>高度非过程化。</li>
</ul>
<h2 id="SQL语句规范"><a href="#SQL语句规范" class="headerlink" title="SQL语句规范"></a>SQL语句规范</h2><ul>
<li>SQL语句不分大小写，但字符常量需要区分大小写，建议命令大写，表名库名小写。</li>
<li>SQL语句可单行或多行书写，以分号结尾。</li>
<li>用空格和缩进来提高语句可读性。</li>
<li>注释有三种方式<ol>
<li>单行注释可以用#</li>
<li>单行注释也可以用–，–与注释之间有空格</li>
<li>多行注释可用&#x2F;**&#x2F;</li>
</ol>
</li>
</ul>
<h2 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h2><p>在MYSQL数据空中有许多的数据库，可以用<code>show databases;</code>命令来查看所有数据库。</p>
<ul>
<li><code>information_schema</code> #主要存储了系统的一些数据库对象信息。</li>
<li><code>mysql</code>#MYSQL的核心数据库，主要负责存储数据库用户的，用户访问权限等MYSQL自己需要使用的控制和管理信息。</li>
<li><code>performance_schema</code>#主要用于收集数据库服务器性能参数。</li>
<li><code>sys</code>#数据库提供一些视图，数据都来自<code>performance_schema</code>，主要为了让开发者和使用者刚方便的查看性能问题。</li>
</ul>
<p>想要知道当前操作的是哪个数据库可用<code>select database();</code>命令来查询。<br>想使用哪个数据库可用<code>use+库名;</code>命令。<br>想要知道在此数据库下有什么表可以用<code>show tables;</code>命令来查询。<br>想要知道某些数据的表结构可以用<code>dese 表名;</code>命令来查找。<br>如果要自己创建数据库用<code>create database 库名;</code>命令创建。但是如果数据库里已经有同名的了，就会提示创建失败，所有我们在创建之前可以先判断一下，用<code>create database if not exists 库名;</code>命令。<br>如果想要删除数据库用<code>drop database 库名;</code>命令。</p>
<h2 id="数据库的基本查询"><a href="#数据库的基本查询" class="headerlink" title="数据库的基本查询"></a>数据库的基本查询</h2><p>SQL数据库查询用select语句来查询。</p>
<h3 id="查询多个字段"><a href="#查询多个字段" class="headerlink" title="查询多个字段"></a>查询多个字段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select 字段,字段 from 表;</span><br><span class="line"># 查询所有字段</span><br><span class="line">select 字段,字段 from 表; # 中间写上所有的字段</span><br><span class="line">select * from 表;  # 影响效率，不直观</span><br><span class="line"># 查询字段，起别名</span><br><span class="line">select 字段,字段 AS&#x27;别名&#x27; from 表;</span><br><span class="line">select 字段,字段 &#x27;别名&#x27; from 表;</span><br><span class="line"># 查询字段，里面的信息不要重复的</span><br><span class="line">select distinct 字段 from 表; # 有多个字段就无效了</span><br><span class="line"># 在SQL语句中是支持我们简单的运算的</span><br><span class="line">select 字段*数字 from 表; # 支持+ - * /(DIV) %(MOD)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><blockquote>
<p>select 字段,字段 from 表 WHERE 条件; WHERE的条件是不能使用统计函数的</p>
</blockquote>
<p>条件运算符</p>
<table>
<thead>
<tr>
<th>关系运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>！&#x3D;或&lt;&gt;</td>
<td>不等于</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>逻辑算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>AND或&amp;&amp;</td>
<td>并且(多个条件同时成立)</td>
</tr>
<tr>
<td>OR或&#x7C; &#x7C;</td>
<td>或者(多个条件任意成立一个)</td>
</tr>
<tr>
<td>not或！</td>
<td>非，不是</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>其他</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>between…and…</td>
<td>在某个范围之间(含最小最大值)</td>
</tr>
<tr>
<td>in(…)</td>
<td>在in后列表中的值，多选一</td>
</tr>
<tr>
<td>lile</td>
<td>模糊匹配(_匹配单个字符，%匹配任意个字符)</td>
</tr>
<tr>
<td>is[not]null</td>
<td>是null</td>
</tr>
</tbody></table>
<p>MySQL也是可以通过表名来进行访问的。</p>
<h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><blockquote>
<p>SQL允许对表中的数据进行计算，将一列数据作为整体，进行纵向计算</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>max</td>
<td>返回某列的最高值(没有返回null)</td>
</tr>
<tr>
<td>min</td>
<td>返回某列的最低值(没有返回null)</td>
</tr>
<tr>
<td>count</td>
<td>返回某列的行数(不包括null)</td>
</tr>
<tr>
<td>count(*)</td>
<td>返回被选列行数</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
<tr>
<td>avg</td>
<td>求平均值</td>
</tr>
</tbody></table>
<p>count可以用于任何的数据类型(因为他只用来计数)，而sum和svg都只能对数值类型做计算，max和min可用于数值，字符串或是日期时间数据类型。</p>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 分组字段/聚合函数 from 表名 [where 条件] group by /*去重*/ 分组字段 [having 分组后条件]; </span><br></pre></td></tr></table></figure>

<h4 id="主意事项"><a href="#主意事项" class="headerlink" title="主意事项"></a>主意事项</h4><p>在语法中，分组字段&#x2F;聚合函数必须在group by中出现否则使用是违法的。<br>如果语句种没有出现group by那么select字段中，只能出现统计函数，不允许出现其他字段函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误样例：</span><br><span class="line">SELECT job,sal FROM emp GROUP BY job;</span><br><span class="line">SELECT enmae,MAX(sal) FROM emp;</span><br></pre></td></tr></table></figure>

<h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><blockquote>
<p>通过条件查询语句查到用户想要的数据，但是输出数据的顺序一般是最初添加到表的顺序来的，为了使输出的顺序是用户需要的，MYSQL提供了ORDER BY 关键字来对查询的结果进行排序。</p>
</blockquote>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段名 FROM 表名...ORDER BY 排序字段名 [ASC/DESC];</span><br></pre></td></tr></table></figure>

<h4 id="语法注意"><a href="#语法注意" class="headerlink" title="语法注意"></a>语法注意</h4><ul>
<li>排序字段名:表示需要排序的字段名，多个字段时用字段隔开。</li>
<li>ASC&#x2F;DESC:ASC表示字段按升序排列,DESC表示字段按降序排列。ASC是默认值。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>ORDER BY一般放在查询语句的最后面，LIMIT字段除外。</li>
<li>当字段中出现空值时，默认空值按最小值对待。</li>
<li>ORDER BY指定多个字段进行排序的时候，MYSQL会按字段的顺序从左到右依次进行排序。</li>
<li><strong>注意：</strong> 对多个字段排序的时，排序的第一个字段必须有重复值时，才会对第二个字段进行排序。如果第一个字段中所有值都是是唯一的，则不会对第二个字段进行排序。</li>
</ul>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><blockquote>
<p>对于较多的数据，如果在一个页面显示，会看起来显得眼花缭乱，如果能进行分页显示，会更加快捷，清晰的浏览。</p>
</blockquote>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELEST 字段名 FROM LIMIT 起始索引,查询记录数;</span><br></pre></td></tr></table></figure>

<h4 id="语句特点"><a href="#语句特点" class="headerlink" title="语句特点"></a>语句特点</h4><ul>
<li>起始索引从0开始，起始索引&#x3D;(查询页码-1)*每页显示记录数。</li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写为LIMIT 10</li>
</ul>
<h2 id="数据库的函数"><a href="#数据库的函数" class="headerlink" title="数据库的函数"></a>数据库的函数</h2><p>MySQL函数会对传入的参数进行处理，并返回一个处理结果，也就是一个值。<br>由于函数比较多，我会记录一些常用的函数，罕见的可以到<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/functions.html">MySQL参考手册</a>去查询。</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>UPPER(列&#x7C;字符串)</td>
<td>将字符串的每个字符转化为大写</td>
</tr>
<tr>
<td>LOWER(列&#x7C;字符串)</td>
<td>将字符串的每个字符转化为小写</td>
</tr>
<tr>
<td>CONCAT(str1,str2,…)</td>
<td>将所有字符串连接成一个字符串</td>
</tr>
<tr>
<td>REPLACE(列&#x7C; 字符串,新字符串)</td>
<td>使新字符串替换旧字符串</td>
</tr>
<tr>
<td>LENGTH(列&#x7C; 字符串)</td>
<td>求字符串长度</td>
</tr>
<tr>
<td>SUBSTR(列&#x7C; 字符串,开始点[,长度])</td>
<td>字符串截取</td>
</tr>
<tr>
<td>LEFT(str,len)</td>
<td>获得字符串左边len个字符组成的字符串</td>
</tr>
<tr>
<td>RIGHT(str,len)</td>
<td>获得字符串右边len个字符组成的字符串</td>
</tr>
<tr>
<td>MID(str,pos,len)</td>
<td>获得字符串从pos(第几个)位置开始，长度为len的字符串</td>
</tr>
<tr>
<td>ASCII(字符)</td>
<td>返回于指定字符对应的十进制整数</td>
</tr>
<tr>
<td>CHR(数字)</td>
<td>返回与整数对应的字符</td>
</tr>
<tr>
<td>RPAD(列&#x7C; 字符串,长度,填充字符)LPAD(列&#x7C; 字符串,长度,填充字符)</td>
<td>用指定的字符在字符串的左或右填充</td>
</tr>
<tr>
<td>LTRIM(字符串),RTRIM(字符串)</td>
<td>去掉字符串左或右的空格</td>
</tr>
<tr>
<td>TRIM(列&#x7C;字符串)</td>
<td>去掉字符串左右空格</td>
</tr>
<tr>
<td>INSTR(列&#x7C;字符串,要查找的字符串,开始位置，出现位置)</td>
<td>查找一个子字符串是否在指定的位置上出现</td>
</tr>
</tbody></table>
<p>注： 1. SQL数据库给我们提供了一个虚拟表DUAL，用来给我们做测试用。</p>
<ol start="2">
<li>起别名可以在字段后面直接空格+别名。</li>
<li>SUBSTR(列&#x7C; 字符串,开始点[,长度])，长度可以是负数，就从后面数保留几位。</li>
</ol>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>round(小数[,位数])</td>
<td>对小数四舍五入</td>
</tr>
<tr>
<td>truncate(小数,位数)</td>
<td>截取，不会四舍五入</td>
</tr>
<tr>
<td>ceil(小数)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(小数)</td>
<td>向下取整</td>
</tr>
<tr>
<td>rand()</td>
<td>生成[0,1]之间的随机数</td>
</tr>
<tr>
<td>注：1. 位数要是负数就是表示当前整数的对应位置取0，向上进位的;负数的绝对值不能高于数字的最高位。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="时间日期函数"><a href="#时间日期函数" class="headerlink" title="时间日期函数"></a>时间日期函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE(),CURRENT_DATE</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME(),CURRENT_TIME</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW(),CURRENT_TIMESTAMP().LOCALTIME(),SYSDATE(),LOCALTIMESTAMP()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(日期)</td>
<td>返回日期中的年份</td>
</tr>
<tr>
<td>MONTH(日期)</td>
<td>返回日期中的月份[1,12]</td>
</tr>
<tr>
<td>DAY(日期)</td>
<td>返回日期中的天[1,31]</td>
</tr>
<tr>
<td>HOUR(时间)</td>
<td>返回时间中的小时</td>
</tr>
<tr>
<td>MINUTE(时间)</td>
<td>返回时间中的分钟</td>
</tr>
<tr>
<td>SECOND(时间)</td>
<td>返回时间中的秒</td>
</tr>
<tr>
<td>WEEKDAY(日期)</td>
<td>返回星期几，0是星期一，1是星期二</td>
</tr>
<tr>
<td>DAYOFWEEK(日期)</td>
<td>返回星期几，1是星期日，2是星期一</td>
</tr>
<tr>
<td>DAYOFYEAR(日期)</td>
<td>计算指定日期是本年第几天</td>
</tr>
<tr>
<td>DAYOFMONTH(日期)</td>
<td>计算指定日期是本月第几天</td>
</tr>
<tr>
<td>QUARTER(日期)</td>
<td>计算日期是本年的第几季度</td>
</tr>
<tr>
<td>TIME_TO_TIME(time)</td>
<td>将指定时间转换位秒</td>
</tr>
<tr>
<td>SEC_TO_TIME(sec)</td>
<td>将以秒为单位的时间转化为时分秒的形式</td>
</tr>
<tr>
<td>DATEDIFF(d1,d2)</td>
<td>计算两个日期相隔的天数</td>
</tr>
<tr>
<td>ADDDATE(date,n)</td>
<td>计算指定日期加上n天后的日期</td>
</tr>
<tr>
<td>SUBDATE(date,n)</td>
<td>计算两个日期相隔的天数</td>
</tr>
<tr>
<td>ADDTIME(time,n)</td>
<td>计算指定时间加上n天后的时间</td>
</tr>
<tr>
<td>SUBTIME(time,n)</td>
<td>计算指定时间减去n秒后的时间</td>
</tr>
<tr>
<td>DATE_FORMAT(date,f)</td>
<td>按格式返回日期</td>
</tr>
<tr>
<td>TINE_FORMAT(time,f)</td>
<td>按格式返回时间</td>
</tr>
</tbody></table>
<p>注: 再格式化返回时间的时候注意%后面的字母的大小写，表示时间不是%m是%i。</p>
<h3 id="条件判断函数"><a href="#条件判断函数" class="headerlink" title="条件判断函数"></a>条件判断函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>IF(expr,v1,v2)</td>
<td>如果表达式expr成立，返回结果v1，否则，返回结果v2</td>
</tr>
<tr>
<td>IFNULL(v1,v2)</td>
<td>如果v1的值不为NULL，则返回v1，否则返回v2</td>
</tr>
<tr>
<td>CASE</td>
<td>分支</td>
</tr>
</tbody></table>
<p>case有两种语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法一：</span><br><span class="line">CASE</span><br><span class="line">    WHEN expr1 THEN V1</span><br><span class="line">    WHEN expr2 THEN V2</span><br><span class="line">    ......</span><br><span class="line">    ELSE vn</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法二：</span><br><span class="line">CASE expr</span><br><span class="line">    WHEN e1 THEN V1</span><br><span class="line">    WHEN e2 THEN V2</span><br><span class="line">    ......</span><br><span class="line">    ELSE vn</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><h4 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h4><blockquote>
<p>系统信息函数用来查询MYSQL数据库信息。</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>VERSION</td>
<td>返回数据库的版本号</td>
</tr>
<tr>
<td>CONNECTION_ID()</td>
<td>返回数据库连接id</td>
</tr>
<tr>
<td>DATABASE()、SCHEMA</td>
<td>返回服务器名</td>
</tr>
<tr>
<td>USER()、SYSTEN_USER()、SESSION_USER()、CURRECT_USER()、CURRENT_USER()</td>
<td>返回当前用户</td>
</tr>
<tr>
<td>CHARSET(str)</td>
<td>返回字符串str的字符集</td>
</tr>
<tr>
<td>COLLATION(str)</td>
<td>返回字符串str的字符排列方式</td>
</tr>
</tbody></table>
<h4 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h4><blockquote>
<p>加密函数是MYSQL用来对数据进行加密的函数</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>MD5(str)</td>
<td>对字符串进行散列，可以用于一些普通的不需要解密的数据加密，如密码</td>
</tr>
<tr>
<td>sha1</td>
<td>对字符串进行散列，可以用于一些普通的不需要解密的数据加密，如密码比MD5更安全</td>
</tr>
</tbody></table>
<h4 id="其他的函数"><a href="#其他的函数" class="headerlink" title="其他的函数"></a>其他的函数</h4><ul>
<li>进制转换</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>BIN(x)</td>
<td>返回x的二进制</td>
</tr>
<tr>
<td>HEX(x)</td>
<td>返回x的十六进制</td>
</tr>
<tr>
<td>OCT(x)</td>
<td>返回x的八进制</td>
</tr>
<tr>
<td>CONV(x,from_base,to_base)</td>
<td>将form_base进制的x，转成to_base进制</td>
</tr>
</tbody></table>
<ul>
<li>ip地址转换</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>INET_ATON(IP)</td>
<td>将点分十进制的ip地址转化为数字</td>
</tr>
<tr>
<td>INET_NTOA(numben)</td>
<td>将数字形式的IP转化为点分十进制</td>
</tr>
</tbody></table>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><blockquote>
<p>表之间的关系基本分为三种，一对多（多对一），多对多，一对一</p>
</blockquote>
<p>我们经常需要查询的时候需要多个表的数据，这就是所谓的联合查询，<br>在具体的实现操作时，首先将两个或两个以上的表按照某个条件连接起来，然后再查询到所要求的数据记录。连接查询分为交叉连接、内连接、外连接查询三种方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询例子：</span><br><span class="line"># 首先需要这两个表是有关系的，外键连接主键</span><br><span class="line">SELECT * FROM emp,dept; #出现的结果时笛卡尔积，结果行数是emp行数和dept行数的乘积。</span><br><span class="line"># 要是需要正确的，需要where语句</span><br><span class="line">SELECT * FROM emp,dept WHERE emp.depton=dept.depton;</span><br><span class="line"># 如果，表名太长可以取别名，但是在这条语句中原来的名字是不能用的了。</span><br></pre></td></tr></table></figure>

<h3 id="等值连接vs不等值连接"><a href="#等值连接vs不等值连接" class="headerlink" title="等值连接vs不等值连接"></a>等值连接vs不等值连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询例子：</span><br><span class="line"># 等值连接</span><br><span class="line">SELECT * FROM emp,dept WHERE emp.depton=dept.depton;</span><br><span class="line"># where的条件用=连接了，所以是等值连接</span><br><span class="line"># 不等值连接</span><br><span class="line">SELECT * FROM emp,salgrade WHERE emp.sal between salgrade.locate and salgrade.hisal;</span><br></pre></td></tr></table></figure>

<h3 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h3><p>内连接：在连接条件不成立的时候，条件为NULL或匹配不到数据的时候，左表数据不显示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1. 隐式内连接</span><br><span class="line">SELECT * FROM emp,dept WHERE emp.depton=dept.depton; </span><br><span class="line">2.显示内连接</span><br><span class="line">SELECT * FROM emp INNET JOIN dept ON emp.depton=dept.depton;# INNET JOIN相当于&#x27;,&#x27;了</span><br></pre></td></tr></table></figure>

<p>外连接：连接条件不成立的时候也会显示，外连接分为左外连接，右外连接，全外连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1.左外连接,左边显示</span><br><span class="line">SELECT * FROM emp LEFT JOIN dept ON emp.depton=dept.depton;</span><br><span class="line">2.右外连接，右边显示</span><br><span class="line">SELECT * FROM emp RIGHT JOIN dept ON emp.depton=dept.depton;</span><br><span class="line">3.全外连接，两边表中的数据都显示，这是运行不了的，因为MYSQL不支持，但是其他的sql支持</span><br><span class="line">SELECT * FROM emp FULL JOIN dept ON emp.depton=dept.depton;</span><br></pre></td></tr></table></figure>

<h3 id="七种JOIN实现"><a href="#七种JOIN实现" class="headerlink" title="七种JOIN实现"></a>七种JOIN实现</h3><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220914170628495.png" alt="image-20220914170628495"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">左上图：左外连接</span><br><span class="line">SELECT * FROM emp LEFT JOIN dept ON emp.depton=dept.depton;</span><br><span class="line">右上图：右外连接</span><br><span class="line">SELECT * FROM emp RIGHT JOIN dept ON emp.depton=dept.depton;</span><br><span class="line">左中图，在左外连接的基础上，去掉满足条件的记录</span><br><span class="line">SELECT * FROM emp LEFT JOIN dapt ON emp.dapton=dapt.dapton WHERE emp.depton IS NULL;#只要不满条件的，连接条件不匹配或者为null的</span><br><span class="line">右中图</span><br><span class="line">SELECT * FROM emp RIGHT JOIN dept ON emp.depton=dept.depton WHERE dapt.deptom IS NULL;</span><br><span class="line">左上图和右中图连接就是全外连接</span><br><span class="line">SELECT * FROM emp LEFT JOIN dept ON emp.depton=dept.depton UNION #并集 SELECT * FROM emp RIGHT JOIN dept ON emp.depton=dept.depton WHERE dapt.deptom IS NULL;</span><br><span class="line">用左中图和右中图连接时右下图</span><br><span class="line">SELECT * FROM emp LEFT JOIN dapt ON emp.dapton=dapt.dapton WHERE emp.depton IS NULL UNION SELECT * FROM emp RIGHT JOIN dept ON emp.depton=dept.depton WHERE dapt.deptom IS NULL;</span><br></pre></td></tr></table></figure>

<h3 id="自连接与并集运算"><a href="#自连接与并集运算" class="headerlink" title="自连接与并集运算"></a>自连接与并集运算</h3><p>隐式连接当想让两个表通过相同字段连接在一起可以用USING()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：SELECT * FROM JOIN dept USING(depton);</span><br></pre></td></tr></table></figure>

<p>自连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：SELECT e.empno,e.ename,m.ename 领导 FROM emp e,emp m</span><br><span class="line">WHERE e.mgr=m.empon;</span><br></pre></td></tr></table></figure>

<p>集合运算，MYSQL只支持并集运算 UNION DISTINCT和UNION ALL，UNION后面什么也不写，默认是DISTINCT<br>要求：</p>
<ol>
<li>输入的查询不能包换ORDER BY 字句，可以为整个集合运算结果选择性的增加一个ORDER BY字句</li>
<li>两个查询必须包含相同的列数</li>
<li>集合运算结果中列名由输入的查询1决定，如果要为结果分配结果列，应该在输入的查询1中分配相应的别名</li>
<li>集合运算时，对行进行比较时，集合运算认为两个null相等</li>
<li>相应列必须具有兼容的数据类型。兼容个的数据类型:优先级较低的数据类型必须能隐式地转换为较高级的数据类型。比如输入的查询1的第一列为int类型，输入的查询2的第一列为float类型，则较低的数据类型int类型可以隐式地转换为较高级float类型。如果输入的查询1的第一列为char类型，输入的查询2的第一列为datetime类型，则会提示转换失败:从字符串转换日期和&#x2F;或时间时，转换失败</li>
</ol>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="子查询概念"><a href="#子查询概念" class="headerlink" title="子查询概念"></a>子查询概念</h3><p>子查询是指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MYSQL4.1开始引入的。</p>
<p>在特定情况下，一个查询语句的条件需要另一个语句来获取，内层查询语句的查询结果，可以为外层查询语句提供查询条件。</p>
<blockquote>
<p>内层查询即子查询，外层查询即主查询，只是叫法不同</p>
</blockquote>
<h3 id="查询规范"><a href="#查询规范" class="headerlink" title="查询规范"></a>查询规范</h3><ol>
<li>子查询必须放在小括号里</li>
<li>子查询一般放在比较操作符的右边，以增强代码可读性</li>
<li>子查询可以出现在几乎所有的SELECT字句中（如：SELECT、FROM、WHERE、ORDER BY、HAVING子句）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">SELECT * FROM emp WHERE sal=(SELECT MIN(sal) FROM emp );</span><br></pre></td></tr></table></figure>

<p>按照查询返回的结果分类：<br>标量查询：返回一个标量（一个值）单行单列<br>列子查询：返回的是单行多列<br>列子查询：返回的是多行多列<br>表子查询：查询的是一个表</p>
<p>按照子查询和主查询之间是否有条件关联分类<br>相关子查询：两个查询之间有一定的条件关联（相互联系）<br>不想关子查询：两个查询之间没有条件关联（相互独立）</p>
<p>为了方便，对于在何处使用子查询的建议：</p>
<ul>
<li>子查询出现在WHERE子句中：此时查询返回的结果一般都是单行单列，单行多列，多行多列</li>
<li>子查询出现在HAVING字句中：此时子查询返回的都是单行单列数据，同时为了使用统计函数操作</li>
<li>子查询出现在FROM子句中：此时子查询返回的结果图一般都是多行多列，可以按照一张数据表（临时表）的形式操作</li>
</ul>
<h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><p>查询出来的是一个值，用到的符号有&gt;(大于) &lt;(小于) &lt;&gt;(不等于) ！&#x3D;(不等于)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">SELECT * FROM emp HWERE sal&gt;(SELECT MIN(sal) FROM emp );</span><br></pre></td></tr></table></figure>

<h3 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">SELECT * FROM emp WHERE job=(SELECT job FROM emp WHERE ename=&#x27;SCOTT&#x27;)AND sal=(SELECT sal FROM emp WHERE ename=&#x27;SCOTT&#x27;)AND ename&lt;&gt;&#x27;SCOTT&#x27;;</span><br><span class="line">上面的可以改写为单行子查询</span><br><span class="line">SELECT * FROM emp WHERE (job,sal)=(SELECT job，sal FROM emp WHERE ename=&#x27;SCOTT&#x27;)AND ename&lt;&gt;&#x27;SCOTT&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="列子查询（多行查询）"><a href="#列子查询（多行查询）" class="headerlink" title="列子查询（多行查询）"></a>列子查询（多行查询）</h3><blockquote>
<p>子查询返回的是多行单列数据，就是一列数据。多行查询也称为集合比较子查询</p>
</blockquote>
<p>在使用多行子查询·需要使用多行比较操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>等于列表中的任意一个</td>
</tr>
<tr>
<td>ANY</td>
<td>需要和单行比较操作符一起使用(&gt;、&lt;、&#x3D;、&lt;&gt;…)，与子查询结果中的任何一个值比较，一个成立</td>
</tr>
<tr>
<td>ALL</td>
<td>需要和单行比较操作符一起使用(&gt;、&lt;、&#x3D;、&lt;&gt;…)，和子查询返回的所有值比较，同时成立</td>
</tr>
<tr>
<td>SOME</td>
<td>实际上是ANY的别名，作用相同，一般用ANY</td>
</tr>
</tbody></table>
<h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">SELECT d.deptno,d.dname,d.loc,temp.count,temp.avgsal</span><br><span class="line">FROM dept d,(SELECT depton,COUNT(depton) count,ROUND(AVG(sal),2) vagsal FROM emp GROUP BY depton) temp /*临时表必须起别名要不调用了*/WHERE d.depton=temp.depton;</span><br><span class="line"></span><br><span class="line">### HAVING子句中的子查询</span><br><span class="line"></span><br><span class="line">```MYSQL</span><br><span class="line">例子：</span><br><span class="line">SELECT dept.dname,ROUND(AVG(sal),2) av</span><br><span class="line">FROM emp e, dept</span><br><span class="line">WHERE e.deptno=dept.deptno</span><br><span class="line">GROUP BY dept.dname</span><br><span class="line">HAVING av&gt;=(SELECT MAX(temp.av)</span><br><span class="line">FROM(SELECT AVG(sal)  av FROM emp GROUP BY deptno) temp);</span><br></pre></td></tr></table></figure>

<h3 id="SELECT子句中子查询"><a href="#SELECT子句中子查询" class="headerlink" title="SELECT子句中子查询"></a>SELECT子句中子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例子：查询公司每个部门的编号、名字、位置、部门人数、平均工资的三种写法</span><br><span class="line">1.正常查询</span><br><span class="line">SELECT d.deptno,d.dname,d.loc,COUNT(d.deptno),AVG(e.sal)</span><br><span class="line">FROM emp e RIGHT JOIN dept d</span><br><span class="line">ON e.deptno=d.deptno</span><br><span class="line">GROUP BY d.deptno;</span><br><span class="line">2.from子句查询</span><br><span class="line">SELECT d.deptno,d.dname,d.loc,t.c,t.av</span><br><span class="line">FROM dept d,(SELECT e.deptno,COUNT(e.deptno) c,AVG(e.sal) av FROM emp e GROUP BY e.deptno ) t</span><br><span class="line">WHERE t.deptno=d.deptno;</span><br><span class="line">3.select子句查询</span><br><span class="line">SELECT d.deptno,d.dname,d.loc,</span><br><span class="line">(SELECT COUNT(deptno) FROM emp WHERE deptno=d.deptno),</span><br><span class="line">(SELECT AVG(sal) FROM emp WHERE deptno=d.deptno)</span><br><span class="line">FROM dept d;</span><br></pre></td></tr></table></figure>

<h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>如果子查询的执行依赖外部查询，通常情况下都是因为子查询中的表用到了外部表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就成为关联子查询。</p>
<p>相关子查询按照一行接一行的顺序指针，主查询的每一行都指向一次子查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">不相关子查询</span><br><span class="line">SELECT *</span><br><span class="line">FROM emp </span><br><span class="line">WHERE sal&gt;</span><br><span class="line">(SELECT sal FROM emp WHERE ename=&#x27;SCOTT&#x27;</span><br><span class="line">);</span><br><span class="line">相关子查询</span><br><span class="line">SELECT e.deptno,e.ename,e.sal</span><br><span class="line">FROM emp e</span><br><span class="line">WHERE sal&gt;</span><br><span class="line">(SELECT AVG(sal) FROM emp WHERE e.deptno=deptno</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="WITH和EXISTX语句"><a href="#WITH和EXISTX语句" class="headerlink" title="WITH和EXISTX语句"></a>WITH和EXISTX语句</h3><p>公共表表达式(WITH)是一个命名的临时结果集，存在于单个语句的范围内，定义后可以在该语句中引用它，可以多次引用。</p>
<p>在SQL中提供了一个existx结构用于判断子查询是否有数据返回。如果子查询中有数据返回，existx结构返回true，否则返回false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">WITH</span><br><span class="line">  temp AS(SELECT depton,MAX(sal) maxsal FROM emp GROUP BY depton)</span><br><span class="line">  SELECT e.empon,e.ename,e.job,e.hiredate, e.sal,d.deptno,d.dname</span><br><span class="line">  FROM emp e</span><br><span class="line">  JOIN dapt d ON e.deptno=d.deptno</span><br><span class="line">  JOIN ON e.deptno=t.depton AND e.sal=t.maxsal;</span><br></pre></td></tr></table></figure>

<h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><blockquote>
<p>使用<code>INSERT INTO</code>语句来向表中插入数据。</p>
</blockquote>
<p>语法：</p>
<ol>
<li>给指定字段添加数据<br><code>INSERT INTO表名 (字段1，字段2....)VALUES (value1,value2....);# value与字段是一一对应的</code></li>
<li>给全部字段添加数据<br><code>INSERT INTO 表名 VALUES (value1,value2....);</code></li>
<li>批量添加数据(用单条INSERT语句处理多个插入要比使用多条INSERT语句更快)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名(字段1，字段2...) VALUES (value1,value2....)</span><br><span class="line">                                 VALUES (value1,value2....)</span><br><span class="line">                                 VALUES (value1,value2....)</span><br><span class="line">                                 .........;</span><br></pre></td></tr></table></figure>

<p>语法说明如下：</p>
<ul>
<li>&lt;表名&gt;：指定被操作的表名。</li>
<li>&lt;列表&gt;：指定需要插入数据的列表。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用<code>INSERT INTO 表名 VALUES (value1,value2....);</code>即可。</li>
<li>VALUES或VALUE语句：该子句包含要插入的数据清单。数据清单数据的顺序要个列的顺序相对应。</li>
</ul>
<p>如果想把一个表的数据拷贝到令一张表上可以用：<br><code>INSERT INTO 表名 SELECT * FROM 表名 WHERE 条件;</code><br><code>INSERT INTO 表名(字段1，字段2....) SELECT * FROM 表名 WHERE 条件;</code></p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>使用UPDATE…SET语句来修改表中的数据。<br>语法：<br><code>UPDATE 表名 SET 字段= value[字段1=value,...][WHERE 子句][ORDER BY 子句][LIMIT 子句];</code><br>语法说明如下：</p>
<ul>
<li>&lt;表名&gt;： 用指定要更新的表名称。</li>
<li>SET子句： 用于指定表中要修改的列名及其列值。其中，每个只当的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可以用关键字DEFAULT表示列值。</li>
<li>WHERE子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。</li>
<li>ORDER BY子句：可选项。用于限定表中的行被修改的次序。</li>
<li>LIMIT子句：可选项。用于限定被修改的行数。</li>
<li>注意：在不使用WHERE条件的时候，将修改所有记录的字段。</li>
</ul>
<p>当一个UPDATE语句中出现查询语句的时候时，查询语句要变成一张临时表才可以，否则会报错。</p>
<p>在修改数据中ORDER BY需要和LIMIT联合使用</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>使用 DELETE FROM语句来删除表中的数据。<br>语法：<br><code>DELETE FROM 表名 [WHERE 子句][ORDER BY 子句][LIMIT 子句];</code><br>语法说明：</p>
<ul>
<li>&lt;类名&gt;：指定要删除数据的表名</li>
<li>ORDER BY子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。</li>
<li>WHERE子句：可选项。表示为删除操作限定删除条件，若省略该句子，则代表该表中的所有行。</li>
<li>LIMIT子句：可选项。用于告知服务器在控制命令被返回到客服端被删除行的最大值。</li>
<li>注意：在不使用WHERE条件的时候，将删除所有数据。</li>
</ul>
<h2 id="表管理"><a href="#表管理" class="headerlink" title="表管理"></a>表管理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="表的基本概念"><a href="#表的基本概念" class="headerlink" title="表的基本概念"></a>表的基本概念</h4><p>在MYSQL数据库中，表是一种很重要的数据库对象，是组成数据库的基本元素，由若干的字段组成，主要用来实现数据库记录。表的操作包含创建表、查看表、删除表和修改表。这些操作是数据库对象的管理中，最基本、最重要的操作。</p>
<ul>
<li>表的相关概念；</li>
<li>表的基本操作：创建、查找、更新、删除；</li>
<li>表的使用策略。</li>
</ul>
<p>表是包含数据库中所有数据的数据库对象。数据在表中的组织方式与在电子表格中的相似，都是按行和列的格式组织的。其中每一行代表一条唯一的记录，每一列代表记录中的一个字段。</p>
<h4 id="标识符命名规范"><a href="#标识符命名规范" class="headerlink" title="标识符命名规范"></a>标识符命名规范</h4><ol>
<li>数据库名，表名不能超过三十个字符，变量名现在为29个</li>
<li>只能包含大写、小写、数字字符以及下划线</li>
<li>同一个MYSQL软件中，数据库不能同名；同一个库中，表不能同名；同一个表中，字段不能重名</li>
<li>不能和保留字、函数名冲突</li>
<li>保留子段名和类名一致性：假如某个字段在一个表里面是整型，那在另一个表里面可就别变成字符串了</li>
</ol>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line">CREATE DATABASE 库名;</span><br><span class="line">方式二：</span><br><span class="line">CREATE DATABASE 库名 CHARACTER SET &#x27;编码格式&#x27;;</span><br><span class="line"># gdk格式是专门用于中文的编码格式，UTF8是全球通用的，一般出现乱码，就是这两个字符集转换出现错误</span><br><span class="line">方式三(推荐)：</span><br><span class="line">CREATE DATABASE IF NOT EXISTS 库名 CHARACTER SET &#x27;编码格式&#x27;;</span><br><span class="line">查看创建数据库时使用的语句：</span><br><span class="line">SHOW CREATE DATABASE 库名;</span><br><span class="line">查看所有的数据库</span><br><span class="line">SHOW DATABASES;</span><br><span class="line">使用数据库</span><br><span class="line">USE 数据库名;</span><br><span class="line">查看当前使用的数据库</span><br><span class="line">SELECT DATABASE();</span><br><span class="line">查看数据库下面所有的表</span><br><span class="line">SHOW TABLES FROM 库名;</span><br><span class="line">修改数据库-&gt;由于数据库不能再次改名字，所以起名字的时候要慎重。</span><br><span class="line">ALTER DATABASE 库名 CHARACTER SET &#x27;字符集&#x27;;</span><br><span class="line">查看数据库支持的字符集</span><br><span class="line">SHOW CHARSET;</span><br><span class="line">查看默认字符集</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%character%&#x27;;</span><br><span class="line">删除数据库</span><br><span class="line">DROP DATABASE IF EXISTS  库名;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>具体类型</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>TINYINT,SMALLINT,MEDIUMINT,INT(或INTEFER),BIGINT</td>
</tr>
<tr>
<td>浮点类型</td>
<td>FLOAT,DOUBLE</td>
</tr>
<tr>
<td>定点数类型（精度最高）</td>
<td>DECIMAL</td>
</tr>
<tr>
<td>位类型</td>
<td>BIT</td>
</tr>
<tr>
<td>日期时间类型</td>
<td>YEAR,TIME,DATE,DATETIME,TIMESTAMP</td>
</tr>
<tr>
<td>文本字符串类型</td>
<td>CHAR,VARCHAR,TINYTEXT,TEXT,MEDIUMTEXT,LONGTEXT</td>
</tr>
<tr>
<td>枚举类型</td>
<td>ENUM</td>
</tr>
<tr>
<td>集合类型</td>
<td>SET</td>
</tr>
<tr>
<td>二进制字符串类型</td>
<td>BINARY,VARBINARY,TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOB</td>
</tr>
<tr>
<td>json类型</td>
<td>JSON对象,JSON数组</td>
</tr>
<tr>
<td>空间数据类型（不常用）</td>
<td>单值：GEMETRY,POINT,LINESTRING,POLYGON集合：MULTPOINT,MULTILINESTRING,MULTIPOLGON,GEOMTRYCOLLECTION</td>
</tr>
</tbody></table>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220922141332424.png" alt="image-20220922141332424"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">创建表：</span><br><span class="line">方法一：</span><br><span class="line">CREATE TABNE 表名</span><br><span class="line">(</span><br><span class="line">  属性 类型,</span><br><span class="line">  属性 类型,</span><br><span class="line">  ......</span><br><span class="line">)[CHARACTER SET &#x27;字符集&#x27;];</span><br><span class="line"></span><br><span class="line">方法二：基于其他的表创建新表</span><br><span class="line">单个表：</span><br><span class="line">CREATE TABNE 表名</span><br><span class="line">AS</span><br><span class="line">SELECT 字段,...FROM 库名.表名;</span><br><span class="line">多个表：把所有的属性和内容都复制下来了</span><br><span class="line">CREATE TABNE 表名</span><br><span class="line">AS</span><br><span class="line">SELECT 字段,...</span><br><span class="line">FROM 库名.表名,..... WHERE 条件;</span><br><span class="line">想要只复制属性，不复制数据可以：</span><br><span class="line">CREATE TABNE 表名</span><br><span class="line">AS</span><br><span class="line">SELECT 字段,...</span><br><span class="line">FROM 库名.表名,..... WHERE 1=2;选择一个永远不成立的条件</span><br><span class="line">查看表</span><br><span class="line">SHOW TABLE FROM 表名;</span><br><span class="line">查看表结构</span><br><span class="line">DESC 表名;</span><br><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在创建完表和库后很久后可能会忘记，就需要我们来写注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">CREATE TABNE 表名</span><br><span class="line">(</span><br><span class="line">  属性 类型 COMMENT &#x27;注释&#x27;,</span><br><span class="line">  属性 类型 COMMENT &#x27;注释&#x27;,</span><br><span class="line">  ......</span><br><span class="line">)COMMENT &#x27;注释&#x27;;</span><br><span class="line">用这种方法就可以在过了很久以后能知道每个属性是干什么的了</span><br><span class="line">修改字段注释：</span><br><span class="line">ALTRE TABLE  表名 MODIFY 字段 数据类型 COMMENT &#x27;新注释&#x27;;</span><br><span class="line">修改表的注释：</span><br><span class="line">ALTRE TABLE  表名 COMMENT &#x27;新注释&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>修改数据表的前提是数据库已经存在该表，修饰表指的是修改数据库中已存在的数据表的结构。修改数据表的操作也是数据库管理中必不可少的，就像画素描一样，话多了可以再用橡皮擦掉，画少了可以用笔加上。</p>
<ul>
<li>修改表名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">方法一：通过ALTER TABLE语句来修改表名</span><br><span class="line">ALTER TABLE &lt;旧表名&gt; RENAME[10]&lt;新表名&gt;;</span><br><span class="line">方法二：通过RENAME TABLE语句来修改表名</span><br><span class="line">RENAME TABLE&lt;旧表名&gt; TO &lt;新表名&gt;[，旧表名2 TO 新表名2]</span><br><span class="line">修改字符集</span><br><span class="line">ALTER TABLE 库名.表名 CONVERT TO CHARACTER SET &#x27;格式&#x27;;</span><br><span class="line">修改字段</span><br><span class="line">添加</span><br><span class="line">1.在最后面添加</span><br><span class="line">ALTER TABLE 表名 ADD 新字段 数据类型 ;</span><br><span class="line">2.在最前面添加</span><br><span class="line">ALTER TABLE 表名 ADD 新字段 数据类型  FIRST;</span><br><span class="line">3.在指定位置添加字段</span><br><span class="line">ALTER TABLE 表名 ADD 新字段 数据类型 AFTER 一个字段的名字;</span><br><span class="line">删除</span><br><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br><span class="line">修改</span><br><span class="line">1.修改字段的数据类型</span><br><span class="line">ALTER TABLE 表名 MODIFY 字段名 数据类型;</span><br><span class="line">2.修改字段名字</span><br><span class="line">ALTER TABLE 表名 CHANGE 字段名 新名字 数据类型;</span><br><span class="line">3.修改字段顺序</span><br><span class="line">  1.把字段放到第一个</span><br><span class="line">  ALTER TABLE 表名 MODIFY 新字段 数据类型  FIRST;</span><br><span class="line">  2.把字段放到指定字段后</span><br><span class="line">  ALTER TABLE 表名 MODIFY 新字段 数据类型 AFTER 一个字段的名字;</span><br><span class="line">删除表</span><br><span class="line">DROP TABLE IF EXISTS 表名;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="约束概念"><a href="#约束概念" class="headerlink" title="约束概念"></a>约束概念</h3><h4 id="为什么需要约束"><a href="#为什么需要约束" class="headerlink" title="为什么需要约束"></a>为什么需要约束</h4><p>对于已经创建好的表，虽然字段的数据类型决定了所能存储的数据类型，但是表中所存储的数据是否合法并没有进行检查。具体使用MYSQL软件时，如果对表中的数据做一些完整性检查操作，可能通过表的约束来完成。</p>
<p>数据完整性是指数据的精确性和可靠性。他是防止数据库中存在不符合语义规定的数据和防止因为错误信息的输入输出造成无效操作或错误信息而提出来的。</p>
<p>为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制，主要从一下赐个方面考虑：</p>
<ul>
<li>实体完整性 如：同一个表，不能存在两条完全一样的记录</li>
<li>域完整性 如：年龄范围0-120</li>
<li>引用完整性 如：员工部门一定在员工表里存在的</li>
<li>用户自定义完整性 如：用户名唯一</li>
</ul>
<h4 id="什么是约束"><a href="#什么是约束" class="headerlink" title="什么是约束"></a>什么是约束</h4><p>约束时表级的强制约束</p>
<h3 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h3><ol>
<li>根据约束的字段分类：单列约束、多列约束</li>
<li>根据约束的作用范围分类：列级约束、表级约束</li>
<li>根据约束的作用分类：非空约束、唯一约束、主键约束、自增长、外键约束、检查约束、默认约束</li>
</ol>
<p>创建约束：</p>
<ol>
<li>在创建表时添加约束</li>
<li>创建表之后添加约束</li>
</ol>
<h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><p>概念：<br>当数据库表中的某个字段上的内容不希望设置为NULL时，则可以使用NK约束进行设置。即NK约束在创建数据库表时为某些字段加上“NOT NULL”约束条件，保证所有记录中该字段都有值。如果用户在插入记录中，该字段为空值，则数据库管理系统会报错。</p>
<p>特点:</p>
<ul>
<li>默认情况下，所有类型的值都可以时NULL</li>
<li>一个表可以有很多字段指定非空约束</li>
<li>空串“”不等于NULL,0也不等于NULL，NULL也不等于NULL</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1.在创建时候</span><br><span class="line">CREATE TABNE 表名</span><br><span class="line">(</span><br><span class="line">  属性 类型 NOT NULL,</span><br><span class="line">  属性 类型 NOT NULL,</span><br><span class="line">  ......</span><br><span class="line">);</span><br><span class="line">当创建新的数据的时候，相对应的字段不能写null，会报错，提示不能填空，当创建数据的时候不写就会提示少写了一个数据。</span><br><span class="line">2.修改</span><br><span class="line">ALTER TABLE 表名 MODIFY 字段 类型 NOT NULL;</span><br><span class="line">当有数据为空的时候更改不了，会提示不明确，需要把所有数据都改为非空后才可以再执行此语句</span><br><span class="line">3.删除非空约束</span><br><span class="line">ALTER TABLE 表名 MODIFY 字段 类型 NULL;NULL可以省略不写</span><br></pre></td></tr></table></figure>

<h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><p>概念：<br>当数据库表中的某个字段上的内容不允许重复时，则可以使用UK约束进行设置。即UK约束进行设置。即UK约束在创建数据库时为某些字段加上”UNIQUE”约束条件，保证所有记录中该字段上的值不重复，则数据库管理系统会报错。</p>
<p>特点：</p>
<ul>
<li>同一个表可以有多个唯一约束</li>
<li>唯一约束允许值为NULL</li>
<li>在创建唯一约束的时候，如果不给唯一约束命名，那么约束名和字段名相同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1.在创建时候</span><br><span class="line">CREATE TABNE 表名</span><br><span class="line">(</span><br><span class="line">  属性 类型 ,</span><br><span class="line">  属性 类型 UNIQUE,</span><br><span class="line">  ......,</span><br><span class="line">  也可以用表约束来写：</span><br><span class="line">  CONSTRAINT 名字(起的新名字) UNIQUE KEY(需要唯一的字段，已有的)# KEY可以省略</span><br><span class="line">);</span><br><span class="line">查看表以存在的约束：</span><br><span class="line">SELECT *FROM information_schema.TABLE_CONSTRAINTS WHERE table name=&#x27;需要查的字段名&#x27;;</span><br><span class="line">2.修改</span><br><span class="line">ALTER TABLE 表名 MODIFY 字段 类型 UNIQUE;</span><br><span class="line">添加表约束：</span><br><span class="line">ALTER TABLE 表名 ADD  CONSTRAINT 名字(起的新名字) UNIQUE KEY (需要唯一的字段，已有的)# KEY可以省略</span><br><span class="line">3.删除约束</span><br><span class="line">ALTER TABLE 表名 DROP INDEX 字段;</span><br></pre></td></tr></table></figure>

<h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><p>概念<br>当想用数据库表中的某个字段来唯一标识所有记录时，则可以使用PK约束进行设置。即PK约束在创建数据库表时为某些字段加上”PRIMARY KEY”约束条件，则该字段可以唯一地标示所有记录。<br>在数据库表中之所以设置主键，是为了便于数据库管理系统快速的查找到表中的记录。在具体设置主键约束时，必须要满足主键字段的值是唯一、非空。由于主键可以是单一字段，也可以是多个字段，因此分为单字段主键和多字段主键。<br>特点：</p>
<ul>
<li>主键约束相当于唯一约束+非空约束，意味着不允许重复和NULL值</li>
<li>主键约束对应着表中的一列或多列（复合主键）</li>
<li>如果时多列组合的复合主键约束，那么这些列都不允许为NULL值，并且组合的值不允许重复</li>
<li>MYSQL的主键名总是PRIMARY，就算是自己命名了主键约束也没有用</li>
<li>当创建主键约束时，系统默认会在所在的列或组合上建立对应的主键索引（能够根据主键查询的，就根据主键传讯，效率更高），如果删除主键约束，主键约束对应的索引就自动删除了</li>
<li>需要注意一点的时，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1.在创建时候</span><br><span class="line">CREATE TABNE 表名</span><br><span class="line">(</span><br><span class="line">  属性 类型  PRIMRY KEY,# 一个表中只能有一个主键约束，否者会报错</span><br><span class="line">  属性 类型 ,</span><br><span class="line">  ......,</span><br><span class="line">  也可以用表约束来写：</span><br><span class="line">  CONSTRAINT 名字(起的新名字) PRIMRY KEY(需要唯一的字段，已有的)# KEY可以省略</span><br><span class="line">);</span><br><span class="line">查看表以存在的约束：</span><br><span class="line">SELECT *FROM information_schema.TABLE_CONSTRAINTS WHERE table name=&#x27;需要查的字段名&#x27;;</span><br><span class="line">添加表约束：</span><br><span class="line">ALTER TABLE 表名 ADD   PRIMRY KEY（名字(起的新名字)）;</span><br><span class="line">3.删除约束</span><br><span class="line">ALTER TABLE 表名 DROP PRIMRY KEY（名字(起的新名字)）;</span><br></pre></td></tr></table></figure>

<h4 id="自增长约束"><a href="#自增长约束" class="headerlink" title="自增长约束"></a>自增长约束</h4><p>概念：<br>AUTO_INCREMENT是MYSQL唯一扩展的完整性约束，当为数据库表中插入新的记录时，字段上的值会自动生成唯一的id。在具体设置AUTO_INCREMENT约束时，一个数据库表中只能有一个字段使用该约束，该字段的数据类型必须是整数类型，由于设置AUTO_INCREMENT约束后的字段会生成唯一的id，所以该字段也经常会设置成pk主键。</p>
<p>特点：</p>
<ul>
<li>一个表最多只有一个自增长列</li>
<li>当需要生产唯一标识符或顺序值时，可设置自增长</li>
<li>自增长列约束的列必须时键列（主键列，唯一键列）</li>
<li>自增长约束的列的数据类型必须时整数类型</li>
<li>如果自增列定制了0或者NULL。会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接使用具体值。</li>
</ul>
<p>&#x3D;&#x3D;在删除一个元素后，再添加一个元素，序列仍是在原先的基础上自增长的&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1.在创建时候</span><br><span class="line">CREATE TABNE 表名</span><br><span class="line">(</span><br><span class="line">  属性 类型 AUTO_INCREMENT,</span><br><span class="line">  属性 类型 ,</span><br><span class="line">  ......,</span><br><span class="line">);</span><br><span class="line">添加表约束：</span><br><span class="line">ALTER TABLE 表名 MODIFY 名字 数据类型  AUTO_INCREMENT;</span><br><span class="line">3.删除约束</span><br><span class="line">ALTER TABLE 表名 MODIFY 名字 数据类型;</span><br></pre></td></tr></table></figure>

<h4 id="检查约束（check）"><a href="#检查约束（check）" class="headerlink" title="检查约束（check）"></a>检查约束（check）</h4><p>检查某个字段的值是否符合xx要求，一般指的是值的范围</p>
<blockquote>
<p>在MYSQL5.7可以使用，但是没有作用，在8.0版本开始生效，可以正确进行检查</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1.在创建时候</span><br><span class="line">CREATE TABNE 表名</span><br><span class="line">(</span><br><span class="line">  属性 类型  CHECK(条件)，</span><br><span class="line">  属性 类型 ,</span><br><span class="line">  ......,</span><br><span class="line">#也可以用表约束来限制</span><br><span class="line">CONSTRAINT 别名 CHECK(条件);</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除约束：<br>ALTER TABLE 表名 DROP CHECK 字段;<br>添加约束：<br>ALTER TABLE 表名 ADD CONSTRAINT 字段 CHECK(条件);</p>
<h4 id="默认值约束（DEFAULT）"><a href="#默认值约束（DEFAULT）" class="headerlink" title="默认值约束（DEFAULT）"></a>默认值约束（DEFAULT）</h4><p>当为数据库表中插入一条新纪录时，如果灭有为某个字段赋值，那么数据库系统会自动为这个字段插入默认值。为了达到这种效果，可以通过SQL语句关键字DEFAULT来设置。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名</span><br><span class="line">(</span><br><span class="line">    字段 类型,</span><br><span class="line">    字段 类型 DEFAULT 字符串;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除约束：<br>ALTER TABLE 表名 MODIFY 字段 类型;<br>添加约束：<br>ALTER TABLE 表名 MODIFY 字段 类型 DEFAULT 默认值;</p>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>外键约束保证多个表（通常两个表）之间的参照完整性，即构造与两个字段之间的关系。</p>
<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>设置外键约束的两个表之间具有父子关系，即子表中某个字段的取值范围由父表所决定。例如：表示一种部门和雇员关系，即每个部门有多个雇员。首先应该有连个表：部门表和雇员表，然后雇员表中有一个表示部门编号的字段deptno，其依赖于部门表的主键，这样字段depton就是雇员的外键，通过该字段部门表建立了关系。<br>对于两个具有关联的表而言，相关关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。<br>在具体设置fk约束时，设置fk约束的字段必须依赖于数据库中已经存在的父表的主键，同时外键可以为null。</p>
<h5 id="其特点"><a href="#其特点" class="headerlink" title="其特点"></a>其特点</h5><ul>
<li>从表的外键必须引用（参考）主表的主键或唯一约束的列：因为参考的值必须是唯一的</li>
<li>在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动生产一个外键名，也可以指定外键约束名</li>
<li>创建表时必须先创建主表，再创建从表</li>
<li>删除表必须先删除从表（或先删除外键约束），再删除主表</li>
<li>当主表的记录被从表参考时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖字段的记录，然后才可以删除主表中的记录</li>
<li>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引；删除外键约束之后，必须<strong>手动</strong>删除对应的索引</li>
</ul>
<h5 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 主表名</span><br><span class="line">(</span><br><span class="line">  字段1 类型 PRIMARY KEY,</span><br><span class="line">  字段2 类型 ,</span><br><span class="line">  ....</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">CREATE TABLE 从表名</span><br><span class="line">(</span><br><span class="line">  字段1 类型 PRIMARY KEY,</span><br><span class="line">  字段2 类型 ,# 需要有字段和主表主键一样</span><br><span class="line">  ....</span><br><span class="line">  CONSTRAINT 字段别名 FOREIGN KEY(主表主键名) REFERENCES 主表(主键)</span><br><span class="line">)</span><br><span class="line">#删除外键约束</span><br><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 别名;</span><br><span class="line">#删除外键创建时自动创建索引</span><br><span class="line">ALTER TABLE 表名 DROP INDEX 别名;</span><br><span class="line">添加外键约束</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 别名 FOREIGN KEY(主表主键名) REFERENCES 主表(主键);</span><br></pre></td></tr></table></figure>

<h5 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h5><blockquote>
<p>级联操作指的就是，当你操作主表时，自动的操作从表</p>
</blockquote>
<p>两种级联操作</p>
<ul>
<li>级联删除：当删除主表数据时自动删除从表的相关数据</li>
<li>级联更新：当主表外键约束字段（一般是主键） 更新时，自动更新从表的数据</li>
</ul>
<p>五种级联方式</p>
<p>定义从表的外键时指定的ON UPDATE&#x2F;ON DELETE子句，InnoBD支持5种方式：</p>
<ul>
<li>CASCADE级联方式<ul>
<li>在主表上update&#x2F;delete记录时，同步update&#x2F;delete掉从表的匹配记录</li>
</ul>
</li>
<li>SET NULL设置为NULL<ul>
<li>在主表上update&#x2F;delete记录时，将从表上匹配记录的列为NULL</li>
</ul>
</li>
<li>NO ACTION不允许更新和删除<ul>
<li>如果从表种有匹配的记录，则不允许对表的关联字段更新</li>
</ul>
</li>
<li>RESTRICT限制<ul>
<li>同时NO ACTION</li>
</ul>
</li>
<li>SET DEFAUT<ul>
<li>主表有变更时，子表将外键列设置成一个默认值，但InnoBD不能识别</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1.主表更新或者删除的时候，从表的相关记录也会更新或删除</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 别名 FOREIGN KEY（主表名）REFERNECES 字段（主表名）ON UPDATE CASCADE ON DELETE CASCADE;  #可以把两个表都建立完后再写这个指令，不要初始化。</span><br><span class="line">#2.主表更新或者删除的时候，从表的相关记录的外键字段会自动设置为NULL</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 别名 FOREIGN KEY（主表名）REFERNECES 字段（主表名）ON UPDATE SET NULL ON DELETE SET NULL; # ON UPDATE 后面的两个可以任意搭配</span><br></pre></td></tr></table></figure>

<h2 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>TINYING</td>
<td>很小的整数</td>
<td>1</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>小的整数</td>
<td>2</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>中等大小的整数</td>
<td>3</td>
</tr>
<tr>
<td>INT&#x2F;INTGER</td>
<td>普通大小的整数</td>
<td>4</td>
</tr>
<tr>
<td>BIGINT</td>
<td>大整数</td>
<td>8</td>
</tr>
</tbody></table>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>单精度浮点数</td>
<td>4</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数</td>
<td>8</td>
</tr>
<tr>
<td>REAL</td>
<td>默认为DOUBLE</td>
<td>把SQL模式设定为”REAL_AS_FLOAT”,REAL就是FLOAT SEL sql_mode&#x3D;”REAL_AS_FLOAT”</td>
</tr>
</tbody></table>
<h3 id="定点类型"><a href="#定点类型" class="headerlink" title="定点类型"></a>定点类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>DECIMAL&#x2F;DEC</td>
<td>压缩的”严格”定点数</td>
<td>M+2</td>
</tr>
</tbody></table>
<p>DECIMAL(M,D)。其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。0&lt;&#x3D;M&lt;&#x3D;65,0&lt;&#x3D;D&lt;&#x3D;30,D&lt;M。例如：定义为DECIMAL(5,2),表示该列的取值范围是[-999.99,999.99]。</p>
<ul>
<li><p>DECIMAL(M,D)的最大范围与DOUBLE类型一样，但是有效的数据方位是由M和D决定的。DECUNAK的存储空间并不固定，由精度M决定，总共占用的存储空间为M+2个字节。也就是说，在一些精度要求不高的场景下，比起占用相同样字节长度的定点数，浮点数表达的数值范围可以更大。</p>
</li>
<li><p>定点数再MYSQL内部是以字符串的形式进行存储的，这就决定了他一定是精确的。</p>
</li>
<li><p>当DECIMAL类型不指定精度和标度时，其默认值DECIMAL(10,0),当数据的精度超出了定点数的精度范围时，则MYSQL同样会四舍五入。</p>
</li>
<li><p>浮点数vs定点数</p>
<ul>
<li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是精度不精确，适用于需要取值范围大，又可以容忍误差的科学计算场景</li>
<li>定点数类型取值范围相对小，但是精确，没有误差，设置对于精度要求极高的场景（比如设计金融计算的成精）</li>
</ul>
</li>
</ul>
<h3 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h3><blockquote>
<p>用于存储图片、音频、视频等二进制数据。</p>
</blockquote>
<p>下表种列出了MYSQL中的二进制数据类型，括号中的M表示可以为其指定长度。</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>BIT(M)</td>
<td>位字段类型</td>
<td>大约（M+7）&#x2F;8字节</td>
</tr>
<tr>
<td>BINARY(M)</td>
<td>固定长度二进制字符串</td>
<td>M字节</td>
</tr>
<tr>
<td>VARBINARY(M)</td>
<td>可变长度二进制字符串</td>
<td>M+1字节</td>
</tr>
<tr>
<td>TINYBLOB(M)</td>
<td>非常小的BLOB</td>
<td>L+1字节，在次，L&lt;2^8</td>
</tr>
<tr>
<td>BLOB(M)</td>
<td>小BLOB</td>
<td>L+2字节，在次，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMBLOB(M)</td>
<td>中等大小的BLOB</td>
<td>L+3字节，在次，L&lt;2^24</td>
</tr>
<tr>
<td>LONGBLOB(M)</td>
<td>非常大的BLOB</td>
<td>L+4字节，在次，L&lt;2^32</td>
</tr>
</tbody></table>
<h3 id="日期-时间类型"><a href="#日期-时间类型" class="headerlink" title="日期&#x2F;时间类型"></a>日期&#x2F;时间类型</h3><table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>日期范围</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>YYYY</td>
<td>1901-2155</td>
<td>1</td>
</tr>
<tr>
<td>TIME</td>
<td>HH:MM:SS</td>
<td>-838:59:59~838:59:59</td>
<td>3</td>
</tr>
<tr>
<td>DATE</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01~9999-12-3</td>
<td>3</td>
</tr>
<tr>
<td>DATETIME</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00~9999-12-31 23:59:59</td>
<td>8</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1970-01-01 00:00:00UTC~2038-01-19 03:14:07 UTC</td>
<td>4</td>
</tr>
</tbody></table>
<blockquote>
<p>要是创建的变量要每次登录更新可以在类型后面加上ON UPDATE再加上类型即可</p>
</blockquote>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>| 类型名称     | 说明         |长度范围|占用的存储空间|</p>
<p>| ———– | ———— | ———— |<br>———— |<br>|CHAR(M)|固定长度|0&lt;&#x3D;M&lt;&#x3D;255|M个字节|<br>|VARCHAR(M)|变长字符串|0&lt;&#x3D;M&lt;&#x3D;65535|M+1个字节|<br>|TINYTEXT|非常小字符串|0&lt;&#x3D;L&lt;&#x3D;255|L+1个字节|<br>|TEXT|小的字符串|0&lt;&#x3D;L&lt;&#x3D;65535|L+2个字节|<br>|MEDIUMTEXT|中等大小的字符串|0&lt;&#x3D;L&lt;&#x3D;16777215|L+3个字节|<br>|LONGTEXT|大的字符串|0&lt;&#x3D;L&lt;&#x3D;4294967295|L+4个字节|<br>|ENUM|枚举类型，只能有一个枚举字符串值|0&lt;&#x3D;L&lt;&#x3D;65535|1或2个字节，取决于枚举值的数目（最大值为65535）|<br>|SET|字符串集合，字符串对象可以有零个或多个SET成员|0&lt;&#x3D;L&lt;&#x3D;64|1，2，3，4或8个字节，取决于集合成员的数量（最多64个成员）|</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图可以帮助我们使用表的一部分而不是整个表，令一方面也可以针对不同的用户定制不同的查询视图。</p>
<blockquote>
<p>视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，他是sql中的一个重要概念。<br>视图建立在已有表的基础上，视图赖以建立的这些表称为基表。<br>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增删改的操作时，基表中的数据会相应地发生变化，反之亦然。<br>向视图提供数据内容的语句为select语句，可以将视图理解为存储起来的select语句。<br>视图，是向用户提供基表数据的另一种表现形式。小项目用不到，大项目用可以提高效率。</p>
</blockquote>
<h3 id="视图语法"><a href="#视图语法" class="headerlink" title="视图语法"></a>视图语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 完整版本:</span><br><span class="line">CREATE [OR REPLACE] [ALGORITHM=&#123;UNDEFINED|MERGE|TEMPTABLE&#125;]</span><br><span class="line">VIEM 视图名称[(字段列表)]</span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED|LOCAL] CHECK OPTION]</span><br><span class="line"># 简单版本:</span><br><span class="line">CREATE VIEW 视图名称</span><br><span class="line">AS 查询语句</span><br></pre></td></tr></table></figure>

<p>视图的查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.查看数据库里有哪些表和视图</span><br><span class="line">SHOW TABLES</span><br><span class="line">2.查看视图结构</span><br><span class="line">DESC 视图名字</span><br><span class="line">3.查看视图的属性信息</span><br><span class="line">SHOW TABLE STATUS LIKE 视图名字</span><br><span class="line">4.查看创建视图的·时候的语句</span><br><span class="line">SHOW CREATE VIEW</span><br></pre></td></tr></table></figure>

<h3 id="更新视图数据"><a href="#更新视图数据" class="headerlink" title="更新视图数据"></a>更新视图数据</h3><p>Mysql支持使用insert，update和delete语句对视图中的数据进行插入，更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p>
<p>在数据的插入阶段时，如果有没有指定的字段，并且字段没有默认值，则插入失败。</p>
<h4 id="不可更新视图"><a href="#不可更新视图" class="headerlink" title="不可更新视图"></a>不可更新视图</h4><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p>
<ul>
<li>在定义视图的时候指定了 <code>ALGORITHM=TEMPTABLE</code>，视图将不支持insert和delete操作</li>
<li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持insert操作</li>
<li>在定义视图的select语句中使用了join联合查询，视图将不支持insert操作</li>
<li>在定义属兔的select语句后的字段列表中使用distinct，聚合函数，group by，having，union等，视图将不支持insert，update和delete</li>
<li>在定义视图的select语句中包含了子查询，而子查询中引用了from后面的表，视图将不支持insert，update和delete</li>
</ul>
<p><strong>注意：虽然可以更新视图，但是总的来说，视图作为虚拟表，主要用于方便查询，不建议更新视图数据。对视图数据更改，都是通过对实际数据表里数据的操作来完成的。</strong></p>
<h3 id="视图的删除与修改"><a href="#视图的删除与修改" class="headerlink" title="视图的删除与修改"></a>视图的删除与修改</h3><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称</span><br><span class="line">DROP VIEW IF EXISTS 视图名称1，视图名称2，视图名称3...</span><br></pre></td></tr></table></figure>

<p>删除视图只是删除视图定义，不会删除基表的数据</p>
<h4 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法1，使用CREATE OR REPLACE VIEW子句修改视图</span><br><span class="line">CREATE OR REPLACE VIEW 视图名称</span><br><span class="line">AS</span><br><span class="line">查询语句</span><br><span class="line">方法2，ALTER VIEW</span><br><span class="line">ALTER VIEW</span><br><span class="line">AS</span><br><span class="line">查询语句</span><br></pre></td></tr></table></figure>

<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><p>MYSQL再5.0版本开始支持存储过程和函数，存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑而只需要简单的调用存储过程和函数即可</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>存储过程，他的思路很简单，他就是一组经过预先编译的sql语句的封装。<br>存储过程预先存储在MYSQL服务器上，需要执行的时候，客服端只需要向服务器发出调用存储的命令，服务器就可以把预先存储好的这一系列SQL语句全部执行。</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li>简化操作，提高SQL语句的重用性，减少了开发程序员的压力</li>
<li>减少操作过程中的失误，提高效率</li>
<li>较少网络传输量（客服端不需要把所有的SQL语句通过网络发送给服务器）</li>
<li>减少SQL语句暴露在网上的风险，提高了数据查询的安全性</li>
</ul>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE [IF NOT EXISTS] 存储过程名称([IN|OUT|INPUT 参数名 参数类型,...])</span><br><span class="line">[charcateristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">存储过程体</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<blockquote>
<p>存储过程名称不能与已存在的存储过程名重名。推荐存储过程名命名为procedu_xxx或者proc_xxx</p>
</blockquote>
<h5 id="参数分类"><a href="#参数分类" class="headerlink" title="参数分类"></a>参数分类</h5><p>存储过程的参数可以是IN、OUT、INOUT</p>
<ul>
<li>IN表示传入参数</li>
<li>OUT表示传出参数</li>
<li>INOUT表示既可以传入也可以传出</li>
<li>也可以不写参数</li>
<li>也可以多个不同类型的参数</li>
</ul>
<p>charcateristics可选参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE SQL</span><br><span class="line">|[NOT] DETERMINISTTIC</span><br><span class="line">|&#123;CONTAINS SQL|NO SQL|READS SQL DATA|MODIFIESC SQL DATA&#125;</span><br><span class="line">|SQL DECURITY&#123;DEFINER|INVOKER&#125;</span><br><span class="line">|COMMENT &#x27;string&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>LANGUAGE SQL:说明存储过程体是由SQL语句组成的，当前系统支持的语言为SQL</p>
</li>
<li><p>[NOT] DETERMINISTTIC：指明存储过程执行的结果是否确定。DETERMINISTTIC 表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。[NOT] DETERMINISTTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</p>
</li>
<li><p>{CONTAINS SQL|NO SQL|READS SQL DATA|MODIFIESC SQL DATA}：指明子程序使用SQL语句的限制</p>
<ul>
<li>CONTAINS SQL 表示当前存储过程的子程序包含SQL语句，但是并不会包含读写数据的SQL语句；</li>
<li>NO SQL 表示当前存储过程的子程序中不包含任何SQL语句；</li>
<li>READS SQL DATA 表示当前存储过程的子程序中包含读数据的SQL语句</li>
<li>MODIFIESC SQL DATA 表示当前存储过程的子程序中包含写数据的SQL</li>
<li>默认情况下，系统会指定为CONTAINS SQL。</li>
</ul>
</li>
<li><p>SQL DECURITY{DEFINER|INVOKER}:执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。</p>
<ul>
<li>DEFINER表示只有当前存储过程的创建者或者定义这才能执行当前存储过程</li>
<li>INVOKER表示拥有当前存储过程的访问权限的用户能够执行当前的存储过程</li>
<li>如果没有设置相关的值，则MYSQL默认指定值为DEFINER</li>
</ul>
</li>
<li><p>COMMENT ‘string’注释信息，可以用来描述存储的过程。</p>
</li>
</ul>
<p>存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以忽略BEGIN和END<br>编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的SQL语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN...END:中间包含了多个语句，每个语句都可以用（;）号为结束符</span><br><span class="line">DECLARE：DECLARE用来声明变量，使用的位置在于BEGIN...END语句中间，而且需要在其他语句使用之前进行变量的声明</span><br><span class="line">SET：赋值语句，对于对变量进行赋值</span><br><span class="line">SELECT...INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值</span><br></pre></td></tr></table></figure>

<p>需要设置新的结束标记</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br></pre></td></tr></table></figure>

<p>因为MYSQL默认的语句结束符号位分号’;’。为了避免与存储过程中SQL语句结束符相冲突，需要使DELIMITER该改变存储过程的结束符。</p>
<p>比如：”DELIMITER &#x2F;&#x2F;“语句的作用是将MYSQl的结束符设置位&#x2F;&#x2F;，并以”END &#x2F;&#x2F;“结束存储过程。存储过程定义完毕之后再使用”DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他字符作为结束符。</p>
<p>如果使用的是Navicat工具，那么再编写存储过程的时候，Navicat会自动设置DELIMITER为其他符号，我们不需要再进行DELIMITER的操作。</p>
<blockquote>
<p>当使用DELIMITER命令时，应该避免使用反斜杠（’&#39;）字符，因为反斜杠是MYSQL的转义字符。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE [IF NOT EXISTS] 存储过程名称([IN|OUT|INPUT 参数名 参数类型,...])</span><br><span class="line">[charcateristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">sql语句1;</span><br><span class="line">sql语句2;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>使用自定义的存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL 函数名(参数);</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">这是有参数的存储过程创建</span><br><span class="line">CREATE PROCEDURE  存储过程名称(IN 参数名 参数类型)</span><br><span class="line">BEGIN</span><br><span class="line">sql语句1;</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line">调用有两种：</span><br><span class="line">1.</span><br><span class="line">CALL 函数名(参数);</span><br><span class="line">2.</span><br><span class="line">SET @变量名=&quot;&quot;;</span><br><span class="line">CALL 函数名(@变量名);</span><br><span class="line"></span><br><span class="line">有返回值的存储过程创建</span><br><span class="line">CREATE PROCEDURE  存储过程名称(OUT 返回值 返回值类型)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT ... INTO(返回值)...</span><br><span class="line">...</span><br><span class="line">END</span><br><span class="line">--定义变量</span><br><span class="line">set @变量名=0;-&gt;需要初始化</span><br><span class="line">CALL 函数名(@变量名);</span><br><span class="line">SELECT @变量名;</span><br><span class="line"></span><br><span class="line">传参并返回的存储过程创建</span><br><span class="line">CREATE PROCEDURE  存储过程名称(INOUT 返回值 返回值类型)</span><br><span class="line">BEGIN</span><br><span class="line"> 嵌套查询语句</span><br><span class="line">...</span><br><span class="line">END</span><br><span class="line">--定义变量</span><br><span class="line">set @变量名=0;-&gt;需要初始化</span><br><span class="line">CALL 函数名(@变量名);</span><br><span class="line">SELECT @变量名;</span><br></pre></td></tr></table></figure>

<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数名 参数类型,..)</span><br><span class="line">RETURNS 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">函数体 #函数体里一定有RETURN 语句</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>参数列表：指定参数位IN,OUT,INOUT只对POCEDURE是合法的，FUNCTION中总是默认位IN参数。</li>
<li>RETURNS type语句表示函数返回数据的类型;</li>
</ol>
<blockquote>
<p>RETURNS子句只能对FUNCTION做指定，对函数而言这是强制的。他用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。</p>
</blockquote>
<p>characteristics创建函数时指定的对函数的约束。取值与创建存储过程时相同。</p>
<p>函数例子：</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221107193949559.png" alt="image-20221107193949559"></p>
<p>在创建多个函数的时候，咱们可以在开头写上：SET GLOBAL log_bin_trust_function_creators&#x3D;1;#默认时0<br>就不会报错了。</p>
<h3 id="对比存储函数和存储过程"><a href="#对比存储函数和存储过程" class="headerlink" title="对比存储函数和存储过程"></a>对比存储函数和存储过程</h3><table>
<thead>
<tr>
<th></th>
<th>关键字</th>
<th>调用语法</th>
<th>返回值</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>函数过程</td>
<td>PROCEDURE</td>
<td>CALL存储过程()</td>
<td>理解为有0个或多个</td>
<td>一般用于更细</td>
</tr>
<tr>
<td>存储函数</td>
<td>FUNCTION</td>
<td>SELECT函数()</td>
<td>只能是一个</td>
<td>一般用于查询结果为一个值并返回时</td>
</tr>
</tbody></table>
<p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能时存储函数不具备的。</p>
<h3 id="存储过程和函数的查看、修改、删除"><a href="#存储过程和函数的查看、修改、删除" class="headerlink" title="存储过程和函数的查看、修改、删除"></a>存储过程和函数的查看、修改、删除</h3><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>MYSQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可以直接从系统的information_schema数据库中查询。<br>1.使用SHOW CREATE 语句查看存储过程和函数的创建信息<br>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE &#123;PROCEDURE|FUNCTION&#125;存储过程名或函数名</span><br></pre></td></tr></table></figure>

<p>2.使用SHOW STATUS 语句查看存储过程和函数的状态信息<br>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW  &#123;PROCEDURE|FUNCTION&#125; STATUS [LIKE &#x27;pattern&#x27;]</span><br></pre></td></tr></table></figure>

<p>这个语句返回子程序的特征，如数据库，名字，类型，创建者及修改日期。<br>[LIKE ‘pattern’]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MYSQL数据库中存在的所有存储过程或函数的信息。</p>
<p>3.从information_schema.Routines表中查看存储过程和函数信息<br>MYSQL中存储过程和函数的信息存储在information_schema数据库下Routines表中。可以通过查询该表的记录来查询过程和函数的信息。基本语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.Routines</span><br><span class="line">WHERE ROUTINE_NAME=&#x27;存储过程或函数名&#x27;[AND ROUTINE_TYPE=&#123;&#x27;PROCEDURE|FUNCTION&#x27;&#125;];</span><br></pre></td></tr></table></figure>

<p>说明：<br>如果在MYSQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE条件查询，指明查询的时存储过程还是函数。</p>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>修改存储过程和函数，不影响存储过程或函数的功能，只是修改相关特性。使用ALTER语句来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER &#123;PROCEDURE|FUNCTION&#125; 存储过程或函数的名 [characteristic]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构时一样的，语句中的所有参数也是一样的。</p>
</blockquote>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除存储过程和函数，可以使用DROP语句，其语法结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP &#123;PROCEDURE|FUNCTION&#125; [IF EXISTS]存储过程或函数的名</span><br></pre></td></tr></table></figure>

<p>IF EXISTS:如果程序或函数不存储，他可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。</p>
<h2 id="变量、分支结构、循环结构以及游标"><a href="#变量、分支结构、循环结构以及游标" class="headerlink" title="变量、分支结构、循环结构以及游标"></a>变量、分支结构、循环结构以及游标</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p>
<p>在 MySQL 数据库中，变量分为 <code>系统变量</code>以及<code>用户自定义变量</code>。</p>
<h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><h5 id="系统变量分类"><a href="#系统变量分类" class="headerlink" title="系统变量分类"></a>系统变量分类</h5><p>变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间， MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特  征。这些系统变量的值要么是 编译MySQL时参数 的默认值，要么是 配置文件 （例如my.ini等）中的参数值。大家可以在官网<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html">Server System Variables</a>中查看MySQL文档的系统变量。</p>
<p>系统变量分为<strong>全局系统变量</strong>（需要添加<code>global</code>关键字）以及会话系统变量（需要添加<code>session</code>关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。**如果不写，默认是会话级别。**静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p>
<p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例  会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变  量值的复制。</p>
<ul>
<li>全局系统变量针对于所有会话（连接）有效，但不能跨重启。</li>
<li>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</li>
<li>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</li>
</ul>
<p>在MySQL中有些系统变量只能是全局的，例如  max_connections  用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client  用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p>
<h5 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h5><ul>
<li><p><font style="color:rgb(135,0,58)"> <strong>查看所有或部分系统变量</strong></font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line"></span><br><span class="line">#查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">#或</span><br><span class="line">SHOW VARIABLES;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看满足条件得部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;%标识符%&#x27;;</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &#x27;%标识符%&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>范例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;admin_%&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font style="color:rgb(135,0,58)"><strong>查看指定系统变量</strong></font></p>
</li>
</ul>
<p>作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，  则标记全局系统变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line">SELECT @@global.变量名;</span><br><span class="line"></span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line">SELECT @@session.变量名;</span><br><span class="line">#或</span><br><span class="line">SELECT @@变量名;</span><br></pre></td></tr></table></figure>

<ul>
<li><font style="color:rgb(135,0,58)"><strong>修改系统变量的值</strong></font></li>
</ul>
<p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、  特征。具体方法：</p>
<p>方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p>
<p>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#为某个系统变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@global.变量名=值;</span><br><span class="line">#方式2：</span><br><span class="line">SET GLOBAL 变量名=值;</span><br><span class="line"></span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@session.变量名=值;</span><br><span class="line">#方式2：</span><br><span class="line">SET SESSION 变量名=值</span><br></pre></td></tr></table></figure>

<p><strong>范例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@global.autocommit;</span><br><span class="line">SET GLOBAL autocommit=0;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line">SET @@session.tx_isolation=&#x27;read-uncommitted&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL max_connections = 1000;</span><br><span class="line">SELECT @@global.max_connections;</span><br></pre></td></tr></table></figure>

<h5 id="补充：MySQL-8-0的新特性——全局变量的持久化"><a href="#补充：MySQL-8-0的新特性——全局变量的持久化" class="headerlink" title="补充：MySQL 8.0的新特性——全局变量的持久化"></a>补充：MySQL 8.0的新特性——全局变量的持久化</h5><p>在MySQL数据库中，全局变量可以通过SET  GLOBAL语句来设置。例如，设置服务器语句超时的限制，可以通过设置系统变量max_execution_time来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL MAX_EXECUTION_TIME=2000;</span><br></pre></td></tr></table></figure>

<p>使用SET GLOBAL语句设置的变量值只会 临时生效 。 数据库重启 后，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了 SET PERSIST 命令。例如，设置服务器的最大连接数为1000：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PERSIST global max_connections = 1000;</span><br></pre></td></tr></table></figure>

<p>MySQL会将该命令的配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</p>
<p>举例：</p>
<p>查看全局变量max_connections的值，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%max_connections%&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name | Value  |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| max_connections | 151  |</span><br><span class="line">| mysqlx_max_connections | 100|</span><br><span class="line">+------------------------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>设置全局变量max_connections的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set persist max_connections=1000; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><code>重启MySQL服务器</code>，再次查询max_connections的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%max_connections%&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| max_connections | 1000 |</span><br><span class="line">| mysqlx_max_connections | 100 |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><h5 id="用户变量分类"><a href="#用户变量分类" class="headerlink" title="用户变量分类"></a>用户变量分类</h5><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用范围不同，又分为<code>会话用户变量</code>和<code>局部变量</code>。</p>
<ul>
<li>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</li>
<li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在存储过程和函数中使用。</li>
</ul>
<p>注意：在 MySQL 5.0以前的版本中是大小写敏感的，因此要注意（在 MySQL 5.0以后已经不区分大小写了）。</p>
<h5 id="会话用户变量"><a href="#会话用户变量" class="headerlink" title="会话用户变量"></a>会话用户变量</h5><ul>
<li>变量的定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#方式1：&quot;= 或 &quot;:=</span><br><span class="line">SET @用户变量=值</span><br><span class="line">SET @用户变量:=值</span><br><span class="line"></span><br><span class="line">#方式2：&quot;:=&quot; 或 INTO关键字</span><br><span class="line">SELECT @用户变量 :=表达式[FROM等子句];</span><br><span class="line">SELECT 表达式 INTO @用户变量 [FROM等子句];</span><br></pre></td></tr></table></figure>

<ul>
<li>查看自定义变量的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @用户变量;</span><br></pre></td></tr></table></figure>

<p><strong>范例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET @n1 =1;</span><br><span class="line">SET @n2 :=3;</span><br><span class="line">SET @sum := @n1+@n2;</span><br><span class="line">SELECT @sum;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @num := COUNT(*) FROM emps;</span><br><span class="line">SELECT @num;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(sal) INTO @avgsal FROM emps;</span><br><span class="line">SELECT  @avgsal;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看某个未定义的变量时，将得到NULL值</span><br><span class="line">SELECT @maye;</span><br></pre></td></tr></table></figure>

<h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>定义：可以使用 DECLARE 语句定义一个局部变量作用域：仅仅在定义它的 BEGIN … END 中有效</p>
<p>位置：只能放在 BEGIN … END 中，而且<strong>只能放在第一句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">  #声明局部变量</span><br><span class="line">  DECLARE 变量1 数据类型 [DEFAULT 默认值];</span><br><span class="line">  DECLARE 变量2,变量3,... 数据类型 [DEFAULT 默认值];</span><br><span class="line"></span><br><span class="line">  #为局部变量赋值</span><br><span class="line">  SET 变量1 = 值;</span><br><span class="line">  SELECT 字段 INTO 变量2 [FROM 子句];</span><br><span class="line"></span><br><span class="line">  #查看局部变量的值</span><br><span class="line">  SELECT 变量1,变量2,变量3;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h6 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 变量名 类型 [DEFAULT 值]; # 如果没有DEFAULT子句，初始值为NULL</span><br></pre></td></tr></table></figure>

<p><strong>范例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE num INT DEFAULT 100;</span><br></pre></td></tr></table></figure>

<h6 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h6><p> 方式1：一般用于赋简单的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET 变量=值;</span><br><span class="line">SET 变量:=值;</span><br></pre></td></tr></table></figure>

<p>方式2：一般用于赋表中的字段值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段名或表达式 INTO 变量名 FROM 表;</span><br></pre></td></tr></table></figure>

<h6 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h6> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 局部变量名;</span><br></pre></td></tr></table></figure>

<p>**范例1：**声明局部变量，并分别赋值为emps表中empno为7369的ename和sal。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE set_value() </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE emp_name VARCHAR(25); </span><br><span class="line">  DECLARE em_sal DOUBLE(10,2);  </span><br><span class="line"></span><br><span class="line">  SELECT ename,sal INTO emp_name,emp_sal </span><br><span class="line">  FROM emps</span><br><span class="line">  WHERE empno = 7369;</span><br><span class="line"></span><br><span class="line">  SELECT emp_name,emp_sal; </span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>**范例2：**声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#方式1：使用用户变量</span><br><span class="line">SET @m=1;</span><br><span class="line">SET @n=2;</span><br><span class="line">SET @sum = @m+@n;</span><br><span class="line">SELECT @sum;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#方式2：使用局部变量</span><br><span class="line">CREATE PROCEDURE add_value()</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE m INT DEFAULT 1;</span><br><span class="line">  DECLARE n INT DEFAULT 3;</span><br><span class="line">  DECLARE sum INT;</span><br><span class="line">  SET sum=m+n;</span><br><span class="line">  SELECT sum;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>**范例3：**创建存储过程“diff_sal”查询某员工和他领导的薪资差距，并用IN参数eno接收员工编号，用OUT参数dif_sal输出薪资差距结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE different_sal(IN eno INT,OUT dif_sal DOUBLE) </span><br><span class="line">BEGIN</span><br><span class="line">  #声明局部变量</span><br><span class="line">  DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0; </span><br><span class="line">  DECLARE mgr_no INT;</span><br><span class="line"></span><br><span class="line">  SELECT sal INTO emp_sal FROM emps WHERE empno = eno; 	</span><br><span class="line">  SELECT mgr INTO mgr_no FROM emps WHERE empno = eno; </span><br><span class="line">  SELECT sal INTO mgr_sal FROM emps WHERE empno = mgr_no;</span><br><span class="line">  SET dif_sal = mgr_sal - emp_sal; </span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">SET @emp_no = 102;</span><br><span class="line">CALL different_salary(@emp_no,@diff_sal);</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">SELECT @diff_sal;</span><br></pre></td></tr></table></figure>

<h5 id="会话用户变量与局部变量对比"><a href="#会话用户变量与局部变量对比" class="headerlink" title="会话用户变量与局部变量对比"></a>会话用户变量与局部变量对比</h5><table>
<thead>
<tr>
<th align="center">变量类型</th>
<th align="center">作用域</th>
<th align="center">定义位置</th>
<th align="center">语法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">会话用户变量</td>
<td align="center">作用域当前会话</td>
<td align="center">定义位置会话的任何地方</td>
<td align="center">语法加@符号，不用指定类型</td>
</tr>
<tr>
<td align="center">局部变量</td>
<td align="center">定义它的BEGIN END中</td>
<td align="center">BEGIN END的第一句话</td>
<td align="center">一般不用加@，需要指定类型</td>
</tr>
</tbody></table>
<h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>定义条件是事先定义程序执行过程中可能遇到的问题， 处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p>
<p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p>
<h5 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h5><p>**案例分析：**创建一个名称为“UpdateData”的存储过程。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE UpdateData() </span><br><span class="line">BEGIN</span><br><span class="line">  SET @x = 1;</span><br><span class="line">  UPDATE emps SET sal = NULL WHERE ename = &#x27;WARD&#x27;; </span><br><span class="line">  SET @x = 2;</span><br><span class="line">  UPDATE emps SET sal = 200 WHERE ename = &#x27;WARD&#x27;; </span><br><span class="line">  SET @x = 3;</span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>

<p>调用存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CALL UpdateData();</span><br><span class="line">ERROR 1048 (23000): Column &#x27;sal&#x27; cannot be null</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @x;</span><br><span class="line">+------+</span><br><span class="line">| @x |</span><br><span class="line">+------+</span><br><span class="line">| 1 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件  和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，  不再向下继续执行。</p>
<h4 id="定义条件"><a href="#定义条件" class="headerlink" title="定义条件"></a>定义条件</h4><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个错误名字和错误条件关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中。</p>
<p>定义条件使用DECLARE语句，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 错误名称 CONDITION FOR 错误码(或错误条件)</span><br></pre></td></tr></table></figure>

<p>错误码的说明：</p>
<ul>
<li><p><code>MySQL_error_code</code> 和 <code>sqlstate_value</code> 都可以表示MySQL的错误。</p>
<ul>
<li>MySQL_error_code是数值类型错误代码。</li>
<li>sqlstate_value是长度为5的字符串类型错误代码。</li>
</ul>
</li>
<li><p>例如，在ERROR 1048 (23000)中，1048是MySQL_error_code，’23000’是sqlstate_value。</p>
</li>
<li><p>例如，在ERROR 1146（42S02）中，1146是MySQL_error_code，’42S02’是sqlstate_value。</p>
</li>
</ul>
<p>**范例1：**定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR  1048  (23000)”对应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#使用MySQL_error_code</span><br><span class="line">DECLARE Field_Not_Be_NULL CONDITION FOR 1048;</span><br><span class="line"></span><br><span class="line">#使用sqlstate_value</span><br><span class="line">DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE &#x27;23000&#x27;;</span><br></pre></td></tr></table></figure>

<p>**范例2：**定义”ERROR 1148(42000)”错误，名称为command_not_allowed。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#使用MySQL_error_code</span><br><span class="line">DECLARE command_not_allowed CONDITION FOR 1148;</span><br><span class="line"></span><br><span class="line">#使用sqlstate_value</span><br><span class="line">DECLARE command_not_allowed CONDITION FOR SQLSTATE &#x27;42000&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="定义处理程序"><a href="#定义处理程序" class="headerlink" title="定义处理程序"></a>定义处理程序</h4><p>可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句  的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font style="color:rgb(135,0,58)"><strong>处理方式</strong></font>：处理方式有3个取值：CONTINUE、EXIT、UNDO。</p>
<ul>
<li><font style="color:rgb(237,105,99)"><code>CONTINUE</code></font> ：表示遇到错误不处理，继续执行。</li>
<li><font style="color:rgb(237,105,99)"><code>EXIT</code></font> ：表示遇到错误马上退出。</li>
<li><font style="color:rgb(237,105,99)"><code>UNDO</code></font> ：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li>
</ul>
</li>
<li><p><font style="color:rgb(135,0,58)"><strong>错误类型：</strong></font>（即条件）可以有如下取值：</p>
<ul>
<li><font style="color:rgb(237,105,99)"><code>SQLSTATE &#39;字符串错误码&#39;</code></font> ：表示长度为5的sqlstate_value类型的错误代码；</li>
<li><font style="color:rgb(237,105,99)"><code>MySQL_error_code</code></font> ：匹配数值类型错误代码；</li>
<li><font style="color:rgb(237,105,99)"><code>错误名称</code></font> ：表示DECLARE … CONDITION定义的错误条件名称。</li>
<li><font style="color:rgb(237,105,99)"><code>SQLWARNING</code></font> ：匹配所有以01开头的SQLSTATE错误代码； </li>
<li><font style="color:rgb(237,105,99)"><code>NOT FOUND</code></font> ：匹配所有以02开头的SQLSTATE错误代码；</li>
<li><font style="color:rgb(237,105,99)"><code>SQLEXCEPTION</code></font> ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li>
</ul>
</li>
</ul>
<p><font style="color:rgb(135,0,58)"><strong>处理语句：</strong></font>：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是  像“ SET 变量 &#x3D; 值 ”这样的简单语句，也可以是使用 BEGIN … END 编写的复合语句。</p>
<p>定义处理程序的几种方式，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#方法1：捕获sqlstate_value</span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27; SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法2：捕获mysql_error_value</span><br><span class="line">DECLARE CONTINUE HANDLER FOR 1146 SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法3：先定义条件，再调用</span><br><span class="line">DECLARE no_such_table CONDITION FOR 1146;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法4：使用SQLWARNING</span><br><span class="line">DECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#x27;ERROR&#x27;;</span><br><span class="line"></span><br><span class="line">#方法5：使用NOT FOUND</span><br><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法6：使用SQLEXCEPTION</span><br><span class="line">DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#x27;ERROR&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="案例解决"><a href="#案例解决" class="headerlink" title="案例解决"></a>案例解决</h4><p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行</p>
<p>CONTINUE操作，并且将@proc_value的值设置为-1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE UpdateDataNoCondition() </span><br><span class="line">BEGIN</span><br><span class="line">  #定义处理程序</span><br><span class="line">  DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;</span><br><span class="line"></span><br><span class="line">  SET @x = 1;</span><br><span class="line">  UPDATE emps SET sal = NULL WHERE ename = &#x27;WARD&#x27;; </span><br><span class="line">  SET @x = 2;</span><br><span class="line">  UPDATE emps SET sal = 200 WHERE ename = &#x27;WARD&#x27;; </span><br><span class="line">  SET @x = 3;</span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>

<p>调用过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CALL UpdateDataWithCondition(); Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @x,@proc_value;</span><br><span class="line">+------+-------------+</span><br><span class="line">| @x  | @proc_value |</span><br><span class="line">+------+-------------+</span><br><span class="line">| 3 | -1 |</span><br><span class="line">+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>**范例：**创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。</p>
<p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操   作，并且将@proc_value的值设置为-1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#准备工作</span><br><span class="line">CREATE TABLE depts </span><br><span class="line">AS</span><br><span class="line">SELECT * FROM test.dept;</span><br><span class="line"></span><br><span class="line">ALTER TABLE depts</span><br><span class="line">ADD CONSTRAINT uk_dept_name UNIQUE(deptno);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE InsertDataWithCondition() </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE duplicate_entry CONDITION FOR SQLSTATE &#x27;23000&#x27; ; </span><br><span class="line">  DECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value = -1;</span><br><span class="line"></span><br><span class="line">  SET @x = 1;</span><br><span class="line">  INSERT INTO depts(dname) VALUES(&#x27;测试&#x27;); </span><br><span class="line">  SET @x = 2;</span><br><span class="line">  INSERT INTO depts(dname) VALUES(&#x27;测试&#x27;);</span><br><span class="line">  SET @x = 3;</span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>

<p>调用存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CALL InsertDataWithCondition(); Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @x,@proc_value;</span><br><span class="line">+------+-------------+</span><br><span class="line">| @x | @proc_value |</span><br><span class="line">+------+-------------+</span><br><span class="line">| 2 | -1 |</span><br><span class="line">+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中  SQL  语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：</p>
<ul>
<li>顺序结构 ：程序从上往下依次执行</li>
<li>分支结构 ：程序按条件进行选择执行，从两条或多条路径中选择一条执行</li>
<li>循环结构 ：程序满足一定条件下，重复执行一组语句</li>
</ul>
<p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p>
<ul>
<li>条件判断语句 ：IF 语句和 CASE 语句</li>
<li>循环语句 ：LOOP、WHILE 和 REPEAT 语句</li>
<li>跳转语句 ：ITERATE 和 LEAVE 语句</li>
</ul>
<h4 id="分支结构之-IF"><a href="#分支结构之-IF" class="headerlink" title="分支结构之 IF"></a>分支结构之 IF</h4><p>IF 语句的语法结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IF 表达式1 </span><br><span class="line">  THEN 操作1</span><br><span class="line">[ELSEIF 表达式2 THEN 操作2] </span><br><span class="line">...</span><br><span class="line">[ELSE 操作N]</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure>

<p>根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。</p>
<ul>
<li><p>特点：① 不同的表达式对应不同的操作<br>​       ② 使用在begin end中</p>
</li>
<li><p><strong>范例1：</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF val IS NULL</span><br><span class="line">THEN SELECT &#x27;val is null&#x27;;</span><br><span class="line">ELSE SELECT &#x27;val is not null&#x27;;	</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure>

<p>**范例2：**声明存储过程“update_sal_by_eno”，定义IN参数eno，输入员工编号。判断该员工 薪资如果低于2000元并且入职时间超过5年，就涨薪500元；否则就不变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE update_sal_by_eno1(IN eno INT) </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE emp_sal DOUBLE; </span><br><span class="line">  DECLARE hire_year DOUBLE;</span><br><span class="line"></span><br><span class="line">  SELECT sal INTO emp_sal FROM emps WHERE empno = eno;</span><br><span class="line"></span><br><span class="line">  SELECT DATEDIFF(CURDATE(),hiredate)/365 INTO hire_year </span><br><span class="line">  FROM emps WHERE empno = eno;</span><br><span class="line"></span><br><span class="line">  IF emp_sal &lt; 2000 AND hire_year &gt; 5</span><br><span class="line">  THEN UPDATE emps SET sal = sal + 500 WHERE empno = eno; </span><br><span class="line">  END IF;</span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>

<p>**范例3：**声明存储过程“update_sal_by_eno2”，定义IN参数eno，输入员工编号。判断该员工  薪资如果低于3000元，就更新薪资为3000元；薪资如果大于等于3000元且低于5000的，但是奖金 比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE update_sal_by_eno2(IN eno INT) </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE emp_sal DOUBLE; </span><br><span class="line">  DECLARE emp_comm DECIMAL(5,2);</span><br><span class="line"></span><br><span class="line">  SELECT sal INTO emp_sal FROM emps WHERE empno = eno; </span><br><span class="line">  SELECT comm INTO emp_comm FROM emps WHERE empno = eno;</span><br><span class="line"></span><br><span class="line">  IF emp_sal &lt; 3000</span><br><span class="line">    THEN UPDATE emps SET sal = 3000 WHERE empno = eno;</span><br><span class="line">    SELECT &#x27;1&#x27;;</span><br><span class="line">  ELSEIF emp_sal &lt; 5000 AND emp_comm IS NULL</span><br><span class="line">    THEN UPDATE emps SET comm = 0.01*sal WHERE empno = eno;</span><br><span class="line">    SELECT &#x27;2&#x27;;</span><br><span class="line">  ELSE</span><br><span class="line">    UPDATE emps SET sal = sal + 100 WHERE empno = eno; </span><br><span class="line">    SELECT &#x27;3&#x27;;</span><br><span class="line">  END IF;</span><br><span class="line">END //</span><br><span class="line">DELIMITER //</span><br></pre></td></tr></table></figure>

<h4 id="分支结构之-CASE"><a href="#分支结构之-CASE" class="headerlink" title="分支结构之 CASE"></a><strong>分支结构之</strong> CASE</h4><p>CASE 语句的语法结构1：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#情况一：类似于switch </span><br><span class="line">CASE 表达式</span><br><span class="line">WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line">ELSE 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br></pre></td></tr></table></figure>

<p>CASE 语句的语法结构2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#情况二：类似于多重if </span><br><span class="line">CASE</span><br><span class="line">WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号)</span><br><span class="line">WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line">ELSE 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br></pre></td></tr></table></figure>

<p>**范例1：**使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE val</span><br><span class="line">  WHEN 1 THEN SELECT &#x27;val is 1&#x27;; </span><br><span class="line">  WHEN 2 THEN SELECT &#x27;val is 2&#x27;;</span><br><span class="line">  ELSE SELECT &#x27;val is not 1 or 2&#x27;; </span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<p>**范例2：**使用CASE流程控制语句的第2种格式，判断val是否为空、小于0、大于0或者等于0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE</span><br><span class="line">  WHEN val IS NULL THEN SELECT &#x27;val is null&#x27;; </span><br><span class="line">  WHEN val &lt; 0 THEN SELECT &#x27;val is less than 0&#x27;;</span><br><span class="line">  WHEN val &gt; 0 THEN SELECT &#x27;val is greater than 0&#x27;; </span><br><span class="line">  ELSE SELECT &#x27;val is 0&#x27;;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<p>**范例3：**声明存储过程“update_salary_by_eno4”，定义IN参数eno，输入员工编号。判断改员工所属部门，如果在10号部门，工资加500；如果在20号部门，工资加600；如果在30号部门，工资加700;其他部门加300。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE update_salary_by_eno4(IN eno INT) </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE dept_no,emp_sal INT; </span><br><span class="line"></span><br><span class="line">  SELECT sal,deptno INTO emp_sal,dept_no FROM emps WHERE empno = eno; </span><br><span class="line"></span><br><span class="line">  CASE deptno</span><br><span class="line">  WHEN 10</span><br><span class="line">    THEN UPDATE emps SET sal=emp_sal+500 WHERE empno = eno; </span><br><span class="line">  WHEN 20</span><br><span class="line">    THEN UPDATE emps SET sal=emp_sal+600 WHERE empno = eno; </span><br><span class="line">  WHEN 30</span><br><span class="line">    THEN UPDATE emps SET sal=emp_sal+700 WHERE empno = eno;</span><br><span class="line">  ELSE </span><br><span class="line">    UPDATE emps SET sal=emp_sal+300 WHERE empno = eno;	</span><br><span class="line">  END CASE;</span><br><span class="line">END //</span><br></pre></td></tr></table></figure>

<p>**范例4：**声明存储过程pro_sal_grade，定义IN参数eno，输入员工编号。判断该员工的薪资等级，如果在[700,1200]之间，为等级一；如果在[1201，1400]之间，为等级二；如果在[1401,2000]之间，为等级三；如果在[2001,3000]之间，为等级四；如果在[3001,9999]之间，为等级五；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE sal_grade(IN eno INT) </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE emp_sal INT; </span><br><span class="line"></span><br><span class="line">  SELECT sal INTO emp_sal FROM emps WHERE empno = eno;</span><br><span class="line"></span><br><span class="line">  CASE </span><br><span class="line">    WHEN emp_sal&gt;=700 AND emp_sal&lt;=1200</span><br><span class="line">      THEN SELECT &#x27;等级一&#x27;;</span><br><span class="line">    WHEN emp_sal&gt;=1201 AND emp_sal&lt;=1400 </span><br><span class="line">      THEN SELECT &#x27;等级二&#x27;;</span><br><span class="line">          WHEN emp_sal&gt;=1401 AND emp_sal&lt;=2000 </span><br><span class="line">      THEN SELECT &#x27;等级三&#x27;;</span><br><span class="line">    WHEN emp_sal&gt;=2001 AND emp_sal&lt;=3000 </span><br><span class="line">      THEN SELECT &#x27;等级四&#x27;;</span><br><span class="line">    WHEN emp_sal&gt;=3001 AND emp_sal&lt;=999 </span><br><span class="line">      THEN SELECT &#x27;等级五&#x27;;</span><br><span class="line">  END CASE;</span><br><span class="line">END //</span><br></pre></td></tr></table></figure>

<h4 id="循环结构之-LOOP"><a href="#循环结构之-LOOP" class="headerlink" title="循环结构之 LOOP"></a>循环结构之 LOOP</h4><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子  句），跳出循环过程。</p>
<p>LOOP语句的基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">    循环执行的语句</span><br><span class="line">END LOOP [loop_label] </span><br></pre></td></tr></table></figure>

<p>其中，loop_label表示LOOP语句的标注名称，该参数可以省略。</p>
<p>**范例1：**使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DECLARE id INT DEFAULT 0;</span><br><span class="line">add_loop:LOOP</span><br><span class="line">  SET id = id +1;</span><br><span class="line">  IF id &gt;= 10 </span><br><span class="line">  THEN LEAVE add_loop; </span><br><span class="line">  END IF;</span><br><span class="line"></span><br><span class="line">END LOOP add_loop;</span><br></pre></td></tr></table></figure>

<p>**范例2：**当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_sal_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.1倍。直到全公司的平均薪资达到8000结束。并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE update_sal_loop(OUT num INT) </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE avg_sal DOUBLE; </span><br><span class="line">  DECLARE loop_count INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">  SELECT AVG(sal) INTO avg_sal FROM emps;</span><br><span class="line"></span><br><span class="line">  label_loop:LOOP</span><br><span class="line">    IF avg_sal &gt;= 8000 </span><br><span class="line">    THEN LEAVE label_loop; </span><br><span class="line">    END IF;</span><br><span class="line"></span><br><span class="line">    UPDATE emps SET sal = sal * 1.1; </span><br><span class="line">    SET loop_count = loop_count + 1;</span><br><span class="line">    SELECT AVG(sal) INTO avg_salary FROM emps; </span><br><span class="line">  END LOOP label_loop;</span><br><span class="line"></span><br><span class="line">SET num = loop_count; </span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>

<h4 id="循环结构之-WHILE"><a href="#循环结构之-WHILE" class="headerlink" title="循环结构之 WHILE"></a>循环结构之 WHILE</h4><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如  果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO</span><br><span class="line">  循环体</span><br><span class="line">END WHILE [while_label];</span><br></pre></td></tr></table></figure>

<p>while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直   至循环条件为假，退出循环。</p>
<p>**范例1：**WHILE语句示例，i值小于10时，将重复执行循环过程，代码如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE test_while()</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE i INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">  WHILE i &lt; 10 DO </span><br><span class="line">    SET i = i + 1;</span><br><span class="line">  END WHILE;</span><br><span class="line"></span><br><span class="line">  SELECT i;</span><br><span class="line">END ;</span><br><span class="line">#调用</span><br><span class="line">CALL test_while();</span><br></pre></td></tr></table></figure>

<p>**范例2：**市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到3000结束。并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE update_sal_while(OUT num INT) </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE avg_sal DOUBLE ;</span><br><span class="line">  DECLARE while_count INT DEFAULT 0;</span><br><span class="line">  SELECT AVG(sal) INTO avg_sal FROM emps; </span><br><span class="line">  WHILE avg_sal &gt; 3000 DO</span><br><span class="line">    UPDATE emps SET sal = sal * 0.9; </span><br><span class="line">    SET while_count = while_count + 1;</span><br><span class="line">    SELECT AVG(sal) INTO avg_sal FROM emps; </span><br><span class="line">  END WHILE;</span><br><span class="line"></span><br><span class="line">  SET num = while_count; </span><br><span class="line">END //</span><br></pre></td></tr></table></figure>

<h4 id="循环结构之-REPEAT"><a href="#循环结构之-REPEAT" class="headerlink" title="循环结构之 REPEAT"></a>循环结构之 REPEAT</h4><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p>
<p>REPEAT语句的基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">    循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line">END REPEAT [repeat_label]</span><br></pre></td></tr></table></figure>

<p>repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。</p>
<p><strong>范例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE test_repeat() </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE i INT DEFAULT 0;</span><br><span class="line">  REPEAT</span><br><span class="line">    SET i = i + 1; </span><br><span class="line">  UNTIL i &gt;= 10</span><br><span class="line">  END REPEAT;</span><br><span class="line"></span><br><span class="line">  SELECT i;</span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>

<p>**范例2：**当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到9000结束。并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE update_salary_repeat(OUT num INT) </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE avg_sal DOUBLE ;</span><br><span class="line">  DECLARE repeat_count INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">  SELECT AVG(sal) INTO avg_sal FROM emps; </span><br><span class="line"></span><br><span class="line">  REPEAT</span><br><span class="line">    UPDATE emps SET sal = sal * 1.15;</span><br><span class="line">        SET repeat_count = repeat_count + 1;</span><br><span class="line">    SELECT AVG(sal) INTO avg_sal FROM emps; </span><br><span class="line">  UNTIL avg_sal &gt;= 9000</span><br><span class="line">  END REPEAT;</span><br><span class="line"></span><br><span class="line">  SET num = repeat_count; </span><br><span class="line">END //</span><br></pre></td></tr></table></figure>

<p><strong>对比三种循环结构：</strong></p>
<p>1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。</p>
<p>2、 LOOP：一般用于实现简单的”死”循环 WHILE：先判断后执行 REPEAT：先执行后判断，无条件至少执行一次</p>
<h4 id="跳转语句之-LEAVE语句"><a href="#跳转语句之-LEAVE语句" class="headerlink" title="跳转语句之 LEAVE语句"></a>跳转语句之 LEAVE语句</h4><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。</p>
<p>基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEAVE 标记名</span><br></pre></td></tr></table></figure>

<p>其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。</p>
<p>**范例1：**创建存储过程 “leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在BEGIN…END中使用IF语句判断num参数的值。</p>
<ul>
<li>如果num&lt;&#x3D;0，则使用LEAVE语句退出BEGIN…END； </li>
<li>如果num&#x3D;1，则查询“emps”表的平均薪资； </li>
<li>如果num&#x3D;2，则查询“emps”表的最低薪资； </li>
<li>如果num&gt;2，则查询“emps”表的最高薪资。</li>
</ul>
<p>IF语句结束后查询“emp”表的总人数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE leave_begin(IN num INT) </span><br><span class="line">	begin_label: BEGIN</span><br><span class="line">		IF num&lt;=0</span><br><span class="line">			THEN LEAVE begin_label; </span><br><span class="line">		ELSEIF num=1</span><br><span class="line">			THEN SELECT AVG(sal) FROM emps; </span><br><span class="line">		ELSEIF num=2</span><br><span class="line">			THEN SELECT MIN(sal) FROM emps; </span><br><span class="line">		ELSE</span><br><span class="line">			SELECT MAX(sal) FROM emps; </span><br><span class="line">		END IF;</span><br><span class="line"></span><br><span class="line">		SELECT COUNT(*) FROM emps; </span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>

<p>**范例2：**当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公  司的平均薪资小于等于10000，并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE leave_while(OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">	#</span><br><span class="line">	DECLARE avg_sal DOUBLE;#记录平均工资</span><br><span class="line">	DECLARE while_count INT DEFAULT 0; #记录循环次数</span><br><span class="line"></span><br><span class="line">	SELECT AVG(sal) INTO avg_sal FROM emps; #① 初始化条件</span><br><span class="line"></span><br><span class="line">	while_label:WHILE TRUE DO #② 循环条件</span><br><span class="line"></span><br><span class="line">		#③ 循环体</span><br><span class="line">		IF avg_sal &lt;= 10000 </span><br><span class="line">			THEN LEAVE while_label;</span><br><span class="line">		END IF;</span><br><span class="line"></span><br><span class="line">		UPDATE emps SET sal = sal * 0.9; </span><br><span class="line">		SET while_count = while_count + 1;</span><br><span class="line"></span><br><span class="line">		#④ 迭代条件</span><br><span class="line">		SELECT AVG(sal) INTO avg_sal FROM emps; </span><br><span class="line">	END WHILE;</span><br><span class="line">	#赋值</span><br><span class="line">	SET num = while_count; </span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>



<h4 id="跳转语句之-ITERATE-语句"><a href="#跳转语句之-ITERATE-语句" class="headerlink" title="跳转语句之 ITERATE 语句"></a>跳转语句之 ITERATE 语句</h4><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序   转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为  continue，意思为“再次循环”。</p>
<p>语句基本格式如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITERATE label</span><br></pre></td></tr></table></figure>

<p>label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</p>
<p><strong>范例：</strong> 定义局部变量num，初始值为0。循环结构中执行num + 1操作。</p>
<ul>
<li><p>如果num &lt; 10，则继续执行循环；</p>
</li>
<li><p>如果num &gt; 15，则退出循环结构；</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE test_iterate() </span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE num INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">	my_loop:LOOP</span><br><span class="line">		SET num = num + 1;</span><br><span class="line"></span><br><span class="line">		IF num &lt; 10</span><br><span class="line">			THEN ITERATE my_loop; </span><br><span class="line">		ELSEIF num &gt; 15</span><br><span class="line">			THEN LEAVE my_loop; </span><br><span class="line">		END IF;</span><br><span class="line"></span><br><span class="line">		SELECT &#x27;顿开教育：让每个学员都学有所成&#x27;; </span><br><span class="line">	END LOOP my_loop;</span><br><span class="line">END //</span><br></pre></td></tr></table></figure>

<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><h4 id="什么是游标（或光标）"><a href="#什么是游标（或光标）" class="headerlink" title="什么是游标（或光标）"></a>什么是游标（或光标）</h4><p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录， 但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是<code>随意定位到某一条记录</code> ，并对记录的数据进行处理。</p>
<p>这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录  进行定位，并对指向的记录中的数据进行操作的数据结构。<strong>游标让</strong> <strong>SQL</strong> <strong>这种面向集合的语言有了面向过程开发的能力。</strong></p>
<p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用 ，我们可以通过操作游标来对数据行进行操作。</p>
<p>MySQL中游标可以在存储过程和函数中使用。</p>
<p>比如，我们查询了 emps数据表中工资高于1500的员工都有哪些：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT empno,ename,sal FROM emps WHERE sal &gt; 1500;</span><br></pre></td></tr></table></figure>

<p><img src="/./C:/Users/Asus/Desktop/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/assets/image-20220428165219836.png" alt="image-20220428165219836"></p>
<p>这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“7698”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。</p>
<h4 id="使用游标步骤"><a href="#使用游标步骤" class="headerlink" title="使用游标步骤"></a>使用游标步骤</h4><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。   如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p>
<p><font style="color:rgb(135,0,58)"><strong>第一步，声明游标</strong></font></p>
<p>在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR FOR select_statement;</span><br></pre></td></tr></table></figure>

<p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR IS select_statement;</span><br></pre></td></tr></table></figure>

<p> 要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是</p>
<p>SELECT 语句，返回一个用于创建游标的结果集。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cur_emp CURSOR FOR</span><br><span class="line">SELECT empno,sal FROM emps;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor_dept CURSOR FOR </span><br><span class="line">SELECT deptno,dname, loc FROM depts ;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(135,0,58)"><strong>第二步，打开游标</strong></font></p>
<p>打开游标的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_name</span><br></pre></td></tr></table></figure>

<p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT  语句的查询结果集就会送到游标工作区，为后面游标的 逐条读取 结果集中的记录做准备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cur_emp ;</span><br></pre></td></tr></table></figure>

<p> <font style="color:rgb(135,0,58)"><strong>第三步，使用游标（从游标中取得数据）</strong></font></p>
<p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name [, var_name] ...</span><br></pre></td></tr></table></figure>

<p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p>
<p>注意：var_name必须在声明游标之前就定义好。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH cur_emp INTO emp_no, emp_sal ;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>游标的查询结果集中的字段数，必须跟</strong> <strong>INTO</strong>  <strong>后面的变量数一致</strong>，否则，在存储过程执行的时候，MySQL 会提示错误。</p>
<p> <font style="color:rgb(135,0,58)"><strong>第四步，关闭游标</strong></font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE cursor_name</span><br></pre></td></tr></table></figure>

<p>有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源 ，如果不及时关闭，<strong>游标会一直保持到存储过程结束</strong>，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。</p>
<p>关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE cur_emp; </span><br></pre></td></tr></table></figure>

<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary；声明OUT参数total_count。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和 达到limit_total_salary参数的值，返回累加的人数给total_count。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_sal INT,OUT total_count INT)</span><br><span class="line">BEGIN</span><br><span class="line">	#声明变量</span><br><span class="line">	DECLARE sum_sal INT DEFAULT  0;   #记录累加的总工资</span><br><span class="line">	DECLARE emp_count INT DEFAULT  0; #记录循环总次数</span><br><span class="line">	DECLARE emp_sal INT;               #当前员工的工资</span><br><span class="line">	</span><br><span class="line">	#声明游标</span><br><span class="line">	DECLARE  cursor_emp CURSOR FOR SELECT sal FROM emp ORDER BY sal DESC;</span><br><span class="line">	#打开游标</span><br><span class="line">	OPEN cursor_emp;</span><br><span class="line">	#使用游标</span><br><span class="line">	WHILE sum_sal &lt; limit_total_sal DO</span><br><span class="line">			FETCH cursor_emp INTO emp_sal;</span><br><span class="line">			SET sum_sal = emp_sal+sum_sal;</span><br><span class="line">			SET emp_count = emp_count+1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	</span><br><span class="line">	#关闭游标</span><br><span class="line">	CLOSE cursor_emp;</span><br><span class="line">	#设置传出参数值</span><br><span class="line">	SET total_count = emp_count;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>游标是 MySQL 的一个重要的功能，为 逐条读取 结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。</p>
<p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行加锁 ，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会  消耗系统资源 ，造成内存不足，这是因为游标是在内存中进行的处理。</p>
<p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>MYSQL从5.0.2版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MYSQL服务器的一段程序。</p>
<p>触发器是由事件来触发某个操作的。所谓事件就是指用户的动作或者触发某项行为。如当对数据表中的数指向插入、更新和删除操作，需要自动执行一些数据库逻辑时。可以使用触发器来实现。</p>
<h3 id="触发器的创建"><a href="#触发器的创建" class="headerlink" title="触发器的创建"></a>触发器的创建</h3><p>触发器的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名称</span><br><span class="line">&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名</span><br><span class="line">FOR EACH ROW</span><br><span class="line">触发器执行的语句块;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>表名:表示触发器监控对象。</p>
</li>
<li><p>BEFORE|AFTER:表示触发的事件。BEFORE表示在事件之前触发;AFTER表示在事件之后触发。</p>
</li>
<li><p>INSERT|UPDATE|DELETE：表示触发的事件。</p>
<ul>
<li>INSERT 表示插入记录时触发</li>
<li>UPDATE 表示更新记录时触发</li>
<li>DELETE 表示删除记录时触发</li>
</ul>
</li>
<li><p>触发器执行的语句块：可以时单条SQL语句，也可以时由BEGIN…END结构组成的复合语句块。</p>
</li>
</ul>
<h3 id="OLD和NEW"><a href="#OLD和NEW" class="headerlink" title="OLD和NEW"></a>OLD和NEW</h3><p>在触发器正文中，OLD和new关键字使您能够访问受触发器影响的行中的列。old和new使MYSQL对触发器的扩展；他们区别分大小写</p>
<p>在insert触发器中，只能使用new.col_name没有旧行。在delete触发器中，只能使用old.col_name；没有新行。在update触发器中。您可以使用old.col_name来引用行更新之前的列，使用new.col_name来引用行更新后的列。</p>
<p>以old命名的列使只读的。您可以参考他（如果您有select权限)，但不能修改他。如果您具有select权限，则可以引用以new命名的列。在before触发器中，如果您具有update权限，您还可以使用set new.col_name&#x3D;value更改其值。这意味着您可以使用触发器来修改要插入新行或用于更新行的值。<br>在before触发器中，auto_increment列的new值为0，而不是实际擦汗如新行时自动生成的序列号。</p>
<p>插入失败手动报错：<br>SIGNAL SQLSTATE ‘错误编号’ SET MESSAGE_TEXT &#x3D;’错误提示’;</p>
<h3 id="查看、删除触发器"><a href="#查看、删除触发器" class="headerlink" title="查看、删除触发器"></a>查看、删除触发器</h3><p>查看触发器是查看数据库中已经纯在的触发器的定义、状态和语法信息等</p>
<p>方法1：查看当前数据库的所有触发器的定义<br>SHOW TRIGGERS;<br>方法2：查看当前数据库中某个触发器的定义<br>SHOW CREATE TRIGGERS 触发器名;<br>方法3：从系统库information_schema的TRIGGERS表中查询指定数据库的触发器信息。<br>SELECT * FROM information_schema.TRIGGERS WHERE trigger_schema&#x3D;’db_14’;</p>
<p>删除触发器</p>
<ul>
<li>触发器也是数据库对象，删除触发器也用DROP语句</li>
<li>如果您删除一个表，该表的所有触发器也会被删除</li>
</ul>
<p>DROP TRIGGER IF EXISTS 触发器名称;</p>
<h3 id="触发器的优缺点"><a href="#触发器的优缺点" class="headerlink" title="触发器的优缺点"></a>触发器的优缺点</h3><ul>
<li><p>优点</p>
<ul>
<li>保证数据的完整性</li>
<li>帮助我们记录操作日志</li>
<li>可以用在操作数据前，对数据进行合法性检查</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>可读性差</li>
<li>相关数据该表可能会导致触发器出错</li>
</ul>
</li>
</ul>
<h2 id="用户与权限管理"><a href="#用户与权限管理" class="headerlink" title="用户与权限管理"></a>用户与权限管理</h2><p>MYsql用户可以分为普通用户和root用户。root用户是超级管理员，拥有所有的权限，包括创建用户、删除用户和修改用户的密码等管理权限，普通用户只拥有被授权的各种权限。</p>
<p>mysql提供了许多语句来管理用户的账户，这些语句可以用来管理登录和退出MySQL服务器、创建用户、删除用户、密码权限管理和权限管理内容等内容。</p>
<p>MySQL数据库的安全性需要通过账户管理来保证。</p>
<h3 id="登录MySQL服务器"><a href="#登录MySQL服务器" class="headerlink" title="登录MySQL服务器"></a>登录MySQL服务器</h3><p>启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql [-h hostanme|hostIP -P port] -u username -p databaseName -e &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure>

<p>参数详解：</p>
<ul>
<li>-h参数：指定MySQL服务所在的主机名或者主机IP。若不指定则自动连接本地的MySQL</li>
<li>-p参数：指定MySQL服务器端口，默认端口是3306，若不指定则自动连接到3306端口</li>
<li>-u参数：指定登录MySQL的用户名</li>
<li>-p参数：会提示输入密码</li>
<li>databaseName：登录之后选择的数据库</li>
</ul>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>使用CREATE USER ‘username’[@’登录主机名’] [IDENTIFIED] BY ‘密码’];</p>
<p>参数详细：</p>
<ul>
<li>usingname:指定创建的用户账户，格式为‘usingname@hostname’usingname是用户名，hostname为主机名，即用户连接MySQL时所在主机的名字。若在创建的过程中，只给出了账户的用户名，而没有指定主机名，则主机名默认为”%”，表示一组主机。</li>
<li>IDENTIFIED BY：用于指定账户对应的口令，若该用户账号无口令，则可省略此子句。</li>
<li>密码：指定用户账户的口令</li>
</ul>
<p>使用注意事项：</p>
<ul>
<li>如果使用CREATE USER语句时没有为用户指定口令，那么MySQL允许该用户可以不使用口令登录系统，然而从安全的角度而言，不推荐这种做法。</li>
<li>使用CREATE USER语句必须拥有MySQL中MySQL数据库的INSERT权限或全局CREATE USER权限，</li>
<li>使用CREATE USER语句创建一个用户后，会在系统自身的MySQL数据库的user表中添加一条新纪录。若创建的账户已存在，则语句执行时会出现错误。</li>
<li>新创建的用户拥有的权限很少。他们可以登录MySQL，只允许进行不需要权限的操作，如使用SHOW语句查询所有存储引擎和字符集的列表等。</li>
<li>如果两个用户具有相同的用户名和不同的主机名，MySQL会将他们视为不同的用户，并允许为这两个用户分配不同的权限集合。</li>
</ul>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>方式一：使用DROP USING语句删除（推荐）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER user;</span><br></pre></td></tr></table></figure>

<p>方式二：使用DELETE FROM 方式删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM mysql.user WHERE Host=&#x27;hostname&#x27; AND User=&#x27;username&#x27;;</span><br></pre></td></tr></table></figure>

<p>执行完DELETE命令后，需要使用FLUSH命令来使用户生效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;#不刷新的话，还是可以登录的</span><br></pre></td></tr></table></figure>

<h3 id="修改用户名和密码"><a href="#修改用户名和密码" class="headerlink" title="修改用户名和密码"></a>修改用户名和密码</h3><p>使用UPDATA语句修改用户名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATA mysql.user SET USER=&#x27;新名字&#x27;WHERE USER=&#x27;旧名字&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>适用于root用户修改自己的密码以及普通用户登录之后修改自己的密码。</p>
<p>1.使用ALTER USER语句来修改当前用户密码，基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER USER() IDENTIFIED BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure>

<p>2.使用SET语句来修改当前用户密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD=&#x27;新密码&#x27;</span><br></pre></td></tr></table></figure>

<p><em><strong>修改其他用户密码</strong></em></p>
<p>root用户不仅可以修改自己的密码，还可以修改其他普通用户的密码</p>
<p>1.使用ALTER语句来修改普通用户密码，基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER user [IDENTIFIED BY &#x27;新密码&#x27;];</span><br></pre></td></tr></table></figure>

<p>2.使用SET语句来修改普通用户密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;username&#x27;@&#x27;hostname&#x27;=&#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure>

<p>3.使用UPDATE语句来修改普通用户密码(不推荐)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATA mysql.user SET authentication_string=PASSWORD(&quot;新密码&quot;)</span><br><span class="line">WHERE User=&#x27;usrname&#x27; AND Host=&#x27;hostname&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="密码的管理"><a href="#密码的管理" class="headerlink" title="密码的管理"></a>密码的管理</h3><p>MySQL中记录使用过的历史密码，目前包括如下密码管理功能:</p>
<ol>
<li>密码过期：要求定期修改密码</li>
<li>密码重用限制：不允许使用旧密码</li>
<li>密码强度评估:要求使用高强度密码</li>
</ol>
<p>密码过期策略</p>
<ul>
<li>在MySQL中，数据库管理员可以手动设置账号密码过期，也可以建立一个自动密码过期策略。</li>
<li>过期策略可以是全局的，也可以为每个账号单独设置过期策略。</li>
</ul>
<p>1.设置密码立即过期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER user PASSWORD EXPLRE;</span><br></pre></td></tr></table></figure>

<p>2.设置指定事件过期</p>
<p>如果密码使用的时间大于允许的时间，服务器会自动设置为过期，不需要手动设置。<br>MySQL使用default_password_lifetime系统变量建立全局密码过期策略。</p>
<ul>
<li>他的默认值是0，表示禁用密码自动过期</li>
<li>他允许的值是正整数N，表示允许的密码生存期，密码必须每隔N天进行修改</li>
</ul>
<p>全局设置</p>
<ul>
<li>方法一:使用SQL语句更改该变量的值并持久化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PERSIST default_password_lifetime=N;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2:把变量添加到配置晚间my.ini中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">default_password_lifetime=N</span><br></pre></td></tr></table></figure>

<p>指定用户过期</p>
<p>每个账户既可以沿用全局密码过期策略，也可以单独设置。在CREATE USER和ALTER USER语句上加入PASSWORD EXPIRE选项并指定时长即可。</p>
<ul>
<li>设置密码90天过期一次</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD EXPIRE INTERVAL 90 DAY;</span><br><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD EXPIRE INTERVAL 90 DAY;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置密码永不过期</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD EXPIRE NERVER;</span><br><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27;  PASSWORD EXPIRE NERVER;</span><br></pre></td></tr></table></figure>

<ul>
<li>沿用全局密码过期策略</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD EXPIRE DEFAULT;</span><br><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27;  PASSWORD EXPIRE DEFAULT;</span><br></pre></td></tr></table></figure>

<h3 id="密码重用策略"><a href="#密码重用策略" class="headerlink" title="密码重用策略"></a>密码重用策略</h3><p>MySQL限制使用已用过的密码。重用限制策略基础密码更改的数量和使用的时间。重用策略可以是全局的，也可以为每一个账户单独设置。</p>
<ul>
<li><p>账户的历史密码包含过去该账号所使用的密码。MySQL基于一下规则来限制密码重用：</p>
<ul>
<li>如果账号的密码限制基于密码更改的数量，那么新的密码不能从最近限制的密码数量中选择。例如：密码更改的最小值为3，那么新密码不能于最近3个密码中任意一个相同</li>
<li>如果账户密码限制基于时间，那么新密码不能从规定时间内选择。例如：如果密码重用周期为60天，那么新密码不能从最近60天内使用的密码中选择。</li>
</ul>
</li>
<li><p>MySQL使用password_history和password_reuse_interval系统变量设置密码重用策略。</p>
<ul>
<li>password_history：规定密码重用的数量</li>
<li>password_reuse_interval：规定密码重用的周期</li>
</ul>
</li>
<li><p>这两个变量在服务器的配置文件中进行维护，也可以在允许期间使用SQL语句更改变量的值并持续化。</p>
</li>
</ul>
<p>全局设置</p>
<p>方法1：使用SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET PERSIST password_history=N;# 设置不能选最近使用的N个密码</span><br><span class="line">SET PERSIST password_reuse_interval=N;# 设置不能选最近使用N天的密码</span><br></pre></td></tr></table></figure>

<p>方法2：把变量添加到配置文件my.ini中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">password_history=N</span><br><span class="line">password_reuse_interval=N</span><br></pre></td></tr></table></figure>

<p>单独设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#不能使用最近N个密码：</span><br><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD HISTORY N;</span><br><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD  HISTORY N;</span><br><span class="line">#不能使用最近N天内的密码：</span><br><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD REUSE INTERVAL N DAY;</span><br><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD  REUSE INTERVAL N DAY;</span><br><span class="line">#即不能使用最近N个密码，也不能使用最近N天内的密码：</span><br><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD HISTORY N PASSWORD REUSE INTERVAL N DAY;</span><br><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD HISTORY N PASSWORD REUSE INTERVAL N DAY;</span><br></pre></td></tr></table></figure>

<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>关于MySQL的权限简单的理解就是MySQL允许你做你权力以内的事情，不可以越界。比如只允许你执行SELECT语句，那么你就不能执行UPDATE语句；只允许你从某台机器上连接MySQL，那么你就不能从除那台极其以外的其他机器上连接MySQL。</p>
<p>在cmd上查看MySQL，中文会出现乱码的情况，我们需要在登录的时候写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u用户名 -p密码 --default-character-set=utf8</span><br></pre></td></tr></table></figure>

<p>MySQL到底都有哪些权限呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show privileges;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">权限</th>
<th align="left">含义和可授予级别</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td>
<td align="left">授予除 GRANT OPTION 和 PROXY 之外的指定访问级别的所有权限。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td>
<td align="left">启用修改表权限；Levels: Global, database, table.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td>
<td align="left">允许更改或删除存储的例程(过程和函数)。. Levels: Global, database, routine.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td>
<td align="left">允许创建数据库和表. Levels: Global, database, table.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td>
<td align="left">允许创建角色. Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td>
<td align="left">允许创建存储例程。 Levels: Global, database.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td>
<td align="left">允许创建、更改或删除表空间和日志文件组。Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td>
<td align="left">允许使用<code>CREATE TEMPORARY TABLE</code>创建临时表。 Levels: Global, database.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td>
<td align="left">允许 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-user.html"><code>CREATE USER</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/drop-user.html"><code>DROP USER</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/rename-user.html"><code>RENAME USER</code></a>and <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/revoke.html"><code>REVOKE ALL PRIVILEGES</code></a>. Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td>
<td align="left">允许创建和修改视图. Levels: Global, database, table.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td>
<td align="left">允许使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/delete.html"><code>DELETE</code></a>. Level: Global, database, table.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td>
<td align="left">允许删除数据库、表和视图。 Levels: Global, database, table.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td>
<td align="left">允许删除角色。Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td>
<td align="left">为 Event Scheduler 启用事件。Levels: Global, database.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td>
<td align="left">允许用户执行存储的例程。 Levels: Global, database, routine.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td>
<td align="left">允许用户通过服务器读取或写入文件. Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td>
<td align="left">允许向其他帐户授予或删除权限。 Levels: Global, database, table, routine, proxy.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td>
<td align="left">允许创建或删除索引。。Levels: Global, database, table.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td>
<td align="left">允许使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>. Levels: Global, database, table, column.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td>
<td align="left">允许在拥有 SELECT 权限的表上启用 LOCK TABLES。。Levels: Global, database.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td>
<td align="left">允许用户使用SHOW PROCESSLIST查看所有进程。Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td>
<td align="left">允许使用代理。 Level: From user to user.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td>
<td align="left">允许创建外键。 Levels: Global, database, table, column.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td>
<td align="left">允许 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/flush.html"><code>FLUSH</code></a> 操作. Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td>
<td align="left">使用户能够询问源或副本服务器在哪里。 Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td>
<td align="left">使副本能够从源读取二进制日志事件。Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td>
<td align="left">允许使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT</code></a>. Levels: Global, database, table, column.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td>
<td align="left">允许 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-databases.html"><code>SHOW DATABASES</code></a> 显示所有数据库. Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td>
<td align="left">允许使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-create-view.html"><code>SHOW CREATE VIEW</code></a>. Levels: Global, database, table.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td>
<td align="left">允许使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysqladmin.html"><strong>mysqladmin shutdown</strong></a>. Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td>
<td align="left">启用其他管理操作，例如 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/change-replication-source-to.html"><code>CHANGE REPLICATION SOURCE TO</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html"><code>CHANGE MASTER TO</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/kill.html"><code>KILL</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/purge-binary-logs.html"><code>PURGE BINARY LOGS</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/set-variable.html"><code>SET GLOBAL</code></a>, and <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysqladmin.html"><strong>mysqladmin debug</strong></a> command. Level: Global.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td>
<td align="left">启用触发器操作. Levels: Global, database, table.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td>
<td align="left">允许使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a>. Levels: Global, database, table, column.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td>
<td align="left">和 “no privileges”一样，意为没有权限</td>
</tr>
</tbody></table>
<p>（1） CREATE和DROP权限 ，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。  </p>
<p>（2） SELECT、INSERT、UPDATE和DELETE权限 允许在一个数据库现有的表上实施操作。</p>
<p>（3） SELECT权限只有在它们真正从一个表中检索行时才被用到。</p>
<p>（4） INDEX权限 允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</p>
<p> （5） ALTER权限 可以使用ALTER TABLE来更改表的结构和重新命名表。</p>
<p>（6） CREATE ROUTINE权限 用来创建保存的程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序， EXECUTE权限 用来执行保存的程序。</p>
<p> （7） GRANT权限 允许授权给其他用户，可用于数据库、表和保存的程序。</p>
<p> （8） FILE权限 使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务  器可以访问这些文件）。</p>
<p>授予权限的原则：</p>
<p>权限控制主要是出于安全因素，因此需要遵循以下几个 经验原则 ：</p>
<p>1、只授予能<code>满足需要的最小权限</code>，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</p>
<p>2、创建用户的时候<code>限制用户的登录主机</code> ，一般是限制成指定IP或者内网IP段。</p>
<p>3、为每个用户<code>设置满足密码复杂度的密码</code>。</p>
<p>4、 <code>定期清理不需要的用户</code> ，回收权限或者删除用户。</p>
<p>授予权限：</p>
<p>给用户授权的方式有 2 种，分别是通过把<code>角色赋予用户给用户授权</code>和<code>直接给用户授权</code>。用户是数据库的使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。</p>
<p>授权命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT priv_type[,priv_type1...] ON databasename.tablename TO username@hostname;</span><br></pre></td></tr></table></figure>

<p><strong>范例：</strong></p>
<ul>
<li><p>给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT,INSERT,DELETE,UPDATE ON test.* TO &#x27;maye&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>授予通过网络方式登录的tom用户  ，对所有库所有表的全部权限。注意这里唯独不包括grant的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;tom&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>ALL PRIVILEGES 是表示所有权限，你也可以使用SELECET、UPDATE等权限。</li>
<li>ON用来指定权限针对哪些数据库和表</li>
<li>*.* 前面的*用来指定数据库名，后面的*用来指定表名；在这里表示所有数据库的所有表</li>
<li>TO表示将权限赋予某个用户。</li>
<li>maye@’localhost’表示maye用户，@后面接限制的主机，可以是IP、IP段、域名以及%</li>
</ul>
</li>
<li><p>如果需要赋予包括GRANT的权限，添加参数<code>WITH GRANT OPTION</code>选项即可，表示该用户可以将自己拥有的权限授予给别人。经常有人在创建操作用户的时候不指定<code>WITH GRANT OPTION</code>选项导致后来该用户不能使用GRANT命令创建用户或者给其他用户授权。</p>
</li>
</ul>
<p> <strong>MySQL 的 权限，分别可以作用在多个层次上</strong></p>
<ul>
<li>所有库的所有表</li>
<li>单库下的所有表（最常用的授权级别）</li>
<li>单表下的所有列</li>
<li>单列权限：企业里称单列授权为 脱敏，即脱离敏感信息，涉及到敏感信息一定要脱敏<ul>
<li>例如：</li>
<li>授予vip账号对某一表下所有列的查询权限</li>
<li>而授予非vip账号对某一表下的某一列的查询权限</li>
</ul>
</li>
<li>针对存储过程的权限</li>
<li>针对函数的权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#（1）针对所有库的所有表：*.* </span><br><span class="line">grant select on *.* to maye@&#x27;localhost&#x27;; </span><br><span class="line"></span><br><span class="line">#（2）针对某一数据库：test.*</span><br><span class="line">grant select on test.* to maye@&#x27;localhost&#x27;; </span><br><span class="line"></span><br><span class="line">#（3）针对某一个表：test.t1</span><br><span class="line">grant select on db1.t1 to maye@&#x27;localhost&#x27;;  </span><br><span class="line"></span><br><span class="line">#（4）针对某一个字段：</span><br><span class="line">grant select(empno,ename,job),update (comm) on test.emp to maye@&#x27;localhost&#x27;; </span><br><span class="line"></span><br><span class="line">#（5）作用在存储过程上：</span><br><span class="line"></span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE pro_show()</span><br><span class="line">BEGIN</span><br><span class="line">SELECT * FROM test.emp;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">show procedure status; -- 查看到db1下有一个名为p1的存储过程 </span><br><span class="line"></span><br><span class="line">grant execute on procedure test.emp to maye@&#x27;localhost&#x27;;</span><br><span class="line"></span><br><span class="line">#（6）作用在函数上：</span><br><span class="line">delimiter //</span><br><span class="line">create function f1(i1 int,i2 int)</span><br><span class="line">returns int</span><br><span class="line">BEGIN</span><br><span class="line">    declare num int;</span><br><span class="line">    set num = i1 + i2;</span><br><span class="line">    return(num);</span><br><span class="line">END //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">show function status; -- 查看到db1下有一个名为f1的函数</span><br><span class="line"></span><br><span class="line">grant execute on function test.f1 to maye@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的  分组。</p>
<p>所谓横向的分组，就是指用户可以接触到的数据的范围，比如可以看到哪些表的数据；</p>
<p>所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是 删除。</p>
</blockquote>
<p>查看权限：</p>
<ul>
<li>查看当前用户权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS;</span><br><span class="line">#or</span><br><span class="line">SHOW GRANTS FOR CURRENT_USER;</span><br><span class="line">#or</span><br><span class="line">SHOW GRANTS FOR CURRENT_USER();</span><br></pre></td></tr></table></figure>

<ul>
<li>查看某用户的全局权限（root用户）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;user&#x27;@&#x27;hostname&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h3><p>收回权限就是取消已经赋予用户的某些权限。<strong>收回用户不必要的权限可以在一定程度上保证系统的安全</strong>  性。MySQL中使用 REVOKE语句取消用户的某些权限。使用REVOKE收回权限之后，用户账户的记录将从db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中   的账户记录使用DROP USER语句）。</p>
<p><strong>注意：在将用户账户从use表删除之前，应该收回相应用户的所有权限。</strong></p>
<ul>
<li>收回权限语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE  priv_type[,priv_type1...] ON databasename.tablename FROM &#x27;username&#x27;@&#x27;hostname&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>范例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#收回指定用户的全库全表的所有权限</span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM &#x27;tom&#x27;@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line">#收回指定用户mysql库下的所有表的增删改查权限</span><br><span class="line">REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM &#x27;tom&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<p>用户重启登录后才生效。</p>
<h3 id="权限表"><a href="#权限表" class="headerlink" title="权限表"></a>权限表</h3><p>MySQL服务器通过<code>权限表来控制用户对数据库的访问</code>，权限表存放在mysql数据库中。MySQL数据库系统会根据这些权限表的内容为每个用户授予相应的权限。这些权限表中最重要的是<code>user表</code>、<code>db表</code>。除此之外，还有<code>table_priv表</code>、<code>column_priv表</code>和<code>proc_priv表</code>等。在MySQL启动时，服务器将这些数据库表中权限信息的内容读入内存。</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>user</td>
<td>用户账号及权限信息</td>
</tr>
<tr>
<td>global_grants</td>
<td>动态全局授权</td>
</tr>
<tr>
<td>db</td>
<td>数据库层级的权限</td>
</tr>
<tr>
<td>tables_priv</td>
<td>表层级的权限</td>
</tr>
<tr>
<td>columns_priv</td>
<td>列层级的权限</td>
</tr>
</tbody></table>
<h4 id="user表"><a href="#user表" class="headerlink" title="user表"></a>user表</h4><p>user表是MySQL中最重要的一个权限表， 记录用户账号和权限信息 。需要注意的是，在 user 表里启用的所有权限都是全局级的，适用于所有数据库。</p>
<p>user表中的字段可以分成4类，分别是<code>用户列</code>、<code>权限列</code>、<code>安全列</code>和<code>资源控制列</code>。</p>
<h5 id="用户列"><a href="#用户列" class="headerlink" title="用户列"></a>用户列</h5><p>用户列存储了用户连接 MySQL 数据库时需要输入的信息。需要注意的是 MySQL 5.7 版本不再使用 Password 来作为密码的字段，而改成了 authentication_string。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>是否为Null</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>char(255)</td>
<td>NO</td>
<td></td>
<td>主机名</td>
</tr>
<tr>
<td>User</td>
<td>char(32)</td>
<td>NO</td>
<td></td>
<td>用户名</td>
</tr>
<tr>
<td>authentication_string</td>
<td>text</td>
<td>YES</td>
<td>NULL</td>
<td>密码</td>
</tr>
</tbody></table>
<h4 id="权限列"><a href="#权限列" class="headerlink" title="权限列"></a>权限列</h4><p>权限列的字段决定了用户的权限，用来描述在全局范围内允许对数据和数据库进行的操作。</p>
<p>权限大致分为两大类，分别是高级管理权限和普通权限：</p>
<ul>
<li>高级管理权限主要对数据库进行管理，例如关闭服务的权限、超级权限和加载用户等；</li>
<li>普通权限主要操作数据库，例如查询权限、修改权限等。</li>
</ul>
<p>user 表的权限列包括 Select_priv、Insert_ priv 等以 priv 结尾的字段，这些字段值的数据类型为 ENUM，可取的值只有 Y 和 N：Y 表示该用户有对应的权限，N 表示该用户没有对应的权限。从安全角度考虑，这些字段的默认值都为 N。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>是否为Null</th>
<th>默认值</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Select_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以通过SELECT 命令查询数据</td>
</tr>
<tr>
<td>Insert_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以通过 INSERT 命令插入数据</td>
</tr>
<tr>
<td>Update_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以通过UPDATE 命令修改现有数据</td>
</tr>
<tr>
<td>Delete_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以通过DELETE 命令删除现有数据</td>
</tr>
<tr>
<td>Create_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以创建新的数据库和表</td>
</tr>
<tr>
<td>Drop_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以删除现有数据库和表</td>
</tr>
<tr>
<td>Reload_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以执行刷新和重新加载MySQL所用的各种内部缓存的特定命令，包括日志、权限、主机、查询和表</td>
</tr>
<tr>
<td>Shutdown_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以关闭MySQL服务器。将此权限提供给root账户之外的任何用户时，都应当非常谨慎</td>
</tr>
<tr>
<td>Process_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以通过SHOW PROCESSLIST命令查看其他用户的进程</td>
</tr>
<tr>
<td>File_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以执行SELECT INTO OUTFILE和LOAD DATA INFILE命令</td>
</tr>
<tr>
<td>Grant_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以将自己的权限再授予其他用户</td>
</tr>
<tr>
<td>References_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以创建外键约束</td>
</tr>
<tr>
<td>Index_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以对索引进行增删查</td>
</tr>
<tr>
<td>Alter_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以重命名和修改表结构</td>
</tr>
<tr>
<td>Show_db_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以查看服务器上所有数据库的名字，包括用户拥有足够访问权限的数据库</td>
</tr>
<tr>
<td>Super_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以执行某些强大的管理功能，例如通过KILL命令删除用户进程；使用SET GLOBAL命令修改全局MySQL变量，执行关于复制和日志的各种命令。（超级权限）</td>
</tr>
<tr>
<td>Create_tmp_table_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以创建临时表</td>
</tr>
<tr>
<td>Lock_tables_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以使用LOCK TABLES命令阻止对表的访问&#x2F;修改</td>
</tr>
<tr>
<td>Execute_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以执行存储过程</td>
</tr>
<tr>
<td>Repl_slave_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以读取用于维护复制数据库环境的二进制日志文件</td>
</tr>
<tr>
<td>Repl_client_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以确定复制从服务器和主服务器的位置</td>
</tr>
<tr>
<td>Create_view_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以创建视图</td>
</tr>
<tr>
<td>Show_view_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以查看视图</td>
</tr>
<tr>
<td>Create_routine_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以更改或放弃存储过程和函数</td>
</tr>
<tr>
<td>Alter_routine_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以修改或删除存储函数及函数</td>
</tr>
<tr>
<td>Create_user_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以执行CREATE USER命令，这个命令用于创建新的MySQL账户</td>
</tr>
<tr>
<td>Event_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以创建、修改和删除事件</td>
</tr>
<tr>
<td>Trigger_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以创建和删除触发器</td>
</tr>
<tr>
<td>Create_tablespace_priv</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>是否可以创建表空间</td>
</tr>
</tbody></table>
<h4 id="安全列"><a href="#安全列" class="headerlink" title="安全列"></a>安全列</h4><p>安全列主要用来判断用户是否能够登录成功。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>是否为Null</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_type</td>
<td>enum(‘’,’ANY’,’X509’,’SPECIFIED’)</td>
<td>NO</td>
<td></td>
<td>支持ssl标准加密安全字段</td>
</tr>
<tr>
<td>ssl_cipher</td>
<td>blob</td>
<td>NO</td>
<td>NULL</td>
<td>支持ssl标准安全字段</td>
</tr>
<tr>
<td>x509_issuer</td>
<td>blob</td>
<td>NO</td>
<td>NULL</td>
<td>支持x509字段</td>
</tr>
<tr>
<td>x509_subject</td>
<td>blob</td>
<td>NO</td>
<td>NULL</td>
<td>支持x509字段</td>
</tr>
<tr>
<td>plugin</td>
<td>char(64)</td>
<td>NO</td>
<td>caching_sha2_password</td>
<td>引入plugins以进行用户连接时的密码验证，plugin创建外部&#x2F;代理用户</td>
</tr>
<tr>
<td>password_expired</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>密码是否过期</td>
</tr>
<tr>
<td>password_last_changed</td>
<td>timestamp</td>
<td>YES</td>
<td>NULL</td>
<td>记录密码最近修改时间</td>
</tr>
<tr>
<td>password_lifetime</td>
<td>smallint unsigned</td>
<td>YES</td>
<td>NULL</td>
<td>设计密码的有效时间，单位为天数</td>
</tr>
<tr>
<td>account_locked</td>
<td>enum(‘N’,’Y’)</td>
<td>NO</td>
<td>N</td>
<td>用户是否被锁定</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：即使 password_expired 为“Y”，用户也可以使用密码登录 MySQL，但是不允许做任何操作。</p>
</blockquote>
<p>通常标准的发行版不支持 ssl，可以使用 SHOW VARIABLES LIKE “have_openssl” 语句来查看是否具有 ssl 功能。如果 have_openssl 的值为 DISABLED，那么则不支持 ssl 加密功能。</p>
<h4 id="资源控制列"><a href="#资源控制列" class="headerlink" title="资源控制列"></a>资源控制列</h4><p>资源控制列的字段用来限制用户使用的资源 ，包含4个字段，分别为：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>是否为空</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>max_questions</td>
<td>int(11) unsigned</td>
<td>NO</td>
<td>0</td>
<td>规定每小时允许执行查询的操作次数</td>
</tr>
<tr>
<td>max_updates</td>
<td>int(11) unsigned</td>
<td>NO</td>
<td>0</td>
<td>规定每小时允许执行更新的操作次数</td>
</tr>
<tr>
<td>max_connections</td>
<td>int(11) unsigned</td>
<td>NO</td>
<td>0</td>
<td>规定每小时允许执行的连接操作次数</td>
</tr>
<tr>
<td>max_user_connections</td>
<td>int(11) unsigned</td>
<td>NO</td>
<td>0</td>
<td>规定允许同时建立的连接次数</td>
</tr>
</tbody></table>
<h3 id="db表"><a href="#db表" class="headerlink" title="db表"></a>db表</h3><p>db 表比较常用，是 MySQL 数据库中非常重要的权限表，表中存储了用户对某个数据库的操作权限。表中的字段大致可以分为两类，分别是用户列和权限列。</p>
<h4 id="用户列-1"><a href="#用户列-1" class="headerlink" title="用户列"></a>用户列</h4><p>db 表用户列有 3 个字段，分别是 Host、User、Db，标识从某个主机连接某个用户对某个数据库的操作权限，这 3 个字段的组合构成了 db 表的主键。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>为空</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>char(60)</td>
<td>NO</td>
<td>无</td>
<td>主机名</td>
</tr>
<tr>
<td>Db</td>
<td>char(64)</td>
<td>NO</td>
<td>无</td>
<td>数据库名</td>
</tr>
<tr>
<td>User</td>
<td>char(32)</td>
<td>NO</td>
<td>无</td>
<td>用户名</td>
</tr>
</tbody></table>
<h4 id="权限列-1"><a href="#权限列-1" class="headerlink" title="权限列"></a>权限列</h4><p>db 表中的权限列和 user 表中的权限列大致相同，只是user 表中的权限是针对所有数据库的，而 db 表中的权限只针对指定的数据库。如果希望用户只对某个数据库有操作权限，可以先将 user 表中对应的权限设置为 N，然后在 db 表中设置对应数据库的操作权限。</p>
<h4 id="tables-priv表和columns-priv表"><a href="#tables-priv表和columns-priv表" class="headerlink" title="tables_priv表和columns_priv表"></a>tables_priv表和columns_priv表</h4><p>tables_priv 表用来对单个表进行权限设置，columns_priv 表用来对单个数据列进行权限设置。</p>
<p>tables_priv 表结构如下表：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>为空</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>char(60)</td>
<td>NO</td>
<td>无</td>
<td>主机</td>
</tr>
<tr>
<td>Db</td>
<td>char(64)</td>
<td>NO</td>
<td>无</td>
<td>数据库名</td>
</tr>
<tr>
<td>User</td>
<td>char(32)</td>
<td>NO</td>
<td>无</td>
<td>用户名</td>
</tr>
<tr>
<td>Table_name</td>
<td>char(64)</td>
<td>NO</td>
<td>无</td>
<td>表名</td>
</tr>
<tr>
<td>Grantor</td>
<td>char(93)</td>
<td>NO</td>
<td>无</td>
<td>修改该记录的用户</td>
</tr>
<tr>
<td>Timestamp</td>
<td>timestamp</td>
<td>NO</td>
<td>CURRENT_TIMESTAMP</td>
<td>修改该记录的时间</td>
</tr>
<tr>
<td>Table_priv</td>
<td>set(‘Select’,’Insert’,’Update’,’Delete’,’ Create’,’Drop’,’Grant’,’References’, ‘Index’,’Alter’,’Create View’,’Show view’,’Trigger’)</td>
<td>NO</td>
<td>无</td>
<td>表示对表的操作权限，包括 Select、Insert、Update、Delete、Create、Drop、Grant、References、Index 和 Alter 等</td>
</tr>
<tr>
<td>Column_priv</td>
<td>set(‘Select’,’Insert’,’Update’,’References’)</td>
<td>NO</td>
<td>无</td>
<td>表示对表中的列的操作权限，包括 Select、Insert、Update 和 References</td>
</tr>
</tbody></table>
<p>columns_priv表的结构:</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>为空</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>char(60)</td>
<td>NO</td>
<td>无</td>
<td>主机</td>
</tr>
<tr>
<td>Db</td>
<td>char(64)</td>
<td>NO</td>
<td>无</td>
<td>数据库名</td>
</tr>
<tr>
<td>User</td>
<td>char(32)</td>
<td>NO</td>
<td>无</td>
<td>用户名</td>
</tr>
<tr>
<td>Table_name</td>
<td>char(64)</td>
<td>NO</td>
<td>无</td>
<td>表名</td>
</tr>
<tr>
<td>Column_name</td>
<td>char(64)</td>
<td>NO</td>
<td>无</td>
<td>数据列名称，用来指定对哪些数据列具有操作权限</td>
</tr>
<tr>
<td>Timestamp</td>
<td>timestamp</td>
<td>NO</td>
<td>CURRENT_TIMESTAMP</td>
<td>修改该记录的时间</td>
</tr>
<tr>
<td>Column_priv</td>
<td>set(‘Select’,’Insert’,’Update’,’References’)</td>
<td>NO</td>
<td>无</td>
<td>表示对表中的列的操作权限，包括 Select、Insert、Update 和 References</td>
</tr>
</tbody></table>
<h4 id="procs-priv表"><a href="#procs-priv表" class="headerlink" title="procs_priv表"></a>procs_priv表</h4><p>procs_priv表可以对 存储过程和存储函数设置操作权限 ，表结构如下表：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>为空</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>char(60)</td>
<td>NO</td>
<td>无</td>
<td>主机名</td>
</tr>
<tr>
<td>Db</td>
<td>char(64)</td>
<td>NO</td>
<td>无</td>
<td>数据库名</td>
</tr>
<tr>
<td>User</td>
<td>char(32)</td>
<td>NO</td>
<td>无</td>
<td>用户名</td>
</tr>
<tr>
<td>Routine_name</td>
<td>char(64)</td>
<td>NO</td>
<td>无</td>
<td>表示存储过程或函数的名称</td>
</tr>
<tr>
<td>Routine_type</td>
<td>enum(‘FUNCTION’,’PROCEDURE’)</td>
<td>NO</td>
<td>无</td>
<td>表示存储过程或函数的类型，Routine_type 字段有两个值，分别是 FUNCTION 和 PROCEDURE。FUNCTION 表示这是一个函数；PROCEDURE 表示这是一个 存储过程。</td>
</tr>
<tr>
<td>Grantor</td>
<td>char(93)</td>
<td>NO</td>
<td>无</td>
<td>插入或修改该记录的用户</td>
</tr>
<tr>
<td>Proc_priv</td>
<td>set(‘Execute’,’Alter Routine’,’Grant’)</td>
<td>NO</td>
<td>无</td>
<td>表示拥有的权限，包括 Execute、Alter Routine、Grant 3种</td>
</tr>
<tr>
<td>Timestamp</td>
<td>timestamp</td>
<td>NO</td>
<td>CURRENT_TIMESTAMP</td>
<td>表示记录更新时间</td>
</tr>
</tbody></table>
<h3 id="访问控制（了解一下）"><a href="#访问控制（了解一下）" class="headerlink" title="访问控制（了解一下）"></a>访问控制（了解一下）</h3><p>正常情况下，并不希望每个用户都可以指向所有的数据库权限。当MySQL允许一个用户执行各种操作时，它首先核实该用户向MySQL服务器发送的连接请求，然后确认用户的操作请求是否被允许。这个过程称为MySQL中的访问控制过程。MySQL的访问控制分为两个阶段：<code>连接核实阶段</code>和<code>请求核实阶段</code>。</p>
<h4 id="连接核实阶段"><a href="#连接核实阶段" class="headerlink" title="连接核实阶段"></a>连接核实阶段</h4><p>当用户试图连接MySQL服务器时，服务器基于用户的身份以及用户是否能提供正确的密码验证身份来确定接受或者拒绝连接。即客户端用户会在连接请求中提供用户名、主机地址、用户密码，MySQL服务器  接收到用户请求后，会<strong>使用user表中的host、user和authentication_string这3个字段匹配客户端提供信息</strong>。</p>
<p>服务器只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接。<strong>如果连接核实没有通过，服务器就完全拒绝访问</strong>；<strong>否则，服务器接受连接，然后进入阶段2等待用户请求。</strong></p>
<h4 id="请求核实阶段"><a href="#请求核实阶段" class="headerlink" title="请求核实阶段"></a>请求核实阶段</h4><p>一旦建立了连接，服务器就进入了访问控制的阶段2，也就是请求核实阶段。对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自user、db、table_priv和column_priv表。</p>
<p>确认权限时，MySQL首先 检查user表 ，如果指定的权限没有在user表中被授予，那么MySQL就会继续</p>
<p>查db表 ，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL继续 检查tables_priv表 以及 columns_priv表 ，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将 返回错误信息 ，用户请求的操作不能执行，操作失败。请求核实的过程如图所示:</p>
<p><img src="/./C:/Users/Asus/Desktop/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/assets/image-20220630141206134.png" alt="image-20220630141206134"></p>
<blockquote>
<p>提示：  MySQL通过向下层级的顺序（从user表到columns_priv表）检查权限表，但并不是所有的权限都要执行该过程。例如，一个用户登录到MySQL服务器之后只执行对MySQL的管理操作，此时只  涉及管理权限，因此MySQL只检查user表。另外，如果请求的权限操作不被允许，MySQL也不会继  续检查下一层级的表。</p>
</blockquote>
<h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h3><h4 id="角色的理解"><a href="#角色的理解" class="headerlink" title="角色的理解"></a>角色的理解</h4><p>角色是<code>权限的集合</code>，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且像用户账户一样，角色可以有用授予和撤销的权限。</p>
<p>引入角色的目的是 方便管理拥有相同权限的用户 。<strong>恰当的权限设定，可以确保数据的安全性，这是至关重要的</strong>。</p>
<p><img src="/./C:/Users/Asus/Desktop/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/assets/image-20220608183730027.png" alt="image-20220608183730027"></p>
<h4 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h4><p>创建角色使用 CREATE ROLE 语句，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE &#x27;role_name&#x27;[@&#x27;host_name&#x27;];</span><br></pre></td></tr></table></figure>

<p>角色名称的命名规则和用户名类似。如果<code>host_name省略，默认为%，role_name不可省略</code>，不可为空。</p>
<p>练习：我们现在需要创建一个经理的角色，就可以用下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE &#x27;manager&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="给角色赋予权限"><a href="#给角色赋予权限" class="headerlink" title="给角色赋予权限"></a>给角色赋予权限</h4><p>创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT priv_type[,priv_type1...] ON table_name TO &#x27;role_name&#x27;[@&#x27;host_name&#x27;];</span><br></pre></td></tr></table></figure>

<p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>**范例：**我们现在想给经理角色授予商品信息表、盘点表和应付账款表的只读权限，就可以用下面的代码来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT ON demo.settlement TO &#x27;manager&#x27;; </span><br><span class="line">GRANT SELECT ON demo.goodsmaster TO &#x27;manager&#x27;;</span><br><span class="line">GRANT SELECT ON demo.invcount TO &#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="查看角色的权限"><a href="#查看角色的权限" class="headerlink" title="查看角色的权限"></a>查看角色的权限</h4><p>赋予角色权限之后，我们可以通过SHOW GRANTS语句来查看权限是否创建成功了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GRANTS FOR &#x27;manager&#x27;;</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| Grants for manager@% |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">| GRANT USAGE ON *.* TO `manager`@`%` |</span><br><span class="line">| GRANT SELECT ON `demo`.`goodsmaster` TO `manager`@`%` |</span><br><span class="line">| GRANT SELECT ON `demo`.`invcount` TO `manager`@`%` |</span><br><span class="line">| GRANT SELECT ON `demo`.`settlement` TO `manager`@`%` |</span><br><span class="line">+-------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是连接登录数据库的权限 。代码的最后三行代表了我们给角色“manager”赋予的权限，也就是对商品信息表、盘点表和应付账款表的只读权限。</p>
<p>结果显示，库管角色拥有商品信息表的只读权限和盘点表的增删改查权限。</p>
<h4 id="回收角色的权限"><a href="#回收角色的权限" class="headerlink" title="回收角色的权限"></a>回收角色的权限</h4><p>角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色  授权相同。撤销角色或角色权限使用REVOKE语句。</p>
<p>修改了角色的权限，会影响拥有该角色的账户的权限。</p>
<p>撤销角色权限的SQL语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE priv_type[,priv_type1...] ON table_name FROM &#x27;role_name&#x27;;</span><br></pre></td></tr></table></figure>

<p>练习1：撤销school_write角色的权限。</p>
<p>（1）使用如下语句撤销school_write角色的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE INSERT,UPDATE,DELETE ON shool.* FROM &#x27;school_write&#x27;;</span><br></pre></td></tr></table></figure>

<p>（2） 撤销后使用SHOW语句查看school_write对应的权限，语句如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;school_write&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="删除角色"><a href="#删除角色" class="headerlink" title="删除角色"></a>删除角色</h4><p>当我们需要对业务重新整合的时候，可能就需要对之前创建的角色进行清理，删除一些不会再使用的角  色。删除角色的操作很简单，你只要掌握语法结构就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP ROLE role[,role1...];</span><br></pre></td></tr></table></figure>

<p>注意，如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限。</p>
<p>练习：执行如下SQL删除角色school_read。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP ROLE &#x27;school_read&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="给用户赋予角色"><a href="#给用户赋予角色" class="headerlink" title="给用户赋予角色"></a>给用户赋予角色</h4><p>角色创建并授权后，要赋给用户并处于 激活状态 才能发挥作用。给用户添加角色可使用GRANT语句，语法形式如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT role[,role1...] TO user_or_role[,user_or_role];</span><br></pre></td></tr></table></figure>

<p>在上述语句中，role代表角色，user代表用户。可将多个角色同时赋予多个用户，用逗号隔开即可。</p>
<p>练习：给kangshifu用户添加角色school_read权限。</p>
<p>（1）使用GRANT语句给kangshifu添加school_read权限，SQL语句如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT &#x27;school_read&#x27; TO &#x27;maye&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<p>（2） 添加完成后使用SHOW语句查看是否添加成功，SQL语句如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;maye&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<p>（3） 使用kangshifu用户登录，然后查询当前角色，如果角色未激活，结果将显示NONE。SQL语句如  下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CURRENT_ROLE();</span><br></pre></td></tr></table></figure>

<h4 id="激活角色"><a href="#激活角色" class="headerlink" title="激活角色"></a>激活角色</h4><p><strong>方式1：使用set default role 命令激活角色</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT ROLE ALL TO &#x27;user_name&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<p>**范例：**为用户激活所有拥有的角色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT ROLE ALL TO</span><br><span class="line"> &#x27;dev1&#x27;@&#x27;localhost&#x27;,</span><br><span class="line"> &#x27;read_user1&#x27;@&#x27;localhost&#x27;,</span><br><span class="line"> &#x27;read_user2&#x27;@&#x27;localhost&#x27;,</span><br><span class="line"> &#x27;rw_user&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>方式2：将activate_all_roles_on_login设置为ON</strong><br>默认情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;activate_all_roles_on_login&#x27;;</span><br><span class="line">+-----------------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------------+-------+</span><br><span class="line">| activate_all_roles_on_login | OFF |</span><br><span class="line">+-----------------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>设置：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL activate_all_roles_on_login=ON;</span><br></pre></td></tr></table></figure>

<p>这条 SQL 语句的意思是，对所有角色永久激活 。运行这条语句之后，用户才真正拥有了赋予角色的所有权限。</p>
<h4 id="撤销用户的角色"><a href="#撤销用户的角色" class="headerlink" title="撤销用户的角色"></a>撤销用户的角色</h4><p>撤销用户角色的SQL语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE role_name FROM user_name;</span><br></pre></td></tr></table></figure>

<p> **范例：**撤销maye用户的school_read角色。</p>
<p> （1）撤销的SQL语句如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &#x27;school_read&#x27; FROM &#x27;maye&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<p>（2）撤销后，执行如下查询语句，查看maye用户的角色信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;maye&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<p>执行发现，用户maye之前的school_read角色已被撤销。</p>
<h4 id="设置强制角色-mandatory-role"><a href="#设置强制角色-mandatory-role" class="headerlink" title="设置强制角色(mandatory role)"></a>设置强制角色(mandatory <strong>role)</strong></h4><p>方式1：服务启动前设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">mandatory_roles=&#x27;role1,role2@localhost,role3@%.maye.com&#x27;</span><br></pre></td></tr></table></figure>

<p>方式2：运行时设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET PERSIST mandatory_roles=&#x27;role1,role2@localhost,role3@%.maye.com&#x27;;#重启后依然有效</span><br><span class="line">SET GLOBAL mandatory_roles=&#x27;role1,role2@localhost,role3@%.maye.com&#x27;;#重启后失效</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="数据库事务概述"><a href="#数据库事务概述" class="headerlink" title="数据库事务概述"></a>数据库事务概述</h3><p>基本概念</p>
<p><strong>事务</strong>:一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p><strong>事务处理的原则</strong>:保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来;要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account SET money = money - 50 WHERE name=&#x27;A&#x27;;</span><br><span class="line">#宕机了</span><br><span class="line">3UPDATE account SET money = money + 50 WHERE name=&#x27;B&#x27;;</span><br></pre></td></tr></table></figure>

<p>事务的状态</p>
<p>我们现在知道事务是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把事务大致划分成几个状态:</p>
<p><strong>活动的(active)</strong><br>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<strong>活动的</strong>状态。</p>
<p><strong>部分提交的(partially committed)</strong><br>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并<strong>没有刷新到磁盘</strong>时，我们就说该事务处在部分提交的状态。</p>
<p><strong>失败的(failed)</strong><br>当事务处在<strong>活动的</strong>或者<strong>部分提交的</strong>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<strong>失败的</strong>状态。</p>
<p><strong>中止的(aborted)</strong><br>如果事务执行了一部分而变为<strong>失败的</strong>状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为<strong>回滚</strong>。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p>
<p><strong>提交的(committed)</strong><br>当一个处在<strong>部分提交的</strong>状态的事务将修改过的数据都<strong>同步到磁盘</strong>上之后，我们就可以说该事务处在了<strong>提交的</strong>状态。一个基本的状态转换图如下所示:</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221116104458850.png" alt="image-20221116104458850"></p>
<p>事务的ACID特性</p>
<p><strong>原子性(atomicity)</strong><br>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么转账成功，要么转账失败，是不存在中间状态的。如果不发保证原子性会怎么样?就会出现数据不一致的情形，A账户减去100元，而B账户增加100元操作失败，系统将无故丢失100元。</p>
<p><strong>一致性(consistency)</strong><br>根据定义，一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关。</p>
<p>那什么是合法的数据状态呢?满足预定的约束的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的(比如满足现实世界中的约束)。满足这个状态，数据就是一致的，不满足这个状态，数据就。是不一致的!如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p>
<ul>
<li>列如: A账户有200元，转账300元出去，此时余额为-100。你自然就发现了此时数据是不一致的，为什么呢?因为你定义了一个状态，余额这列必须&gt;&#x3D;0.</li>
<li>列如: A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额没有增加。你也知道此时数据是不一致的，为什么呢?因为你定义了一个状态，要求A+B的总余额必须不变。</li>
</ul>
<p><strong>隔离型(isolation)</strong><br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>如果无法保证隔离性会怎么样?假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE accounts SET money = money - 50 WHERE name=&#x27;A&#x27;;</span><br><span class="line">UPDATE accountsSET money = money + 50 WHERE name=&#x27;B &#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221116111012657.png" alt="image-20221116111012657"></p>
<p><strong>持久性(durability)</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<blockquote>
<p>总结</p>
<p>ACID是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</p>
<p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证原子性、隔高性、一致性和持久性的一个或多个数据操作称为一个事务。</p>
</blockquote>
<h3 id="如何使用事务"><a href="#如何使用事务" class="headerlink" title="如何使用事务"></a>如何使用事务</h3><p>使用事务有两种方式，分别为显式事务和隐式事务。</p>
<h4 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h4><p><strong>步骤1</strong>:START TRANSACTION或者BEGIN，作用是显式开启一个事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysq1&gt; BEGIN;</span><br><span class="line">#或者</span><br><span class="line">mysq1&gt; START TRANSACTION</span><br></pre></td></tr></table></figure>

<p>START TRANSACTION语句相较于BEGIN特别之处在于，后边能跟随几个修饰符:</p>
<ul>
<li>READ ONLY:标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</li>
<li>READ wRITE:标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</li>
<li>WITH CONSISTENT SNAPSHOT:启动一致性读。</li>
</ul>
<p><strong>步骤2</strong>:一系列事务中的操作(主要是DML，不含DDL)</p>
<p><strong>步骤3</strong>:提交事务或中止事务(即回滚事务)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#提交事务。当提交事务后，对数据库的修改是永久性的。mysq1&gt;COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#回滚事务。即撤销正在进行的所有没有提交的修改2 mysq1&gt;ROLLBACK;</span><br><span class="line"></span><br><span class="line">#将事务回滚到某个保存点。</span><br><span class="line">mysq1&gt; ROLLBACK [TO SAVEPOINT 名字]</span><br></pre></td></tr></table></figure>

<h4 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h4><p>MySQL中有一个系统变量autocommit :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOw VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| variab1e_name | value |</span><br><span class="line">+-—----------———+-------+</span><br><span class="line">|autocommit     | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>当然，如果我们想关闭这种<strong>自动提交</strong>的功能，可以使用下边两种方法之一:</p>
<ul>
<li>显式的的使用STARTTRANSACTION或者BEGIN语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li>
<li>把系统变量autocommit的值设置为OFF ．就像这样:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = OFF;</span><br><span class="line">#或</span><br><span class="line">SET autocommit = 0;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@autocommit=FALSE;</span><br><span class="line">SELECT @@autocommit=TURE;</span><br><span class="line">#如果autocommit为false，则默认开启事务，每个sql语句，都需要自己提交或者回滚</span><br><span class="line">sql语句</span><br><span class="line">...</span><br><span class="line">COMMIT;</span><br><span class="line">#回滚</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<h3 id="隐式提交数据的情况"><a href="#隐式提交数据的情况" class="headerlink" title="隐式提交数据的情况"></a>隐式提交数据的情况</h3><ul>
<li><p>数据定义语言(Data definition language，缩写为:DDL)</p>
</li>
<li><p>隐式使用或修改mysql数据库中的表</p>
</li>
<li><p>事务控制或关于锁定的语句</p>
<ul>
<li>当我们在一个事务还没提交或者回滚时就又使用STARTTRANSACTION或者BEGIN语句开启了另一个事务时，会隐式的提交上一个事务。即:</li>
<li>当前的autocommit系统变量的值为OFF，我们手动把它调为ON时，也会隐式的提交前边语句所属的事务。</li>
<li>使用LOCKTABLES、UNLOCK TABLES等关于锁定的语句也会隐式的提交前边语句所属的事务。</li>
</ul>
</li>
<li><p>加载数据得语句</p>
</li>
<li><p>关于MySQL复制得一些语句</p>
</li>
<li><p>其它得一些语句</p>
</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>MySQL是一个客户端&#x2F;服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话 ( Session )。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分,也就是对于服务器来说可能同时处理多个事务。事务有隔离性的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对性能影响太大，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，那就看二者如何权衡取舍了。</p>
<h4 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h4><h4 id="1-脏写-Dirty-Write"><a href="#1-脏写-Dirty-Write" class="headerlink" title="1.脏写(Dirty Write )"></a>1.脏写(Dirty Write )</h4><p>对于两个事务Session A、Session B，如果事务Session A修改了另一个未提交事务SessionB修改过的数据，那就意味着发生了脏写。</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221116150602298.png" alt="image-20221116150602298"></p>
<p>Session A和session B各开启了一个事务，Session B中的事务先将sno列为1的记录的name列更新为李四，然后session A中的事务接着又把这条sno列为1的记录的name列更新为张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象就称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离级比较了解的话，会发现默认隔离级别下，上面SessionA中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样现象。</p>
<h4 id="2-脏读-Dirty-Read"><a href="#2-脏读-Dirty-Read" class="headerlink" title="2.脏读(Dirty Read )"></a>2.脏读(Dirty Read )</h4><p>对于两个事务Session A、Session B，Session A读取了已经被Session B更新但还没有被提交的字段。之后若Session B回滚，Session A读取的内容就是临时且无效的。</p>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为张三’，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。</p>
<h4 id="3-不可重复读-Non-Repeatable-Read"><a href="#3-不可重复读-Non-Repeatable-Read" class="headerlink" title="3.不可重复读(Non-Repeatable Read )"></a>3.不可重复读(Non-Repeatable Read )</h4><p>对于两个事务Session A、 Session B,Session A 读取)了一个字段，然后Session B更新了该字段。之后Session A再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。</p>
<p>我们在Session B中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了)，这些事务都修改了sno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为不可重复读。</p>
<h4 id="4-幻读-Phantom"><a href="#4-幻读-Phantom" class="headerlink" title="4.幻读(Phantom )"></a>4.幻读(Phantom )</h4><p>对于两个事务SessionA、Session B, Session A从一个表中读取了一个字段,然后SessionB在该表中插入了一些新的行。之后,如果SessionA再次诗取同一个表就会多出几行。那就意味着发生了幻读。</p>
<p>Session A中的事务先根据条件studentno&gt;0这个条件查询表student，得到了name列值为张三’的记录;之后Session B中提交了一个隐式事务，该事务向表student中插入了一条新记录;之后Session A中的事务再根据相同的条件sno&gt;0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为幻读。我们把新插入的那些记录称之为幻影记录。</p>
<h3 id="SQL中的四种隔离级别"><a href="#SQL中的四种隔离级别" class="headerlink" title="SQL中的四种隔离级别"></a>SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序:</p>
<blockquote>
<p>脏写&gt;脏读&gt;不可重复读&gt;幻读</p>
</blockquote>
<p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在:设立一些隔离级别，隔离级别越低，并发问题发生的就越多。<strong>SQL标准中设立了4个隔离级别</strong>:</p>
<ul>
<li><p>READ UNCOMITTED:读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</p>
</li>
<li><p>READ COMMITTED:读已提交，它满足了隔离的简单定义:一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)。可以避免脏读，但不可重复读、幻读问题仍然存在。</p>
</li>
<li><p>REPEATABLE READ:可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</p>
</li>
<li><p>SERIALLIZABLE:可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</p>
<p><strong>SQL标准中规定</strong>，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下:</p>
</li>
</ul>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221116151952907.png" alt="image-20221116151952907"></p>
<p><strong>脏写</strong>怎么没涉及到?因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p>
<p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下:</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221116152508558.png" alt="image-20221116152508558"></p>
<h3 id="查看MySQL当前的隔离级别"><a href="#查看MySQL当前的隔离级别" class="headerlink" title="查看MySQL当前的隔离级别"></a>查看MySQL当前的隔离级别</h3><p>MySQL的默认隔离级别为REPEATABLE READ，通过全局变量可以查看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#查看隔离级别,MySQL 5.7.20的版本之前:</span><br><span class="line">mysql&gt; SHOw VARIABLES LIKE &#x27;tx_isolation &#x27; ;+---------------+--—------------—-+</span><br><span class="line">| variab1e_name | value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| tx_isolation | REPEATABLE-READ  |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation #查看隔离级别，MySQL 5.7.20的版本及之后: mysq1&gt;SHOW VARIABLES LIKE &#x27;transaction_isolation &#x27;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| variable_name         | value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |+-----------------------+-----------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<h3 id="设置MySQL当前的隔离级别"><a href="#设置MySQL当前的隔离级别" class="headerlink" title="设置MySQL当前的隔离级别"></a>设置MySQL当前的隔离级别</h3><p>通过下面的语句修改事务的隔离级别:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBALISESSION] TRANSACTION ISOLATION LEVEL隔离级别;</span><br><span class="line">#其中，隔离级别格式:</span><br><span class="line">&gt;READ UNCOMMITTED</span><br><span class="line">&gt;READ COMMITTED</span><br><span class="line">&gt;REPEATABLE READ</span><br><span class="line">&gt;SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION =&#x27;隔离级别&#x27;</span><br><span class="line">#其中,隔离级别格式:</span><br><span class="line">&gt;READ-UNCOMMITTED</span><br><span class="line">&gt;READ-COMMITTED</span><br><span class="line">&gt;REPEATABLE-READ</span><br><span class="line">&gt;SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p><strong>关于设置时使用GLOBAL或SESSION的影响:</strong></p>
<ul>
<li>使用GLOBAL关键字(在全局范围影响):</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET GLOBAL TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure>

<p>则：<br>当前已经存在的会话无效<br>只对执行完该语句之后产生的会话起作用</p>
<ul>
<li>使用SESSION关键字(在会话范围影响):</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET SESSION TRANSACTION_ISOLATION =&#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure>

<p>则：<br>对当前会话的所有后续的事务有效<br>如果在事务之间执行，则对后续的事务有效<br>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</p>
<p>小结:<br>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p>
<h2 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h2><p>在任何数据环境下，总会有不确定的以外发生，为了有效的防止数据丢失，并将损失降到最小，应定期对MySQL数据库服务器做备份。如果数据库中的数据丢失或者出现错误，可以使用备份的数据进行恢复。主从服务器之间的数据同步问题可以通过复制功能实现。</p>
<h3 id="物理备份与逻辑备份"><a href="#物理备份与逻辑备份" class="headerlink" title="物理备份与逻辑备份"></a>物理备份与逻辑备份</h3><p><strong>物理备份</strong>：备份数据文件，转存数据库物理文件到某一目录。物理备份速度比较块，但占用空间比较大，MySQL中可以用xtrabackup工具进行物理备份。</p>
<p><strong>逻辑备份</strong>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但是占用空间小，更灵活。MySQL中常用的逻辑备份工作mysqldump。逻辑备份就是备份sql语句，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p>
<h3 id="mysqldump命令实现逻辑备份"><a href="#mysqldump命令实现逻辑备份" class="headerlink" title="mysqldump命令实现逻辑备份"></a>mysqldump命令实现逻辑备份</h3><p>备份一个数据库</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -h 主机名称 -p 密码 [tbname,[tbname...]]&gt; 备份文件名称.sql #备份名可以写出存储到的位置 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：备份的文件并非一定要求后缀为.sql，例如后缀名为.txt的文件也是可以的。</p>
</blockquote>
<p>备份全部数据库</p>
<p>若想用mysqldump备份整个实例，可以使用–all-database或-A参数<br>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 密码 --all-database &gt; 备份文件名称.sql </span><br><span class="line"></span><br><span class="line">mysqldump -u 用户名 -p 密码 -A &gt; 备份文件名称.sql </span><br></pre></td></tr></table></figure>

<p>备份部分数据库</p>
<p>若想用mysqldump备份部分实例，可以使用–database或-B参数，<br>指定database备份中会存在创建数据库的语句，如果不指定参数，则不存在。<br>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 密码 --database [数据库名1 [数据库2...]]  &gt; 备份文件名称.sql </span><br></pre></td></tr></table></figure>

<p>备份部分表<br>比如在表更变前做个备份<br>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 密码 数据库的名称 [表1 [表2...]] &gt; 备份文件名称.sql </span><br></pre></td></tr></table></figure>

<p>备份单表的部分数据<br>有时候表数据很大，我们只需要部分数据，这时候就可以使用–where选项了。where后面附带带需求要满足的条件<br>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 密码 数据库的名称 表名 --where=&quot;条件&quot; &gt; 备份文件名称.sql </span><br></pre></td></tr></table></figure>

<p>只备份结构或只备份数据</p>
<p>只备份结构的话使用–on-data选项（简写为-d）<br>只备份数据的话使用–no-create-info选项（简写为-t）<br>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 密码 数据库的名称 --no-data &gt; 备份文件名称.sql </span><br><span class="line"></span><br><span class="line">mysqldump -u 用户名 -p 密码 数据库的名称 --no-create-info &gt; 备份文件名称.sql </span><br></pre></td></tr></table></figure>

<p>备份中包含存储过程、函数、事件</p>
<p>mysqldump备份默认是不包含存储过程，自定义函数及事件的。可以使用–routines或-R选项来备份存储过程及函数，使用–events或-E选项来备份事件。</p>
<p>查看当前库有哪些存储过程或者函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SPECIFIC_NAME,ROUTINE_TYPE,ROUTINE_SCHEMA FROM information_schema.Routines WHERE ROUTINE_SCHEMA=&quot;库名&quot;;</span><br></pre></td></tr></table></figure>

<p>备份数据库数据，函数，以及存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 密码 -R -E --database 数据库的名称 &gt; 备份文件名称.sql </span><br></pre></td></tr></table></figure>

<p>排除某些表的备份</p>
<p>如果我们想备份某个库，但是某些表数据很大或者业务关联不大，这个时候可以考虑排除掉这些表，同样的，选项–ignore-table 可以完成这个功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u用户名 -p 密码   数据库的名称 --ignore-table=数据库名.表名 &gt; 备份文件名称.sql </span><br></pre></td></tr></table></figure>

<h3 id="MySQL命令恢复数据"><a href="#MySQL命令恢复数据" class="headerlink" title="MySQL命令恢复数据"></a>MySQL命令恢复数据</h3><p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u用户名 -p 密码   [dbname] &lt; 备份文件名称.sql </span><br><span class="line"></span><br><span class="line">#如果备份中有建立数据库的语句就可以不用建立数据库，如果没有需要自己先建立数据库</span><br></pre></td></tr></table></figure>

<h3 id="表的导出"><a href="#表的导出" class="headerlink" title="表的导出"></a>表的导出</h3><p>使用SELECT…INTO OUTFILE导出文本文件（不会导出表头）</p>
<p>1.选择数据库，并查询表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use 库名</span><br><span class="line">select * from 表名 ;</span><br></pre></td></tr></table></figure>

<p>2.导出emp表到指定的目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *FROM 数据库.表名 INTO OUTFILE &#x27;位置/名字.txt&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT *FROM 数据库.表名 INTO OUTFILE &#x27;位置/名字.csv&#x27; FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>在使用INTO OUTFILE这个语句的时候会出现错误</p>
<p>错误原因是：<strong>变量secure_file_priv的选值不对</strong></p>
<p>变量secure_file_priv可选值和作用：</p>
<ul>
<li>如果设置为empty，表示不限制文本生成的位置，这是不安全的；</li>
<li>如果设置为一个标识路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li>
<li>如果设置为null，就表明进制在这个MySQL实例上执行INTO OUTFILE操作。</li>
</ul>
<p>**注意：**这个变量是只读变量，不能通过SQL语句修改，只能修改my.ini配置文件，然后重启服务器（变量放到mysqld组中）</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">secure_file_priv</span>=</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="使用mysqldump命令导出文本文件"><a href="#使用mysqldump命令导出文本文件" class="headerlink" title="使用mysqldump命令导出文本文件"></a>使用mysqldump命令导出文本文件</h4><blockquote>
<p>不会导出表头，只有表数据</p>
</blockquote>
<p>举例：使用mysqldump命令将test数据库中emp表中的记录导出到文本文件和sql文件（只包含创建表的语句）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#注意：结尾不能加分号</span><br><span class="line">mysqldump -uroot -p -T &quot;c:/Users&quot; test emp</span><br></pre></td></tr></table></figure>

<p>执行完会生成txt文件（数据）和sql文件（结构）</p>
<p>举例2∶使用mysqldump将test数据库中的emp表导出到文本文件，使用FIELDS选项，要求字段之间使用逗号,)间隔，字符串类型字段值用双引号括起来:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysqldump -uroot -p -T &quot;c:/Users/Maye/backup&quot; test emp --fields-terminated-by=，--fields-optional1y-enclosed-by=\ &quot;</span><br></pre></td></tr></table></figure>

<p>打开account.txt文件，其内容包含创建account表的数据。从文件中可以看出，字段之间用逗号隔开，字符类型的值被双引号括起来.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 7369, &quot;SMITH&quot; , &quot;CLERK&quot;,7902, &quot;1980-12-17&quot;, 800, \N, 20</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="使用mysql命令导出文本文件"><a href="#使用mysql命令导出文本文件" class="headerlink" title="使用mysql命令导出文本文件"></a>使用mysql命令导出文本文件</h4><p>举例1:使用mysql语句导出test数据中emp表中的记录到文本文件(会同时导出表头);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysq1-uroot -p --execute=&quot;SELECT * FROM emp;&quot; test&gt; &quot;c:/users/Maye/backup/emp_1.txt&quot;</span><br></pre></td></tr></table></figure>

<p>举例2:将test数据库emp表中的记录导出到文本文件，使用–veritcal参数将该条件记录分为多行显示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysq1 -uroot -p --vertical --execute=&quot;SELECT * FROM emp;&quot; test &gt; &quot;c:/Users/Maye/backup/emp_11.txt&quot;</span><br></pre></td></tr></table></figure>

<p>举例3:将test数据库emp表中的记录导出到xml，使用–xml参数将该条件记录分为多行显示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 mysq1 -uroot -p --xml --execute=&quot;SELECT * FROM emp;&quot; test &gt; &quot;c:/Users/Maye/backup/emp_11.txt&quot;</span><br><span class="line">导出html文件就是使用 --html参数</span><br></pre></td></tr></table></figure>

<h3 id="表的导入"><a href="#表的导入" class="headerlink" title="表的导入"></a>表的导入</h3><p>1.使用LOAD DATA INFILE方式导入文本文件</p>
<p>举例1:使用SELECT…INTO OUTFILE将test数据库中emp表的记录导出到文本文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test.emp INTO OUTFILE &#x27;C:/users/Maye/backup/emp_2.txt &#x27; ;</span><br></pre></td></tr></table></figure>

<p>删除account表中的数据:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM test.emp;</span><br></pre></td></tr></table></figure>

<p>从文本文件account.txt中恢复数据:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE &#x27;C:/Users/Maye/backup/emp_2.txt&#x27;INTO TABLE test.emp;</span><br></pre></td></tr></table></figure>

<p>举例2∶选择数据库test，使用SELECT….NTO OUTFILE将test数据库emp表中的记录导出到文本文件，使用FIELDS选项和LINES选项，要求字段之间使用逗号”，”间隔，所有字段值用双引号括起来:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 SELECT * FROM test.emp INTO OUTFILE &#x27;C:/Users/Maye/backup/emp_2.csV&#x27;FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>删除account表中的数据:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM test.emp;</span><br></pre></td></tr></table></figure>

<p>从’c:&#x2F;users&#x2F;Maye&#x2F;backup&#x2F;emp_2.csv’中导入数据到account表中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE &#x27;c:/Users/Maye/backup/emp_2.csv&#x27;INTO TABLE test.emp FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>2.使用mysqlimport方式导入文本文件</p>
<blockquote>
<p>文件名必须是表名</p>
</blockquote>
<p>举例:导出文件emp.txt，字段之间使用逗号”,”间隔，字符串字段值用双引号括起来:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 SELECT* FROMtest.emp INTO OUTFILE &#x27;C:/Users/Naye/backup/emp_3.csv&#x27;FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>删除emp表中的数据:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM test.emp;</span><br></pre></td></tr></table></figure>

<p>使用mysqlimport命令将emp.txt文件内容导入到数据库test的emp表中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysq1import -uroot -p --local test “c:/users/Maye/backup/emp_3.csv”--fields-terminated-by=，--fields-optiona1ly-enclosed-by=\&quot;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221111111829683.png" alt="image-20221111111829683">当出现问题的时候，上图有解决。</p>
<h2 id="c-c-操作数据库"><a href="#c-c-操作数据库" class="headerlink" title="c&#x2F;c++操作数据库"></a>c&#x2F;c++操作数据库</h2><p>首先需要初始化mysql</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种方式初始化</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">MYSQL *mysql=<span class="built_in">mysql_init</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">MYSQL mysql;</span><br><span class="line"><span class="built_in">mysql_init</span>(&amp;mysql);</span><br></pre></td></tr></table></figure>

<p>有初始化，就会有关闭mysql：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mysql_close</span>(mysql);</span><br></pre></td></tr></table></figure>

<p>在初始化和关闭数据库中间就可以使用数据库了</p>
<p>首先需要连接数据库：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接数据库</span></span><br><span class="line"><span class="built_in">mysql_real_connect</span>()<span class="comment">//-&gt;一般后面的两个参数填0或者NULL</span></span><br><span class="line"><span class="comment">//一般会确保是否连接上数据库了，所以:</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">mysql_real_connect</span>())</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">mysql_error</span>(mysql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;连接数据库成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置连接超时的时间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> time=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">mysql_options</span>();<span class="comment">//参数查文档</span></span><br></pre></td></tr></table></figure>

<p>在运行的时候可能会与数据库断开连接，如果想让他重连：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> re=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">mysql_options</span>();<span class="comment">//参数查文档-&gt;第二个参数是MYSQL_OPT_RECONNECT</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> mysql_options()函数在mysql_init之后，在mysql_real_connect之前！</p>
<p>在使用中可以用mysql_ping函数来测试是否与数据库连接！</p>
<p>执行SQL语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* sql=<span class="string">&quot;SQL语句&quot;</span>;<span class="comment">//SQL语句不用加;</span></span><br><span class="line"><span class="built_in">mysql_query</span>();<span class="comment">//执行数据库</span></span><br><span class="line"><span class="built_in">mysql_real_query</span>();<span class="comment">//这个比较安全</span></span><br></pre></td></tr></table></figure>

<p>获取执行完的SQL语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_RES* res=<span class="built_in">mysql_store_result</span>();<span class="comment">//会把结果集保存到本机</span></span><br><span class="line">MYSQL_RES* res=<span class="built_in">mysql_use_result</span>();<span class="comment">//不会把结果保存起来，而是一条一条的从服务器中读取</span></span><br></pre></td></tr></table></figure>

<p>无论是哪种获取，在用完之后都必须释放掉：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mysql_free_result</span>();<span class="comment">//释放掉的是MYSQL_RES数据类型的</span></span><br><span class="line"><span class="comment">//一定会释放成功的，没有返回类型 </span></span><br></pre></td></tr></table></figure>

<p>获得字段数量（就是列数）和获得每行记录，并输出：</p>
<blockquote>
<p>输出后发现汉字编码是错误的，所以在开始还需要配置一下</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置编码</span></span><br><span class="line"><span class="built_in">mysql_options</span>()<span class="comment">//-&gt;第二个参数是MYSQL_INIT_COMMAND -&gt;第三个参数是&quot;SET NAMES GBK&quot;-&gt;这是因为咱们电脑编码是GBK，也可以设置为其他编码</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20221111160024208.png" alt="image-20221111160024208"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得字段数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fi=<span class="built_in">mysql_field_count</span>(mysql);</span><br><span class="line"><span class="comment">//获得每条记录 MYSQL_ROW就是char**</span></span><br><span class="line">MYSQL_ROW row=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(row=<span class="built_in">mysql_fetch_row</span>(res))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fi;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//cout&lt;&lt;row[i]&lt;&lt;&quot;  &quot;;//当没有数据的时候输出的是（null）</span></span><br><span class="line">      <span class="comment">//为了改变，而且也安全所以可以改为：</span></span><br><span class="line">      cout&lt;&lt;row[i]?row[i]:<span class="string">&quot;NULL&quot;</span>&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取字段不仅仅可以在MYSQL类型的变量中获取，也可以在MYSQL_RES类型中获取：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fi = <span class="number">0</span>;</span><br><span class="line">fi=<span class="built_in">mysql_num_fields</span>(res);</span><br></pre></td></tr></table></figure>

<p>获取记录的条数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> rowC=<span class="built_in">mysql_num_rows</span>(res);</span><br></pre></td></tr></table></figure>

<p>获取每一个字段,并输出方法1：&#x2F;&#x2F;一个字段一个字段的抓取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_FIELD *fie=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(fie=<span class="built_in">mysql_fetch_field</span>(res))</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;fie-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取每一个字段,并输出方法2：&#x2F;&#x2F;把所有的字段先抓取出来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_FIELD *fie=<span class="literal">NULL</span>;</span><br><span class="line">fie=<span class="built_in">mysql_fetch_fields</span>(res);</span><br><span class="line"><span class="keyword">if</span>(fie)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fi;i++)</span><br><span class="line">  &#123;</span><br><span class="line">     cout&lt;&lt;fie[i].name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用这个方法有个好处就是，可以返回所有数据中最长的长度：fie[i].max_length。<br>用printf(“%-*s”,fie[i].max_length+1,fie[i].name);显示就很舒服</p>
</blockquote>
<p>获取每一个字段,并输出方法3：&#x2F;&#x2F;使用mysql_fetch_field_direct()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fi;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//如果有需要可以存起来，再输出</span></span><br><span class="line">   cout&lt;&lt;<span class="built_in">mysql_fetch_field_direct</span>(res,i)-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要执行多条SQL语句时，需要把mysql_real_connect()的最后一个参数改写为CLIENT_MULTI_STATEMENTS-&gt;意思是支持客服端多条代码段</p>
<p>虽然改完了但是输出的时候还是只输出一个字段，这个时候可以使用do while循环语句，循环条件是：mysql_next_result(mysql)-&gt;当没有语句执行后自动跳出</p>
<p>当执行的语句中不是结果集的语句，比如insert update等，可以输出他影响的行数，用函数：mysql_affected_rows()。</p>
<p>样例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//初始化MySQL</span></span><br><span class="line"> MYSQL* mysql = <span class="built_in">mysql_init</span>(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="comment">//设置字符集</span></span><br><span class="line"> <span class="built_in">mysql_options</span>(mysql, MYSQL_INIT_COMMAND, <span class="string">&quot;SET NAMES GBK&quot;</span>);</span><br><span class="line"> <span class="comment">//设置自动重连</span></span><br><span class="line"> <span class="type">bool</span> is = <span class="literal">true</span>;</span><br><span class="line"> <span class="built_in">mysql_options</span>(mysql, MYSQL_OPT_RECONNECT,&amp;is);</span><br><span class="line"> <span class="comment">//连接服务器</span></span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">mysql_real_connect</span>(mysql, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;ddl&quot;</span>, <span class="number">3306</span>, <span class="number">0</span>, CLIENT_MULTI_STATEMENTS))</span><br><span class="line"> &#123;</span><br><span class="line">   cout &lt;&lt; <span class="built_in">mysql_error</span>(mysql)&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;连接成功\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//断开连接后重连</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">mysql_ping</span>(mysql))</span><br><span class="line"> &#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;连接中&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获得数据</span></span><br><span class="line">  <span class="comment">//执行SQL语句</span></span><br><span class="line">  <span class="comment">//SQL语句不用加;,但是执行多条代码段的时候，两两语句中间需要;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* sql = <span class="string">&quot;SELECT * FROM student;SELECT * FROM teaches&quot;</span>;</span><br><span class="line">  <span class="comment">//执行数据库</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">mysql_query</span>(mysql, sql))</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mysql_query:&quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(mysql);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//把结果保存本机</span></span><br><span class="line">    MYSQL_RES* res = <span class="built_in">mysql_store_result</span>(mysql);</span><br><span class="line">    <span class="keyword">if</span> (!res)</span><br><span class="line">    &#123;     </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;mysql_store_result:&quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(mysql);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回字段有多少</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fi = <span class="number">0</span>;</span><br><span class="line">    fi = <span class="built_in">mysql_field_count</span>(mysql);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; fi &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示要输出多少数据</span></span><br><span class="line">    <span class="type">uint64_t</span> it = <span class="built_in">mysql_num_rows</span>(res);</span><br><span class="line">    cout &lt;&lt; it &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//显示字段</span></span><br><span class="line">    MYSQL_FIELD* fie = <span class="built_in">mysql_fetch_fields</span>(res);</span><br><span class="line">    <span class="keyword">if</span> (fie)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fi; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-*s&quot;</span>, fie[i].max_length + <span class="number">6</span>, fie[i].name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//把每一列都传出来</span></span><br><span class="line">    MYSQL_ROW row = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (row = <span class="built_in">mysql_fetch_row</span>(res))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fi; i++)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%-*s&quot;</span>, fie[i].max_length + <span class="number">6</span>, row[i] ? row[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//释放掉的是MYSQL_RES数据类型的</span></span><br><span class="line">     <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line"> &#125; <span class="keyword">while</span> (<span class="built_in">mysql_next_result</span>(mysql) == <span class="number">0</span>);</span><br><span class="line"> <span class="comment">//关闭数据库</span></span><br><span class="line"> <span class="built_in">mysql_close</span>(mysql);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/sql/" rel="tag"># sql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/79666db.html" rel="prev" title="数据结构">
      <i class="fa fa-chevron-left"></i> 数据结构
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/8a255ac6.html" rel="next" title="人脸识别基础">
      人脸识别基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MYSQL"><span class="nav-number">1.</span> <span class="nav-text">MYSQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.1.</span> <span class="nav-text">数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.</span> <span class="nav-text">数据库管理系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.</span> <span class="nav-text">数据库系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL"><span class="nav-number">1.4.</span> <span class="nav-text">SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">1.5.</span> <span class="nav-text">SQL的组成部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E8%A7%84%E8%8C%83"><span class="nav-number">1.6.</span> <span class="nav-text">SQL语句规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.</span> <span class="nav-text">数据库的基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.8.</span> <span class="nav-text">数据库的基本查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5"><span class="nav-number">1.8.1.</span> <span class="nav-text">查询多个字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.8.2.</span> <span class="nav-text">条件查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.8.3.</span> <span class="nav-text">聚合查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.8.4.</span> <span class="nav-text">分组查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">主意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.8.5.</span> <span class="nav-text">排序查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F"><span class="nav-number">1.8.5.1.</span> <span class="nav-text">语法注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">1.8.5.2.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.8.6.</span> <span class="nav-text">分页查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E7%89%B9%E7%82%B9"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">语句特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.</span> <span class="nav-text">数据库的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.1.</span> <span class="nav-text">字符串函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.2.</span> <span class="nav-text">数值函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.3.</span> <span class="nav-text">时间日期函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.4.</span> <span class="nav-text">条件判断函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.5.</span> <span class="nav-text">其他函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">系统信息函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.5.2.</span> <span class="nav-text">加密函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.5.3.</span> <span class="nav-text">其他的函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.10.</span> <span class="nav-text">多表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5vs%E4%B8%8D%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.10.1.</span> <span class="nav-text">等值连接vs不等值连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.10.2.</span> <span class="nav-text">内连接和外连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E7%A7%8DJOIN%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.10.3.</span> <span class="nav-text">七种JOIN实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B9%B6%E9%9B%86%E8%BF%90%E7%AE%97"><span class="nav-number">1.10.4.</span> <span class="nav-text">自连接与并集运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.11.</span> <span class="nav-text">子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%A6%82%E5%BF%B5"><span class="nav-number">1.11.1.</span> <span class="nav-text">子查询概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%A7%84%E8%8C%83"><span class="nav-number">1.11.2.</span> <span class="nav-text">查询规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E9%87%8F%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.11.3.</span> <span class="nav-text">标量子查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.11.4.</span> <span class="nav-text">单行子查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%A4%9A%E8%A1%8C%E6%9F%A5%E8%AF%A2%EF%BC%89"><span class="nav-number">1.11.5.</span> <span class="nav-text">列子查询（多行查询）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.11.6.</span> <span class="nav-text">表子查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SELECT%E5%AD%90%E5%8F%A5%E4%B8%AD%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.11.7.</span> <span class="nav-text">SELECT子句中子查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.11.8.</span> <span class="nav-text">相关子查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WITH%E5%92%8CEXISTX%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.11.9.</span> <span class="nav-text">WITH和EXISTX语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="nav-number">1.12.</span> <span class="nav-text">数据管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">1.12.1.</span> <span class="nav-text">插入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="nav-number">1.12.2.</span> <span class="nav-text">修改数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">1.12.3.</span> <span class="nav-text">删除数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.13.</span> <span class="nav-text">表管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.13.1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">表的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">1.13.1.2.</span> <span class="nav-text">标识符命名规范</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.13.2.</span> <span class="nav-text">创建数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.13.3.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">1.13.4.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8"><span class="nav-number">1.13.5.</span> <span class="nav-text">修改表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.14.</span> <span class="nav-text">约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E6%A6%82%E5%BF%B5"><span class="nav-number">1.14.1.</span> <span class="nav-text">约束概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.14.1.1.</span> <span class="nav-text">为什么需要约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.14.1.2.</span> <span class="nav-text">什么是约束</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.14.2.</span> <span class="nav-text">约束的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.14.2.1.</span> <span class="nav-text">非空约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.14.2.2.</span> <span class="nav-text">唯一约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.14.2.3.</span> <span class="nav-text">主键约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E9%95%BF%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.14.2.4.</span> <span class="nav-text">自增长约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%BA%A6%E6%9D%9F%EF%BC%88check%EF%BC%89"><span class="nav-number">1.14.2.5.</span> <span class="nav-text">检查约束（check）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%BA%A6%E6%9D%9F%EF%BC%88DEFAULT%EF%BC%89"><span class="nav-number">1.14.2.6.</span> <span class="nav-text">默认值约束（DEFAULT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.14.2.7.</span> <span class="nav-text">外键约束</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.14.2.7.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E7%89%B9%E7%82%B9"><span class="nav-number">1.14.2.7.2.</span> <span class="nav-text">其特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.14.2.7.3.</span> <span class="nav-text">添加外键约束</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C"><span class="nav-number">1.14.2.7.4.</span> <span class="nav-text">级联操作</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.15.</span> <span class="nav-text">SQL数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.15.1.</span> <span class="nav-text">整数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.15.2.</span> <span class="nav-text">浮点类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.15.3.</span> <span class="nav-text">定点类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.15.4.</span> <span class="nav-text">二进制类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.15.5.</span> <span class="nav-text">日期&#x2F;时间类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.15.6.</span> <span class="nav-text">字符串类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-number">1.16.</span> <span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E8%AF%AD%E6%B3%95"><span class="nav-number">1.16.1.</span> <span class="nav-text">视图语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE%E6%95%B0%E6%8D%AE"><span class="nav-number">1.16.2.</span> <span class="nav-text">更新视图数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="nav-number">1.16.2.1.</span> <span class="nav-text">不可更新视图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9"><span class="nav-number">1.16.3.</span> <span class="nav-text">视图的删除与修改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="nav-number">1.16.3.1.</span> <span class="nav-text">删除视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%A7%86%E5%9B%BE"><span class="nav-number">1.16.3.2.</span> <span class="nav-text">修改视图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-number">1.17.</span> <span class="nav-text">存储过程和函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.17.1.</span> <span class="nav-text">存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="nav-number">1.17.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%BD%E5%A4%84"><span class="nav-number">1.17.1.2.</span> <span class="nav-text">好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">1.17.1.3.</span> <span class="nav-text">语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB"><span class="nav-number">1.17.1.3.1.</span> <span class="nav-text">参数分类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="nav-number">1.17.2.</span> <span class="nav-text">存储函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">1.17.3.</span> <span class="nav-text">语法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.17.4.</span> <span class="nav-text">对比存储函数和存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%A5%E7%9C%8B%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E5%88%A0%E9%99%A4"><span class="nav-number">1.17.5.</span> <span class="nav-text">存储过程和函数的查看、修改、删除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B"><span class="nav-number">1.17.5.1.</span> <span class="nav-text">查看</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9"><span class="nav-number">1.17.5.2.</span> <span class="nav-text">修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">1.17.5.3.</span> <span class="nav-text">删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E3%80%81%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E6%B8%B8%E6%A0%87"><span class="nav-number">1.18.</span> <span class="nav-text">变量、分支结构、循环结构以及游标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.18.1.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="nav-number">1.18.1.1.</span> <span class="nav-text">系统变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB"><span class="nav-number">1.18.1.1.1.</span> <span class="nav-text">系统变量分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="nav-number">1.18.1.1.2.</span> <span class="nav-text">查看系统变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9AMySQL-8-0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.18.1.1.3.</span> <span class="nav-text">补充：MySQL 8.0的新特性——全局变量的持久化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="nav-number">1.18.1.2.</span> <span class="nav-text">用户变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB"><span class="nav-number">1.18.1.2.1.</span> <span class="nav-text">用户变量分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="nav-number">1.18.1.2.2.</span> <span class="nav-text">会话用户变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.18.1.2.3.</span> <span class="nav-text">局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="nav-number">1.18.1.2.3.1.</span> <span class="nav-text">定义变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"><span class="nav-number">1.18.1.2.3.2.</span> <span class="nav-text">变量赋值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.18.1.2.3.3.</span> <span class="nav-text">使用变量</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%AF%B9%E6%AF%94"><span class="nav-number">1.18.1.2.4.</span> <span class="nav-text">会话用户变量与局部变量对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">1.18.2.</span> <span class="nav-text">异常处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.18.2.0.1.</span> <span class="nav-text">案例分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.18.2.1.</span> <span class="nav-text">定义条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.18.2.2.</span> <span class="nav-text">定义处理程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E8%A7%A3%E5%86%B3"><span class="nav-number">1.18.2.3.</span> <span class="nav-text">案例解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.18.3.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E4%B9%8B-IF"><span class="nav-number">1.18.3.1.</span> <span class="nav-text">分支结构之 IF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E4%B9%8B-CASE"><span class="nav-number">1.18.3.2.</span> <span class="nav-text">分支结构之 CASE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8B-LOOP"><span class="nav-number">1.18.3.3.</span> <span class="nav-text">循环结构之 LOOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8B-WHILE"><span class="nav-number">1.18.3.4.</span> <span class="nav-text">循环结构之 WHILE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8B-REPEAT"><span class="nav-number">1.18.3.5.</span> <span class="nav-text">循环结构之 REPEAT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5%E4%B9%8B-LEAVE%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.18.3.6.</span> <span class="nav-text">跳转语句之 LEAVE语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5%E4%B9%8B-ITERATE-%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.18.3.7.</span> <span class="nav-text">跳转语句之 ITERATE 语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87"><span class="nav-number">1.18.4.</span> <span class="nav-text">游标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87%EF%BC%88%E6%88%96%E5%85%89%E6%A0%87%EF%BC%89"><span class="nav-number">1.18.4.1.</span> <span class="nav-text">什么是游标（或光标）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.18.4.2.</span> <span class="nav-text">使用游标步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.18.4.3.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.18.4.4.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">1.19.</span> <span class="nav-text">触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.19.1.</span> <span class="nav-text">触发器的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OLD%E5%92%8CNEW"><span class="nav-number">1.19.2.</span> <span class="nav-text">OLD和NEW</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E3%80%81%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">1.19.3.</span> <span class="nav-text">查看、删除触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.19.4.</span> <span class="nav-text">触发器的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-number">1.20.</span> <span class="nav-text">用户与权限管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BB%E5%BD%95MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.20.1.</span> <span class="nav-text">登录MySQL服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7"><span class="nav-number">1.20.2.</span> <span class="nav-text">创建用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="nav-number">1.20.3.</span> <span class="nav-text">删除用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81"><span class="nav-number">1.20.4.</span> <span class="nav-text">修改用户名和密码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">1.20.5.</span> <span class="nav-text">密码的管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E9%87%8D%E7%94%A8%E7%AD%96%E7%95%A5"><span class="nav-number">1.20.6.</span> <span class="nav-text">密码重用策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-number">1.20.7.</span> <span class="nav-text">权限管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B6%E5%9B%9E%E6%9D%83%E9%99%90"><span class="nav-number">1.20.8.</span> <span class="nav-text">收回权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E8%A1%A8"><span class="nav-number">1.20.9.</span> <span class="nav-text">权限表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#user%E8%A1%A8"><span class="nav-number">1.20.9.1.</span> <span class="nav-text">user表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%88%97"><span class="nav-number">1.20.9.1.1.</span> <span class="nav-text">用户列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E5%88%97"><span class="nav-number">1.20.9.2.</span> <span class="nav-text">权限列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%88%97"><span class="nav-number">1.20.9.3.</span> <span class="nav-text">安全列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%E5%88%97"><span class="nav-number">1.20.9.4.</span> <span class="nav-text">资源控制列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#db%E8%A1%A8"><span class="nav-number">1.20.10.</span> <span class="nav-text">db表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%88%97-1"><span class="nav-number">1.20.10.1.</span> <span class="nav-text">用户列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E5%88%97-1"><span class="nav-number">1.20.10.2.</span> <span class="nav-text">权限列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tables-priv%E8%A1%A8%E5%92%8Ccolumns-priv%E8%A1%A8"><span class="nav-number">1.20.10.3.</span> <span class="nav-text">tables_priv表和columns_priv表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#procs-priv%E8%A1%A8"><span class="nav-number">1.20.10.4.</span> <span class="nav-text">procs_priv表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%89"><span class="nav-number">1.20.11.</span> <span class="nav-text">访问控制（了解一下）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%A0%B8%E5%AE%9E%E9%98%B6%E6%AE%B5"><span class="nav-number">1.20.11.1.</span> <span class="nav-text">连接核实阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%A0%B8%E5%AE%9E%E9%98%B6%E6%AE%B5"><span class="nav-number">1.20.11.2.</span> <span class="nav-text">请求核实阶段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%92%E8%89%B2%E7%AE%A1%E7%90%86"><span class="nav-number">1.20.12.</span> <span class="nav-text">角色管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%92%E8%89%B2%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.20.12.1.</span> <span class="nav-text">角色的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2"><span class="nav-number">1.20.12.2.</span> <span class="nav-text">创建角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E8%A7%92%E8%89%B2%E8%B5%8B%E4%BA%88%E6%9D%83%E9%99%90"><span class="nav-number">1.20.12.3.</span> <span class="nav-text">给角色赋予权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90"><span class="nav-number">1.20.12.4.</span> <span class="nav-text">查看角色的权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90"><span class="nav-number">1.20.12.5.</span> <span class="nav-text">回收角色的权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A7%92%E8%89%B2"><span class="nav-number">1.20.12.6.</span> <span class="nav-text">删除角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E7%94%A8%E6%88%B7%E8%B5%8B%E4%BA%88%E8%A7%92%E8%89%B2"><span class="nav-number">1.20.12.7.</span> <span class="nav-text">给用户赋予角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BF%80%E6%B4%BB%E8%A7%92%E8%89%B2"><span class="nav-number">1.20.12.8.</span> <span class="nav-text">激活角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%A4%E9%94%80%E7%94%A8%E6%88%B7%E7%9A%84%E8%A7%92%E8%89%B2"><span class="nav-number">1.20.12.9.</span> <span class="nav-text">撤销用户的角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%BC%BA%E5%88%B6%E8%A7%92%E8%89%B2-mandatory-role"><span class="nav-number">1.20.12.10.</span> <span class="nav-text">设置强制角色(mandatory role)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.21.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">1.21.1.</span> <span class="nav-text">数据库事务概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.21.2.</span> <span class="nav-text">如何使用事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.21.2.1.</span> <span class="nav-text">显式事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.21.2.2.</span> <span class="nav-text">隐式事务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">1.21.3.</span> <span class="nav-text">隐式提交数据的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.21.4.</span> <span class="nav-text">事务隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.21.4.1.</span> <span class="nav-text">数据并发问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%84%8F%E5%86%99-Dirty-Write"><span class="nav-number">1.21.4.2.</span> <span class="nav-text">1.脏写(Dirty Write )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%84%8F%E8%AF%BB-Dirty-Read"><span class="nav-number">1.21.4.3.</span> <span class="nav-text">2.脏读(Dirty Read )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-Non-Repeatable-Read"><span class="nav-number">1.21.4.4.</span> <span class="nav-text">3.不可重复读(Non-Repeatable Read )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%B9%BB%E8%AF%BB-Phantom"><span class="nav-number">1.21.4.5.</span> <span class="nav-text">4.幻读(Phantom )</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.21.5.</span> <span class="nav-text">SQL中的四种隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8BMySQL%E5%BD%93%E5%89%8D%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.21.6.</span> <span class="nav-text">查看MySQL当前的隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEMySQL%E5%BD%93%E5%89%8D%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.21.7.</span> <span class="nav-text">设置MySQL当前的隔离级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">1.22.</span> <span class="nav-text">数据库备份与恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD%E4%B8%8E%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD"><span class="nav-number">1.22.1.</span> <span class="nav-text">物理备份与逻辑备份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysqldump%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD"><span class="nav-number">1.22.2.</span> <span class="nav-text">mysqldump命令实现逻辑备份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E5%91%BD%E4%BB%A4%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="nav-number">1.22.3.</span> <span class="nav-text">MySQL命令恢复数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%9A%84%E5%AF%BC%E5%87%BA"><span class="nav-number">1.22.4.</span> <span class="nav-text">表的导出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8mysqldump%E5%91%BD%E4%BB%A4%E5%AF%BC%E5%87%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">1.22.4.1.</span> <span class="nav-text">使用mysqldump命令导出文本文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8mysql%E5%91%BD%E4%BB%A4%E5%AF%BC%E5%87%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">1.22.4.2.</span> <span class="nav-text">使用mysql命令导出文本文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="nav-number">1.22.5.</span> <span class="nav-text">表的导入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-c-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.23.</span> <span class="nav-text">c&#x2F;c++操作数据库</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wxy"
      src="/images/%E5%A4%B4%E5%83%8F.jpg">
  <p class="site-author-name" itemprop="name">Wxy</p>
  <div class="site-description" itemprop="description">故事开始于2025/2/24 15：47</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    
      <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
      <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
      <div class="widget-wrap">
          <h3 class="widget-title">Tag Cloud</h3>
          <div id="myCanvasContainer" class="widget tagcloud">
              <canvas width="250" height="250" id="resCanvas" style="width=100%">
                  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/" rel="tag">cpp</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E7%A8%8B/" rel="tag">教程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/" rel="tag">日常生活</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" rel="tag">计算机视觉</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">1</span></li></ul>
              </canvas>
          </div>
      </div>
    

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wxy</span>
</div>
  <div class="powered-by">
  </div><script color="255,255,255" opacity="0.5" zIndex="-1" count="150" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>
<script type="text/javascript" src="/js/click_love.js"></script>


        








      </div>
    </footer>
  </div>

  <!-- 引入jQuery -->
  <script type="text/javascript" src="//libs.baidu.com/jquery/1.8.3/jquery.min.js"></script>

  <!-- 雪花特效2 -->
  <script type="text/javascript" src="/js/snow2.js"></script>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
