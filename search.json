[{"title":"c++14版本更新","url":"/posts/c2e95af0.html","content":"c++14版本特性变量模板变量模板可以认为是一种不确定的变量，就是泛型变量。\n语法：\ntemplate &lt; 形参列表 &gt; 变量声明// 举例template&lt;typename T&gt;const T pi = T(3.1415926535897932385L);\n\n在c++14之前只有模板函数和模板类，没有变量模板。\n变量声明：变量的声明。声明的变量名成为模板名。形参列表：非空的模板形参的逗号分隔列表，每项是非类型形参、类型形参、模板形参，或任何上述的形参包之一。\n\n介绍一下非类型形参、类型形参、模板形参是什么？非类型形参：就是普通的形参，比如 template 在写变量的时候就可以在&lt;&gt;中写一个int类型的变量。(T纯右值不可改，在编译期间就确定了，除非T是左值引用类型)类型形参：就是模板形参，比如 template 在写变量的时候就可以在&lt;&gt;中写一个类型变量。模板形参：就是模板形参，比如 template&lt;template class T&gt; 在写变量的时候就可以在&lt;&gt;中写一个模板变量。模板实参：就是模板实参，比如 template 在写变量的时候就可以在&lt;&gt;中写一个具体的类型，可以是类等自定义的类型。\n\n官方文档提供的几种案例：\n// 1. 基础使用template&lt;class T&gt;constexpr T pi = T(3.1415926535897932385L); // 变量模板 template&lt;class T&gt;T circular_area(T r) // 函数模板&#123;    return pi&lt;T&gt; * r * r; // pi&lt;T&gt; 是变量模板实例化&#125;//2.在类作用域中使用时，变量模板声明一个静态数据成员模板。using namespace std::literals;struct matrix_constants&#123;    template&lt;class T&gt;    using pauli = hermitian_matrix&lt;T, 2&gt;; // 别名模版     template&lt;class T&gt; // 静态数据成员模板    static constexpr pauli&lt;T&gt; sigmaX = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;&#125;;     template&lt;class T&gt;    static constexpr pauli&lt;T&gt; sigmaY = &#123;&#123;0, -1i&#125;, &#123;1i, 0&#125;&#125;;     template&lt;class T&gt;    static constexpr pauli&lt;T&gt; sigmaZ = &#123;&#123;1, 0&#125;, &#123;0, -1&#125;&#125;;&#125;;// 3.与其他静态成员一样，静态数据成员模板的需要一个定义。这种定义可以在类定义外提供。处于命名空间作用域的静态数据成员的模板声明也可以是类模板的非模板数据成员的定义：struct limits&#123;    template&lt;typename T&gt;    static const T min; // 静态数据成员模板的声明&#125;; template&lt;typename T&gt;const T limits::min = &#123;&#125;; // 静态数据成员模板的定义 template&lt;class T&gt;class X&#123;    static T s; // 类模板的非模板静态数据成员的声明&#125;; template&lt;class T&gt;T X&lt;T&gt;::s = 0; // 类模板的非模板静态数据成员的定义\n\n泛型 lambda泛型lambda表达式可以在其形参列表中使用 auto 或 decltype(auto) 来表示其形参的类型。 拓展了c++11的lambda表达式的使用范围。\n语法样例：\nauto genericLambda = [](auto a, auto b) &#123;    return a + b;&#125;;int intResult = genericLambda(5, 10); // OK: int + intdouble doubleResult = genericLambda(5.5, 10.2); // OK: double + double// 实际上编译器眼中的泛型lambda表达式是这样的：class SomeCompilerGeneratedClassName &#123;public:    template&lt;typename T, typename U&gt;    auto operator()(T t, U u) const &#123;        return t + u;    &#125;&#125;;// 官方提供的样例// 泛型 lambda，operator() 是有两个形参的模板auto glambda = [](auto a, auto&amp;&amp; b) &#123; return a &lt; b; &#125;;bool b = glambda(3, 3.14); // ok // 泛型 lambda，operator() 是有一个形参的模板auto vglambda = [](auto printer)&#123;    return [=](auto&amp;&amp;... ts) // 泛型 lambda，ts 是形参包    &#123;         printer(std::forward&lt;decltype(ts)&gt;(ts)...);        // 零元 lambda （不接受形参）        return [=] &#123; printer(ts...); &#125;;    &#125;;&#125;; auto p = vglambda([](auto v1, auto v2, auto v3)&#123;    std::cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3;&#125;); auto q = p(1, &#x27;a&#x27;, 3.14); // 输出 1a3.14q();                      // 输出 1a3.14\n\n\n注意：泛型lambda表达式允许在捕获列表中初始化新变量，支持移动捕获和表达式初始化。\n\nlambda 初始化捕获lambda表达式允许在捕获列表中初始化新变量。这个特性允许你在lambda表达式内部通过任意的表达式来初始化被捕获的变量。\n语法：\n[captured_var = init_expression] (parameters) -&gt; return_type &#123;    // lambda body&#125;\n\n使用样例：\n// 基本用法int x = 5;auto lambda = [val = x + 10]() &#123;     std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; val &lt;&lt; std::endl; &#125;;lambda(); // 输出: Value: 15// 智能指针的捕获int* p = new int(10);auto lambda = [ptr = std::unique_ptr&lt;int&gt;(p)]() &#123;     if(ptr) std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; &#125;;lambda(); // 输出: Value: 10// 改变捕获变量的类型int x = 5;auto lambda = [num = static_cast&lt;double&gt;(x)]() mutable &#123;     std::cout &lt;&lt; &quot;Double value: &quot; &lt;&lt; num &lt;&lt; std::endl; &#125;;lambda(); // 输出: Double value: 5.0\n\nnew&#x2F;delete 消除这个特性英文是：new&#x2F;delete elision。\n这个特性的意思是：在某些情况下，编译器可以在不调用 new 或 delete 运算符的情况下分配和释放内存。\n因为对这个描述比较少，我们可以理解为，编译器对于new和delete的调用进行了优化。\n在以下情况下，编译器可以体现new&#x2F;delete的省略：\n\nNRVO (Named Return Value Optimization) 和 RVO (Return Value Optimization)：这些优化允许编译器在函数返回局部对象时省略拷贝或移动操作。如果编译器能够确定对象的生命期并进行优化，则可能避免额外的构造、拷贝和析构操作，这间接减少了潜在的new&#x2F;delete调用。\n移动语义：C++11引入了移动语义，允许资源从临时对象高效转移而不是复制。当一个对象被移动而不是被复制时，通常不需要分配新的内存，这减少了new操作的需求，并且通过释放旧的对象来减少delete操作。\n自动存储持续时间 vs 动态存储持续时间：尽量使用栈上的变量（具有自动存储持续时间），而不是堆上的动态分配（具有动态存储持续时间）。栈分配更快，且不需要手动管理内存（即显式的new和delete）。\n智能指针：使用如std::unique_ptr和std::shared_ptr等智能指针代替裸指针，可以帮助自动管理内存，减少手动调用new和delete的机会，并允许编译器更好地优化代码。\n\nconstexpr 函数上放松的限制在C++14中，constexpr函数得到了显著的放松和增强，使其更加灵活和实用。根据你提供的来源，以下是C++14对constexpr函数放松的主要限制：\n\n允许更多的复杂操作：在C++11中，constexpr函数被严格限制为只能包含一个返回语句。C++14放宽了这一限制，允许constexpr函数包含更复杂的控制流，包括循环（如while、for）和局部变量的声明。\n非const成员函数可以是constexpr：C++14允许非const成员函数也可以声明为constexpr。这意味着你可以定义修改对象状态的constexpr成员函数，只要这些修改可以在编译期完成。\n支持局部变量：constexpr函数现在可以包含局部变量的声明和使用，这增加了函数内部逻辑组织的灵活性。\n不再强制所有声明都必须有constexpr说明符：对于constexpr变量模板的所有声明来说，在C++14之前需要在每个声明处都加上constexpr说明符。C++14之后，不再要求这样做，提高了代码的可维护性。\n\n示例代码：\n// C++14 constexpr 函数可以包含局部变量和循环constexpr int factorial_cxx14(int n) &#123;    int res = 1; // 局部变量    while (n &gt; 1) &#123; // 循环        res *= n--;    &#125;    return res;&#125;class MyClass &#123;public:    // 非 const 成员函数可以是 constexpr    constexpr void multiplyByTwo() &#123;        value *= 2;    &#125;private:    int value;&#125;;int main() &#123;    constexpr int result = factorial_cxx14(5); // 可以在编译期计算    static_assert(result == 120, &quot;factorial calculation failed&quot;);&#125;\n\n二进制字面量与数位分隔符在c++14之前，整数字面量只有十进制、八进制和十六进制。14之后，增加了二进制字面量。\n二进制字面量的语法：要定义一个二进制字面量，你需要以0b或0B开头，后面跟随一个或多个二进制数字（0或1）。\nint binNumber = 0b101010; // 等价于十进制的42int binNumberUpper = 0B101010; // 同样等价于十进制的42\n\n其他相关特性:除了直接支持二进制字面量外，C++14还允许在长整型字面量中使用二进制格式，并可以添加整数后缀来指定类型。\n例如：\n0b101u //表示无符号整数。0b101L //表示长整数。0b101LL //表示长长整数。int largeBinNumber = 0b1&#x27;0101&#x27;0101; // 分隔符的使用\n\n此外，C++14还引入了单引号作为分隔符的功能，可以在较长的字面量中使用，以提高可读性。不过，这一功能主要针对视觉上的改善，并不影响字面量的实际值。\n函数的返回类型推导在c++11中auto作为函数的返回类型是一个占位符，必须要有尾随返回类型，但是在c++14中，auto可以作为函数的返回类型可以不写尾随返回类型，使代码变得更加简洁。\n\n使用auto进行返回类型推导C++14允许使用auto作为函数的返回类型，编译器会根据函数体内的返回语句自动推导出实际的返回类型。这使得编写模板和泛型代码变得更加简洁。\ndecltype(auto)除了直接使用auto，C++14还引入了decltype(auto)，它允许根据返回表达式的精确类型来推导返回类型，而不是根据值类别进行调整。这对于返回引用或指针时特别有用。\n\n//使用auto时，返回类型基于值类别被调整：auto f() &#123; return 3.14f; &#125; // 返回类型是 float//使用decltype(auto)时，返回类型基于表达式的声明类型：const int a = 10;decltype(auto) g() &#123; return a; &#125; // 返回类型是 const int&amp;\n\n\n尾随返回类型的改进虽然尾随返回类型（trailing return type）在C++11中就已经存在，但在C++14中与auto结合使用变得更加灵活和强大。例如，可以轻松地定义复杂的返回类型：\n\ntemplate&lt;typename T, typename U&gt;auto add(T t, U u) -&gt; decltype(t + u); // C++11风格// 在C++14中可以直接写成：template&lt;typename T, typename U&gt;auto add(T t, U u) &#123; return t + u; &#125;\n\n\n单返回语句的简单推导如果一个函数只有一条返回语句，并且这条语句的表达式类型可以明确推导出来，那么编译器可以根据这个表达式直接推导出函数的返回类型。这种情况下不需要显式指定返回类型。\n\nauto square(int x) &#123; return x * x; &#125; // 返回类型自动推导为 int\n\n带默认成员初始化器的聚合类。在C++标准中聚合类的定义，聚合类是指满足以下条件的类：\n\n没有私有或受保护的非静态数据成员。\n没有用户声明的构造函数（即没有自定义的构造函数）。\n没有虚函数。\n没有基类。\n没有虚基类。\n\n在C++14之前，聚合类不允许为成员变量提供默认初始化器。例如，下面的代码在C++11中是非法的：\nstruct Point &#123;    int x = 0; // 默认成员初始化器，在C++11中非法    int y = 0; // 默认成员初始化器，在C++11中非法&#125;;\n\nC++14放松了这个限制，允许聚合类拥有默认成员初始化器。这意味着你可以为聚合类的成员变量指定默认值，这些默认值会在对象被默认初始化时使用。例如：\nstruct Point &#123;    int x = 0; // 默认成员初始化器    int y = 0; // 默认成员初始化器&#125;;\n\n\n这个特性看编译器是否支持，比如clion用cmake构建项目，声明的是c++11版本也支持这个特性。\n\n注意事项\n\n初始化顺序：如果使用列表初始化，成员变量会按照它们在类中声明的顺序进行初始化，而不是按照初始化列表中的顺序。\n兼容性：虽然可以为聚合类的成员提供默认初始化器，但这并不意味着聚合类的行为完全等同于带有构造函数的类。聚合类仍然不能有用户定义的构造函数、虚函数或基类。\n混合初始化：如果你部分提供了初始化值，未提供的成员将会使用默认初始化器。例如：\n\n","tags":["cpp"]},{"title":"人脸识别基础","url":"/posts/8a255ac6.html","content":"人脸识别demo函数介绍以下介绍的都是opencv提供给python的函数。\n1. 加载图片cv2.imread(filename,flags)\n\n\nfilename：图片的路径\nflags：加载图片的方式\ncv2.IMREAD_COLOR：默认参数，加载彩色图片，这个是彩色图片加载最常用的参数\ncv2.IMREAD_GRAYSCALE：以灰度模式加载图片\n\n\n返回值：返回img对象\n\n2. 显示图片cv2.imshow(winname,mat)\n\n\nwinname：显示图片的窗口名称\nmat：要显示的图片\n\n3. 保存图片cv2.imwrite(filename,img[,params])\n\n\nfilename：保存的文件名\nimg：要保存的图片\nparams：特定格式保存的参数编码，一般不用管。\n\n4. 等待键盘输入cv2.waitKey(delay)\n\n\ndelay：延迟多少毫秒，当delay&lt;&#x3D;0时，会永远等待下去\n返回值：返回值是当前键盘按键的值\n\n5. 销毁所有窗口cv2.destroyAllWindows()\n\n6. 图片剪裁cv2.resize(src,dsize[,dst[,fx[,fy[,interpolation]]]])\n\n\nsrc：输入，原图像，即待改变大小的图像\ndsize：输出，目标图像大小。\n如果这个参数不为0，那么就代表将原图像缩放到这个Size(width，height)指定的大小；\n如果这个参数为0，那么原图像缩放之后的大小就要通过下面的公式来计算：dsize&#x3D;Size(round(fxsrc.cols),round(fysrc.rows))  \n其中，fx和fy就是下面要说的两个参数，是图像width方向和height方向的缩放比例。\nfx：width方向的缩放比例\nfy：height方向的缩放比例\n\n\ninterpolation：这个参数是指定插值的方式，图像缩放之后，肯定像素要进行重新计算的，就靠这个参数来指定重新计算像素的方式，有以下几种：\nINTER_NEAREST - 最近邻插值\nINTER_LINEAR - 双线性插值（默认设置）\n\n\n\n\n返回值：返回改变大小之后的图像\n\n7. 图片灰度化cv2.cvtColor(src,code[,dst[,dstCn]])\n\n\nsrc：输入图像\ncode：颜色空间转换代码或标志\ncv2.COLOR_BGR2GRAY：BGR转灰度图\ncv2.COLOR_BGR2HSV：BGR转HSV\n\n\ndst：输出图像\ndstCn：目标图像中的通道数\n返回值：返回转换后的图像\n\n8. 加载训练数据cv2.CascadeClassifier(filename)\n\n\nfilename：训练数据的路径\n返回值：返回训练数据对象\n\n9. 加载过滤器detect.detectMultiScale(src)\n\n\nsrc：灰度图\n返回值：返回人脸的位置\n\n10. 绘制矩形cv2.rectangle(img,pt1,pt2,color[,thickness[,lineType[,shift]]])\n\n\nimg：要绘制的图片\npt1：矩形的顶点\npt2：矩形的顶点\ncolor：矩形的颜色\nthickness：矩形边框线的粗细（如果为负值如CV_FILLED），负数值如CV_FILLED表示填充矩形\nlineType：线条的类型。见line\nshift：坐标点的小数点位数\n\n11. 加载视频cv2.VideoCapture(filename)\n\n\nfilename：视频的路径\n如果是数字，代表打开摄像头\n\n\n返回值：返回视频对象\n\n12. 判断视频是否打开cap.isOpened()\n\n\n返回值：返回True或者False\n\n13. 读取视频cap.read()\n\n\n返回值：返回读取到的视频帧和是否读取成功的标志\n\n14. 释放视频资源cap.release()\n\n15. 创建局部二值模式直方图cv2.face.LBPHFaceRecognizer_create()\n\n\n返回值：返回LBPHFaceRecognizer对象\n\n16. 识别人脸recognizer.predict(gray[y:y+h,x:x+w])\n\n\ngray[y:y+h,x:x+w]：人脸图像\n返回值：返回预测的id和置信度\n\n17. 图像上添加文本cv2.putText(img,text,org,fontFace,fontScale,color[,thickness[,lineType[,bottomLeftOrigin]]])\n\n\nimg：待绘制的图像\ntext：文本字符串\norg：文本框的左下角\nfontFace：字体\nfontScale：字体大小\ncolor：字体颜色\nthickness：线条的粗细\nlineType：线型\nbottomLeftOrigin：当此参数为true时，图像的数据原点位于左下角。否则，它位于左上角。\n返回值：返回绘制了文字的图像\n\n18. 绘制圆形cv2.circle(img,center,radius,color[,thickness[,lineType[,shift]]])\n\n\nimg：待绘制的图像\ncenter：圆心坐标\nradius：圆的半径\ncolor：圆的颜色\nthickness：线条的粗细\nlineType：线型\nshift：坐标点的小数点位数\n返回值：返回绘制了圆形的图像\n\n\n其他图像参数类似\n\n流程介绍1. 训练数据流程：\n\n准备人脸照片的路径\n获取人脸特征和对应id\n获取图片路径列表\n加载人脸检测器\n遍历图片列表\n打开图片并转换为灰度图像\n检测人脸\n提取id\n保存人脸特征和id\n\n\n\n\n创建人脸识别器并训练\n保存训练结果\n\nimport osimport cv2from PIL import Imageimport numpy as npdef getImageAndLabels(path):    facesSamples=[]    ids=[]    imagePaths=[os.path.join(path,f) for f in os.listdir(path)]    # 检测人脸    face_detector = cv2.CascadeClassifier(&#x27;D:/programming/libs/opencv/opencv/sources/data/haarcascades/haarcascade_frontalface_alt2.xml&#x27;)    # 打印数组imagePaths    print(&#x27;数据排列：&#x27;,imagePaths)    # 遍历列表中的图片    for imagePath in imagePaths:        # 打开图片,黑白化        PIL_img=Image.open(imagePath).convert(&#x27;L&#x27;)        img_numpy=np.array(PIL_img,&#x27;uint8&#x27;)        # 获取图片人脸特征        faces = face_detector.detectMultiScale(img_numpy)        # 获取每张图片的id和姓名        id = int(os.path.split(imagePath)[1].split(&#x27;.&#x27;)[0])        # 预防无面容照片        for x,y,w,h in faces:            ids.append(id)            facesSamples.append(img_numpy[y:y+h,x:x+w])        # 打印id        print(&#x27;id:&#x27;, id)    print(&#x27;fs:&#x27;, facesSamples)    return facesSamples,idsif __name__ == &#x27;__main__&#x27;:    # 图片路径    path=&#x27;./save_img&#x27;    # 获取图像数组和id标签数组和姓名    faces,ids=getImageAndLabels(path)    # 获取训练对象    recognizer=cv2.face.LBPHFaceRecognizer_create()    recognizer.train(faces,np.array(ids))    # 保存文件    # 确保目录存在    trainer_dir = &#x27;./trainer&#x27;    if not os.path.exists(trainer_dir):        os.makedirs(trainer_dir)    recognizer.write(&#x27;./trainer/trainer.yml&#x27;)\n\n2. 人脸识别流程：\n\n加载训练数据\n加载识别器\n打开摄像头\n识别人脸\n灰度化\n检测人脸\n识别人脸\n\n\n\nimport cv2import os#加载训练数据集文件recogizer=cv2.face.LBPHFaceRecognizer_create()recogizer.read(&#x27;trainer/trainer.yml&#x27;)names=[]warningtime = 0#准备识别的图片def face_detect_demo(img):    gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)#转换为灰度    face_detector=cv2.CascadeClassifier(&#x27;D:/programming/libs/opencv/opencv/sources/data/haarcascades/haarcascade_frontalface_alt2.xml&#x27;)    face=face_detector.detectMultiScale(gray,1.1,5,cv2.CASCADE_SCALE_IMAGE,(100,100),(300,300))    for x,y,w,h in face:        cv2.rectangle(img,(x,y),(x+w,y+h),color=(0,255,0),thickness=2)        # 人脸识别        ids, confidence = recogizer.predict(gray[y:y + h, x:x + w])        #print(&#x27;标签id:&#x27;,ids,&#x27;置信评分：&#x27;, confidence)        if confidence &gt; 80:            cv2.putText(img, &#x27;unkonw&#x27;, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (0, 255, 0), 1)        else:            cv2.putText(img,str(names[ids-1]), (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (0, 255, 0), 1)    cv2.imshow(&#x27;result&#x27;,img)def name():    path = &#x27;./save_img&#x27;    imagePaths=[os.path.join(path,f) for f in os.listdir(path)]    for imagePath in imagePaths:       name = str(os.path.split(imagePath)[1].split(&#x27;.&#x27;,2)[1])       names.append(name)cap=cv2.VideoCapture(0)name()while True:    flag,frame=cap.read()    if not flag:        break    face_detect_demo(frame)    if ord(&#x27; &#x27;) == cv2.waitKey(1):        breakcv2.destroyAllWindows()cap.release()\n","tags":["python","计算机视觉"]},{"title":"c++17版本更新","url":"/posts/7f23363e.html","content":"c++17新特性C++17 是小版本 C++14 之后的一个大版本，它提供了新的语言和库功能特性。该标准于 2017 年 12 月发布。\n移除或弃用的特性已移除特性\nstd::auto_ptr\n已弃用的函数对象\nstd::random_shuffle\nstd::unexpected\n过时的 iostream 别名\n三标符\nregister 关键字\nbool 类型的自增操作\n动态异常说明\n\n弃用特性\nstd::iterator\nstd::raw_storage_iterator\nstd::get_temporary_buffer\nstd::is_literal_type\nstd::result_of\n整个 &lt;codecvt&gt; 头文件\n\n\n因为这些特性之前并没有被广泛使用，所以对此没有太多了解。只讲链接进行保存，有需要的可以去查看。\n\n新的语言特性u8 字符字面量语法：u8&#39;c字符 &#39;\nUTF-8 字符字面量，例如 u8’a’。这种字面量具有 char(C++20 前)char8_t(C++20 起) 类型，且它的值等于c字符的 ISO&#x2F;IEC 10646 码位值，只要码位值能以单个 UTF-8 代码单元表示（即c字符 处于范围 0x0-0x7F（含边界）内）。\nu8 字符字面量的类型为 char8_t，它是一个新的字符类型，它的大小和 char 相同，但是它的字符集是 UTF-8 字符集。\n将 noexcept 作为类型系统的一部分这个字面量在c++11标准加入，在c++7标准正式成为标准的一部分。作用是在函数声明和定义中使用，用于指定函数是否可以抛出异常。\n新的求值顺序规则在C++中，除非有明确的规则定义，否则表达式的任何部分（包括函数参数）的求值顺序是未指定的。这意味着编译器可以自由选择求值顺序，并且可以在不同时间点以不同的顺序进行求值。\n在C++17之前，C++标准使用的是序列点的概念来描述何时副作用必须完成以及何时可以安全地访问一个对象的值而不导致未定义行为。例如，在同一内存位置上的两次副作用之间如果没有适当的序列点，则会导致未定义行为。典型例子包括对同一个变量进行前置或后置自增&#x2F;自减操作而没有正确地分隔这些操作的情况。\nC++17引入了一些重要的变化和新增规则来改进求值顺序的规定，主要包括：\n明确了某些情况下的求值顺序：C++17明确规定了一些过去求值顺序不明确的情况。例如，在调用函数时，所有实参表达式的求值顺序现在是未指明的而非未定义的。这允许编译器优化代码但避免了完全未定义的行为。避免未定义行为：对于一些特定的表达式，如i &#x3D; ++i + i++;，在C++17之前会导致未定义行为，因为它们在同一内存位置上进行了无序的读写操作。虽然这种表达式仍然被认为是不好的编程实践，但在C++17中，其行为被更清晰地定义为未定义行为，而不是依赖于编译器实现的具体细节。具体的表达式示例：\ni = ++i + 2; //在C++17下具有良好的定义。i = i++ + 2; //在C++17前行为是未定义的，但C++17并没有改变这一点。f(i = -2, i = -2); 和 f(++i, ++i); //在C++17之前是未定义行为，但在C++17中，这些表达式的求值顺序变为未指明，即允许任意顺序执行，但不会造成未定义行为。\n\nlambda 表达式捕获 *this在[]可以捕获*this，表示：当前对象的简单的按复制捕获\n\n与this的区别：\n\n捕获this时，this的类型是指针类型，而捕获*this时，this的类型是引用类型。\n捕获this时，this指向的是当前对象，而捕获*this时，this指向的是当前对象的副本。\n\n\n例子：\nstruct S2 &#123; void f(int i); &#125;;void S2::f(int i)&#123;    [=] &#123;&#125;;        // OK：默认按复制捕获    [=, &amp;i] &#123;&#125;;    // OK：按复制捕获，但 i 按引用捕获    [=, *this] &#123;&#125;; // C++17 前：错误：无效语法                   // C++17 起：OK：按复制捕获外围的 S2    [=, this] &#123;&#125;;  // C++20 前：错误：= 为默认时的 this                   // C++20 起：OK：同 [=]    [i, i] &#123;&#125;;        // 错误：i 重复    [this, *this] &#123;&#125;; // 错误：&quot;this&quot; 重复（C++17）    [i] (int i) &#123;&#125;;   // 错误：形参和捕获的名字相同&#125;\n\nconstexpr编译期的 constexpr if 语句if语句：属性 (可选) if constexpr(可选) ( 初始化语句 (可选) 条件 ) true分支语句 else false分支语句\n参数介绍：属性-(C++11 起) 任意数量的属性constexpr-(C++17 起) 出现时，该语句是 constexpr if 语句初始化语句-(C++17 起) 下列之一：\n\n表达式语句（可以是空语句 ;）\n简单声明，典型的是带初始化器的变量声明，但它可以声明任意多个变量，或是一条结构化绑定声明\n别名声明(C++23 起)\n\n\n注意，任何初始化语句都应以分号 ; 结束。这是它常被非正式地描述成后随分号的表达式或声明的原因。\n\n条件-条件true分支语句-任意当条件求值为 true 时会执行的语句false分支语句-当条件求值为 false 时会执行的语句复合语句-当此 if 语句在明显常量求值语境下求值时会执行的复合语句（consteval 前附 ! 的情况下条件变成“不在这种语境下求值”）语句-当此 if 语句不在明显常量求值语境下求值时会执行的语句（consteval 未前附 ! 的情况下条件变成“在这种语境下求值”）\n以 if constexpr 开始的语句被称为 constexpr if 语句。constexpr if 语句的所有子语句都是有控制流限制的语句。\n在 constexpr if 语句中，条件的值必须是可按语境转换到 bool 类型的经转换常量表达式(C++23 前)按语境转换到 bool 的表达式，其中转换为常量表达式(C++23 起)。\n如果条件的值是 true，那么舍弃 false分支语句（如果存在），否则舍弃 true分支语句。\n简单来说：constexpr if（自C++17起）：这种形式的 if 语句允许编译时分支选择，对于模板编程特别有用。在 constexpr if 中，根据条件表达式的值，编译器可以选择编译或忽略特定的分支。\n\n但是if constexpr 不是 #if 预处理指令的替代品。\n\nconstexpr 的 lambda 表达式constexpr lambda：从C++17开始，lambda表达式可以被声明为constexpr，这意味着如果lambda满足成为constexpr函数的所有要求，它就可以在编译时常量表达式中使用。这使得lambda表达式可以在更多的上下文中使用，比如作为非类型的模板参数。 示例：\nauto getId = [](auto x) constexpr &#123; return x.id; &#125;;\n\n其他有关lambda的特性：\nLambda捕获表达式中的初始化捕获列表中的初始化器：C++17允许在lambda表达式的捕获列表中直接初始化变量。这对于复制或移动捕获特别有用，并且可以简化代码逻辑。 示例：\nint x = 4;auto f = [x = std::move(x)]() &#123; return x; &#125;; // 使用std::move来捕获x\n\n变量inline 变量在此之前，inline主要用于函数和成员函数，允许在多个翻译单元中提供函数定义而不导致链接错误。自C++17起，标准引入了对inline变量的支持，这是C++17相对于之前版本的一个重要更新。\ninline变量（C++17）定义：从C++17开始，变量可以被声明为inline。这使得可以在多个翻译单元（每个源文件为一个翻译单元）中提供相同变量的定义，而不会导致链接时的重复定义错误。这一特性特别适用于常量，因为它允许常量在头文件中定义，并且该头文件可以被多个源文件包含而不会引起冲突。使用场景：当你需要在多个源文件之间共享一个常量或变量时，inline变量是一个理想的解决方案。对于模板编程也非常有用，因为现在你可以定义内联静态数据成员而不需要在每个翻译单元中都提供单独的定义。语法示例：\nstruct MyStruct &#123;    static inline const int MAX_LIMIT = 100; // C++17 及之后&#125;;\n\n在这个例子中，MAX_LIMIT被声明为一个inline静态成员变量。这意味着你可以在多个源文件中包含这个头文件而不会遇到重复定义的问题。\n但是这个特性也有一些问题，比如编译器是否支持。\n结构化绑定结构化绑定允许更方便地将复合类型的成员解包到独立的变量中。这项功能特别适用于处理tuple、pair、数组以及具有多个成员的结构体或类实例的情况。\n语法与参数：\n属性 (可选) 声明说明符序列 引用限定符 (可选) [ 绑定标识符列表 ] 初始化器 ;属性-任意数量的属性的序列decl-specifier-seq-包含以下说明符的序列（遵循简单声明的规则）：    constexpr    constinit    (C++26 起)    static    thread_local    const    volatile    auto引用限定符-&amp; 或 &amp;&amp; 之一绑定标识符列表-此声明所引入的各标识符的逗号分隔的列表，每个标识符可以后随一个属性说明符序列(C++26 起)初始化器-初始化器（见下文）\n初始化器 必须是下列之一：&#x3D; 表达式{ 表达式 }( 表达式 )表达式-（无括号的逗号表达式以外的）任意表达式\n例子：\nauto [name1, name2, ..., nameN] = expression;//解绑std::tuple    auto tupleExample = std::make_tuple(10, &quot;Hello&quot;, 3.14);    auto [num, str, pi] = tupleExample;    std::cout &lt;&lt; num &lt;&lt; &quot;, &quot; &lt;&lt; str &lt;&lt; &quot;, &quot; &lt;&lt; pi &lt;&lt; std::endl;//解绑数组    int arr[] = &#123;1, 2, 3&#125;;    auto [a, b, c] = arr;    std::cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; std::endl;//解绑结构体struct Point &#123;    int x;    int y;&#125;;    Point p = &#123;10, 20&#125;;    auto [x, y] = p;    std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; std::endl;        //指针绑定：虽然不常见，但你也可以将结果绑定到指针上。    auto&amp; [refX, refY] = p; // 绑定为引用    auto* [ptrX, ptrY] = &amp;p; // 绑定为指针    //捕获列表中的使用：结构化绑定也可用于lambda表达式的捕获列表中，这使得在lambda内部可以更容易地访问复杂数据结构的成员。    auto lambda = [&amp;r = data] &#123; /* 使用 r */ &#125;;\n\n\n注意事项引用绑定：你可以通过在声明时添加&amp;或&amp;&amp;来创建对原对象的引用，而不是进行值复制。\n\nif 和 switch 语句中的初始化器在C++17中，if和switch语句得到了增强，允许在其条件表达式中包含初始化器。这项改进使得可以在控制流语句的上下文中声明并初始化变量，同时该变量的作用域被限制在对应的if或switch语句块内。这不仅提升了代码的安全性和可读性，还减少了潜在的错误，比如忘记在不同分支中正确地初始化变量。\nif语句中的初始化器在C++17之前，如果需要在条件判断之前初始化一个变量，通常需要在if语句外部进行，这样可能会导致这个变量的作用域超出预期，增加了出错的可能性。例如：\nstd::string s = &quot;Hello, world!&quot;;std::string::iterator it = s.begin();if (it != s.end()) &#123;    // 使用 it&#125;\n\n而在C++17中，可以直接在if语句中进行初始化，并且初始化的变量仅在if及其对应的else块（如果有）中可见：\nstd::string s = &quot;Hello, world!&quot;;if (auto it = s.begin(); it != s.end()) &#123;    // 使用 it&#125; else &#123;    // it 在这里不可见&#125;// it 在这里也不可见\n\nswitch语句中的初始化器类似地，switch语句也可以包含初始化器，这使得可以在进入不同的case标签前先安全地初始化一些局部变量。这对于需要根据某个值来初始化另一个值的情况特别有用。\n例如：\nint value = getValue();int divisor = 10; // 假设默认除数是10switch (value) &#123;    case 1:        divisor = 5;        // ...        break;    case 2:        divisor = 3;        // ...        break;    default:        // 使用 divisor&#125;\n\n使用C++17的新特性，可以将divisor的初始化直接放在switch语句内部：\nint value = getValue();switch (int divisor = 10; value) &#123; // 初始化divisor为10    case 1:        divisor = 5;        // ...        break;    case 2:        divisor = 3;        // ...        break;    default:        // 使用divisor&#125;// divisor 在这里不可见\n\n强制的复制消除复制消除：当满足特定条件时，可以省略从某个源对象创建具有相同类类型（忽略 cv 限定）的对象的操作，即使选择的构造函数和&#x2F;或析构函数具有副作用。这种对象创建操作的消除被称为复制消除 。\n“强制的复制消除”改进了编译器如何处理某些情况下对象的拷贝或移动构造函数的调用。这项特性特别针对的是返回值优化（Return Value Optimization, RVO）和具名返回值优化（Named Return Value Optimization, NRVO），但与之前的版本不同，C++17标准要求编译器必须执行这种优化，而不是像之前那样作为可选的优化。\n在C++17之前，RVO和NRVO是编译器可以进行的一种优化，目的是避免不必要的临时对象创建、拷贝或移动操作。例如，在以下情况：\nclass C &#123;public:    C() = default;    C(const C&amp;) &#123; std::cout &lt;&lt; &quot;Copy constructor\\n&quot;; &#125;    C(C&amp;&amp;) &#123; std::cout &lt;&lt; &quot;Move constructor\\n&quot;; &#125;&#125;;C f() &#123;    return C(); // 希望通过RVO避免调用拷贝/移动构造函数&#125;int main() &#123;    C obj = f();&#125;\n\n在早期的C++标准中，虽然很多现代编译器会尝试进行RVO来优化上述代码，使得obj直接在最终位置构造，而不需要额外的拷贝或移动，但这并不是强制性的。因此，是否实际发生拷贝或移动依赖于编译器实现。\nC++17引入了一个关键改变：当一个对象被从一个函数返回，并且该对象的类型与返回类型完全匹配时（包括cv限定符），编译器不再需要生成拷贝或移动构造函数的调用。这意味着即使类的拷贝或移动构造函数有副作用（如打印消息），这些副作用也不会发生。这不仅提高了性能，也减少了潜在的错误来源。\n考虑上面的例子，在C++17下，即使C类的拷贝和移动构造函数有副作用，编译器也会忽略它们，不会产生任何输出，因为没有实际的拷贝或移动操作被执行。\n示例说明\nstruct Large &#123;    Large() &#123;&#125;    Large(const Large&amp;) &#123; std::cout &lt;&lt; &quot;Copy\\n&quot;; &#125;    Large(Large&amp;&amp;) &#123; std::cout &lt;&lt; &quot;Move\\n&quot;; &#125;&#125;;Large create() &#123;    return Large(); // 在C++17前可能调用移动构造，在C++17及之后不会有任何构造函数被调用&#125;int main() &#123;    Large l = create(); // 在C++17下，l将直接在最终位置构造，无需拷贝或移动    // 在C++17中，由于强制的复制消除，create()函数中的Large对象将直接在main函数中变量l的位置上构造，而不经过任何形式的拷贝或移动。&#125;\n\n优点：\n强制的复制消除显著提升了C++程序的效率，减少了不必要的构造函数调用，同时保持了语义的一致性。这对于资源密集型的对象尤其重要，因为它允许更高效地管理资源，减少内存分配和释放的开销。此外，这也意味着程序员可以编写更加直观的返回局部对象的代码，而不用担心性能上的损失。\n临时量实质化临时量实质化（Temporary Materialization）定义了纯右值（prvalue）在什么情况下会被转换为亡值（xvalue），即创建一个临时对象的过程。\n临时量实质化的条件:\n\n绑定引用到纯右值时：当尝试将一个引用绑定到一个纯右值时，需要先将该纯右值实质化为一个临时对象。\n访问类纯右值的数据成员时：例如，S().m，其中S()是一个纯右值，访问其成员变量m会促使该纯右值被实质化为一个临时对象。\n调用类纯右值的隐式对象成员函数时：如果对一个纯右值调用了某个成员函数，那么该纯右值首先会被实质化为一个临时对象。\n进行数组到指针转换或在数组纯右值上使用下标时：处理数组类型的纯右值时，如需转换为指针或使用下标操作，也会导致临时量实质化。\n以花括号初始化器列表初始化 std::initializer_list&lt;T&gt; 类型的对象时：这涉及到使用初始化列表来构造对象的情况。\n纯右值作为弃值表达式时：当纯右值被用作不关心结果的表达式时，可能需要实质化。\n\n官方案例：\nstruct S &#123; int m; &#125;;int k = S().m; // C++17 起成员访问期待泛左值；               // S() 纯右值被转换成亡值\n\n在这个例子中，S() 创建了一个类型为 S 的纯右值。由于我们试图访问它的成员变量 m，这要求该纯右值必须首先被实质化为一个临时对象，之后才能对其成员进行访问。因此，在C++17中，S() 会被实质化为一个临时对象，然后通过这个临时对象访问成员 m。\n从纯右值直接初始化同类型对象（无论是通过直接初始化还是复制初始化）并不会触发临时量实质化。这是因为C++17引入了“受保证的复制消除”机制，这意味着编译器可以直接使用源纯右值来初始化目标对象，而不需要创建中间的临时对象。这一特性不仅提高了性能，也简化了程序逻辑。\n\n可以理解为隐式转化的规则之一\n\n模板折叠表达式 ( … )C++17引入了一个称为折叠表达式的新特性，它极大地简化了对参数包（…）的操作。这个特性主要用于模板编程中，使得对不定数量的模板参数进行操作变得更加简单和直观。\n在c++17之前，对参数包进行操作通常需要使用递归或辅助函数或者是使用初始化列表。既麻烦还难看。\nc++17之前：\n// 递归template&lt;typename T&gt;T sum(T n) &#123;    return n;&#125;template&lt;typename T, typename... Args&gt;T sum(T first, Args... rest) &#123;    return first + sum(rest...);&#125;// 初始化列表template&lt;typename... Args&gt;auto sum(Args... args) -&gt; decltype((args + ...)) &#123;    decltype((args + ...)) result&#123;&#125;; // 初始化结果变量为0    (void)std::initializer_list&lt;int&gt;&#123;([&amp;] &#123; result += args; &#125;(), 0)...&#125;;    return result;&#125;// 折叠表达式template&lt;typename... Args&gt;auto sum(Args... args) -&gt; decltype((args + ...)) &#123;    return (args + ...);&#125;\n\n折叠表达式的语法与规则：\n语法折叠表达式主要分为四种形式：\n一元右折叠 (E 运算符 …)：从左至右依次应用运算符。一元左折叠 (… 运算符 E)：从右至左依次应用运算符。二元右折叠 (E 运算符 … 运算符 I)：从左至右依次应用运算符，并以I作为初始值。二元左折叠 (I 运算符 … 运算符 E)：从右至左依次应用运算符，并以I作为初始值。\n其中，运算符可以是C++中的32个二元运算符之一，如+, -, *, &#x2F;, %, ^, &amp;, |, &#x3D;, &lt;, &gt;, &lt;&lt;, &gt;&gt;, +&#x3D;, -&#x3D;, &#x3D;, &#x2F;&#x3D;, %&#x3D;, ^&#x3D;, &amp;&#x3D;, |&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&#x3D;, &#x3D;&#x3D;, !&#x3D;, &lt;&#x3D;, &gt;&#x3D;, &amp;&amp;, ||, ,, ., -&gt;*等。\n特殊情况当一元折叠应用于长度为零的参数包时，仅允许使用特定的运算符：逻辑与（&amp;&amp;），其值为true；逻辑或（||），其值为false；以及逗号运算符（,），其值为void()。\n例：\ntemplate&lt;typename... Args&gt;bool all(Args... args) &#123;    return (... &amp;&amp; args); // 使用一元左折叠&#125;// 如果调用all(true, true, true, false)，那么折叠表达式会展开为((true &amp;&amp; true) &amp;&amp; true) &amp;&amp; false，结果为false。// 1template&lt;typename... Args&gt;void printer(Args&amp;&amp;... args) &#123;    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; &#x27;\\n&#x27;; // 使用折叠表达式&#125;int main() &#123;    printer(1, 2, 3, &quot;abc&quot;); // 输出: 123abc&#125;// 2template&lt;typename T, typename... Args&gt;void push_back_vec(std::vector&lt;T&gt;&amp; v, Args&amp;&amp;... args) &#123;    static_assert((std::is_constructible_v&lt;T, Args&amp;&amp;&gt; &amp;&amp; ...));    (v.push_back(std::forward&lt;Args&gt;(args)), ...);&#125;int main() &#123;    std::vector&lt;int&gt; v;    push_back_vec(v, 6, 2, 45, 12);    for(int i : v) std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; // 输出: 6 2 45 12&#125;\n\n类模板实参推导 tuple t(4, 3, 2.5)C++17引入了类模板实参推导（Class Template Argument Deduction，简称CTAD），这是一项允许编译器自动推断出类模板实例化时所需的模板参数值的功能。这项特性简化了许多情况下需要手动指定模板参数的需求，从而减少了代码的冗余和复杂性。\nc++17之前：\nstd::pair&lt;int, double&gt; p(2, 4.5);\n\nc++17后：\nstd::pair p(2, 4.5); // 编译器可以自动推断出模板参数\n\n为了支持CTAD，C++17允许定义推导指引。\n推导指引是特殊的声明，用于指导编译器如何从构造函数参数推导出模板参数。它们可以是隐式生成的，也可以由用户显式定义。\n\n隐式生成的推导指引：编译器会为每个构造函数自动生成相应的推导指引。\n用户定义的推导指引：用户可以定义自己的推导指引来覆盖默认行为或处理特殊情况。\n\n用户自定义推导指引的语法：\ntemplate&lt;class T&gt; struct A &#123;    A(T, int*);&#125;;template&lt;class T&gt;A(T*, int*) -&gt; A&lt;T&gt;; // 用户定义的推导指引int i, *ip;A a&#123;i, ip&#125;; // 自动推导为 A&lt;int&gt;\n\n\n没有完全搞懂，先放案例吧。。。\n\n注意：\nCTAD仅在未提供模板实参列表的情况下发生。如果提供了模板实参列表，则不会触发推导。在某些情况下，如存在多个可能的推导指引时，编译器会根据一定的优先级规则选择最合适的推导指引。复制推导候选通常比包装构造函数更受偏好，以避免不必要的嵌套。\nauto 占位的非类型模板形参在C++17之前，非类型模板参数（non-type template parameters, NTTPs）必须显式地指定其类型。例如：\ntemplate&lt;int N&gt; //这里，N是一个整数类型的非类型模板参数。struct S &#123;    void foo() &#123; /* ... */ &#125;&#125;;\n\nC++17的新方式通过C++17的增强，我们可以使用auto关键字来代替具体的类型，这为模板提供了更大的灵活性和通用性。例如：\ntemplate&lt;auto N&gt;struct S &#123;    void foo() &#123; /* ... */ &#125;&#125;;\n\n在这个例子中，N可以是任何能作为非类型模板参数的值，无论它是int, long, double还是指针等。这意味着您不再需要为每种可能的类型分别编写模板特化或重载。\n注意事项:\n\n虽然auto使得模板更加通用，但它不能用于所有类型的非类型模板参数。例如，类类型的对象（除非它们是字面量类型且有适当的转换构造函数）不能作为非类型模板参数。\n此外，使用auto作为非类型模板形参时，不能与占位类型（placeholder types）如T结合使用于同一个模板形参列表内，这是为了避免歧义和复杂性。\n\n命名空间简化的嵌套命名空间c++11中嵌套命名空间的语法：\nnamespace A &#123;    namespace B &#123;        namespace C &#123;            // 在这里定义 C 命名空间的内容        &#125;    &#125;&#125;\n\nc++17中简化的嵌套命名空间的语法：\nnamespace A::B::C &#123;    // 在这里定义 C 命名空间的内容&#125;\n\nusing 声明语句可以声明多个名称using声明语句得到了增强，允许一次导入多个名称（如类型、函数或模板）从一个命名空间到另一个命名空间。这项改进简化了代码，减少了重复的using声明需求。\nc++14中：\nnamespace foo &#123;    void f() &#123;&#125;    void g() &#123;&#125;    void h() &#123;&#125;&#125;using foo::f;using foo::g;using foo::h;\n\nc++17后：\nnamespace foo &#123;    void f() &#123;&#125;    void g() &#123;&#125;    void h() &#123;&#125;&#125;using foo::&#123;f, g, h&#125;;\n\n属性命名空间不必重复在C++17中，对于属性的使用有了改进，使得当多个属性属于同一个命名空间时，不必为每个属性都重复指定命名空间。具体来说，如果一组属性都位于同一个命名空间内（例如std::literals），您可以一次性指定这个命名空间，然后列出所有需要使用的属性，而不需要对每个属性名都加上完整的命名空间前缀。\n在C++17之前，如果您想要使用来自特定命名空间的多个属性，您可能需要这样写：\nvoid function() [[std::literals::fast_math]] [[std::literals::ivdep]] [[std::literals::align_value(16)]];\n\n但在C++17中，通过使用[[using namespace_name: …]]语法，可以简化为：\nvoid function() [[using std::literals: fast_math, ivdep, align_value(16)]]; \n\n属性说明符序列 (C++11 起)为类型、对象、代码等引入由实现定义的属性。\n语法[[ 属性列表 ]]  (C++11 起)[[ using 属性命名空间 : 属性列表 ]]  (C++17 起)其中属性列表 是由逗号分隔的零或更多个属性 的序列（可以以指示包展开的省略号 … 结束）\n标识符属性命名空间 :: 标识符标识符 ( 实参列表 (可选) )属性命名空间 :: 标识符 ( 实参列表 (可选) )其中属性命名空间为一个标识符，而实参列表为其中圆括号、方括号和花括号平衡出现的记号序列（平衡记号序列）。\n\n简单属性，例如 [[noreturn]]。\n有命名空间的属性，例如 [[gnu::unused]]。\n有实参的属性，例如 [[deprecated(“原因”)]]。\n既有命名空间又有实参列表的属性。\n\n\n\n除了以下所列出的标准属性之外，实现还可能支持拥有由实现定义的行为的任意非标准属性。所有实现所未知的属性均被忽略，且不产生错误。\n\n新属性[fallthrough]指示从前一标号直落是有意的，而在发生直落时给出警告的编译器不应诊断它。\n直落语句只能用在 switch 语句中，其中待执行的下个语句是该 switch 语句的带 case 或 default 标号的语句。如果直落语句在循环中，那么下个（带标号）语句必须是该循环的同一迭代的一部分。\n实例：\nvoid f(int n)&#123;    void g(), h(), i();     switch (n)    &#123;        case 1:        case 2:            g();            [[fallthrough]];        case 3: // 直落时不警告            h();        case 4: // 编译器可在发生直落时警告            if (n &lt; 3)            &#123;                i();                [[fallthrough]]; // OK            &#125;            else            &#123;                return;            &#125;        case 5:            while (false)            &#123;                [[fallthrough]]; // 非良构：下一语句不是同一迭代的一部分            &#125;        case 6:            [[fallthrough]]; // 非良构：没有后继的 case 或 default 标号    &#125;&#125;\n\n[maybe_unused]抑制针对未使用实体的警告。\n此属性可出现在下列实体的声明中：class/struct/union：struct [[maybe_unused]] S;typedef，包括别名声明：[[maybe_unused]] typedef S* PS;，using PS [[maybe_unused]] = S*;变量，包括静态数据成员：[[maybe_unused]] int x;非静态数据成员：union U &#123; [[maybe_unused]] int n; &#125;;函数：[[maybe_unused]] void f();枚举：enum [[maybe_unused]] E &#123;&#125;;枚举项：enum &#123; A [[maybe_unused]], B [[maybe_unused]] = 42 &#125;;结构化绑定：[[maybe_unused]] auto [a, b] = std::make_pair(42, 0.23);对于声明为 [[maybe_unused]] 的实体，如果没有使用这些实体或它们的结构化绑定，那么编译器针对未使用实体发布的警告会被抑制。\n\n[nodiscard]在转换到 void 之外的弃值表达式中调用声明为 nodiscard 的函数，或调用按值返回声明为 nodiscard 的枚举或类的函数时，鼓励编译器发布警告。\n\n在C++中，“弃值表达式”是指那些计算结果被有意忽略、不用于任何后续操作的表达式。通常情况下，这意味着表达式的值没有被存储到变量中，也没有作为参数传递给函数等。例如：调用函数仅为了其副作用：有时我们调用一个函数主要是为了它的副作用（如打印输出、修改全局状态等），而不是关心它的返回值。在这种情况下，函数的返回值就被忽略了。std::puts(&quot;Hello, world!&quot;);// 例如，std::puts 返回写入的字符数，但我们通常只关心它是否成功执行了打印操作\n\n__has_include语法：#include &lt; h字符序列 &gt; 换行 (1)#include “ q字符序列 “ 换行 (2)#include 记号序列 换行 (3)__has_include ( “ q字符序列 “ )__has_include ( &lt; h字符序列 &gt; ) (4) (C++17 起)__has_include ( 字符串字面量 )__has_include ( &lt; h记号序列 &gt; ) (5) (C++17 起)\n\n搜索由 h字符序列 唯一识别的标头，并将该指令替换为这个标头的全部内容。\n搜索由 q字符序列 识别的源文件，并将该指令替换为这个源文件的全部内容。可能退回至语法 (1) 并将 q字符序列 视为标头标识符。\n如果 (1) 和 (2) 都不匹配，记号序列 会经历宏替换。该指令在替换后会再次尝试匹配 (1) 和 (2)。\n检查是否可以包含一个标头或源文件。\n如果 (4) 不匹配，h记号序列 会经历宏替换。该指令在替换后会再次尝试匹配 (4)。换行 - 换行字符h字符序列 - 一个或多个 h字符 的序列，并且其中以下内容的出现受条件性支持：\n\n\n字符 ‘\n字符 “\n字符 \\\n字符序列 &#x2F;&#x2F;\n字符序列 &#x2F;*\n\nh字符 - 源字符集(C++23 前)翻译字符集(C++23 起) 除了换行符和 &gt; 以外的任何成员q字符序列 - 一个或多个 q字符 的序列，并且其中以下内容的出现受条件性支持：\n\n字符 ‘\n字符 \\\n字符序列 &#x2F;&#x2F;\n字符序列 &#x2F;*\n\nq字符 - 源字符集(C++23 前)翻译字符集(C++23 起) 除了换行符和 “ 以外的任何成员记号序列 - 一个或多个预处理记号的序列字符串字面量 - 一个字符串字面量h记号序列 - 一个或多个除了 &gt; 以外的预处理记号的序列\n这个特性是因为社区对头文件有了更深的理解才诞生的。实例：\n#if __has_include(&lt;optional&gt;)    #include &lt;optional&gt;    #define has_optional 1    template&lt;class T&gt;    using optional_t = std::optional&lt;T&gt;;#elif __has_include(&lt;experimental/optional&gt;)    #include &lt;experimental/optional&gt;    #define has_optional -1    template&lt;class T&gt;    using optional_t = std::experimental::optional&lt;T&gt;;#else    #define has_optional 0    template&lt;class V&gt;    class optional_t    &#123;        V v&#123;&#125;;        bool has&#123;&#125;;     public:        optional_t() = default;        optional_t(V&amp;&amp; v) : v(v), has&#123;true&#125; &#123;&#125;        V value_or(V&amp;&amp; alt) const&amp;        &#123;            return has ? v : alt;        &#125;        // etc.    &#125;;#endif #include &lt;iostream&gt; int main()&#123;    if (has_optional &gt; 0)        std::cout &lt;&lt; &quot;&lt;optional&gt; 存在\\n&quot;;    else if (has_optional &lt; 0)        std::cout &lt;&lt; &quot;&lt;experimental/optional&gt; 存在\\n&quot;;    else        std::cout &lt;&lt; &quot;&lt;optional&gt; 不存在\\n&quot;;     optional_t&lt;int&gt; op;    std::cout &lt;&lt; &quot;op = &quot; &lt;&lt; op.value_or(-1) &lt;&lt; &#x27;\\n&#x27;;    op = 42;    std::cout &lt;&lt; &quot;op = &quot; &lt;&lt; op.value_or(-1) &lt;&lt; &#x27;\\n&#x27;;&#125;\n\n新的头文件&lt;any&gt;&lt;charconv&gt;&lt;execution&gt;&lt;filesystem&gt;&lt;memory_resource&gt;&lt;optional&gt;&lt;string_view&gt;&lt;variant&gt;\n","tags":["cpp"]},{"title":"数据结构","url":"/posts/79666db.html","content":"[TOC]\n数据结构与算法顺序表template&lt;typename T&gt;class CMyvector&#123;private: T* p; int Len;public:\tCMyvector()\t&#123;     p = NULL;\t\tLen = 0;\t&#125;\t~CMyvector()\t&#123;\t\tdelete[] p;\t\tLen = 0;\t&#125;\t//创建顺序表\tvoid create(const T&amp; _p)\t&#123;\t\tif (Len==0)\t\t&#123;\t\t\t//申请内存\t\t\tp = new T;\t\t\t//赋值\t\t\t*p = _p;\t\t\t//增加数量\t\t\tLen++;\t\t&#125;\t\telse\t\t&#123;\t\t\t//创建变量\t\t\tT* Newp = new T[Len + 1];\t\t\t//赋值\t\t\tmemcpy(Newp, p, sizeof(T)*Len);\t\t\tNewp[Len] = _p;\t\t\tdelete[] p;\t\t\tp = Newp;\t\t\tNewp = NULL;\t\t\tLen++;\t\t&#125;\t&#125;\t//显示顺序表\tvoid Show()\t&#123;\t\tcout &lt;&lt; &quot;数组里有&quot; &lt;&lt; Len &lt;&lt; &quot;个: &quot;;\t\tfor (int i = 0; i &lt; Len; i++)\t\t&#123;\t\t\tcout&lt;&lt; p[i] &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;\t//删除\tvoid Ddelete(int n/*第几个*/)\t&#123;\t\tif (p==NULL)\t\t&#123;\t\t\treturn;\t\t&#125;\t\tif (n&gt;Len)\t\t&#123;\t\t\treturn;\t\t&#125;\t\tint True = n - 1;/*下标*/\t\tif (True&lt;0)\t\t&#123;\t\t\treturn;\t\t&#125;\t\tswitch (Len)\t\t&#123;\t\tcase 1:\t\t\tdelete[] p;\t\t\tcout &lt;&lt; &quot;数组已经清除\\n&quot;;\t\t\treturn;\t\tdefault:\t\t&#123;\t\t\tT* Newp = new T[Len - 1];\t\t\tif (True==0)\t\t\t&#123;\t\t\t\tmemcpy(Newp, p+1, sizeof(T) * (Len-1));\t\t\t\tdelete[] p;\t\t\t\tp = Newp;\t\t\t\tNewp = NULL;\t\t\t\tLen--;\t\t\t\treturn;\t\t\t&#125;\t\t\t else if (True == Len-1)\t\t\t &#123; \t\t\t\tmemcpy(Newp, p, sizeof(T) * (Len - 1));\t\t\t\tdelete[] p;\t\t\t\tp = Newp;\t\t\t\tNewp = NULL;\t\t\t\tLen--;\t\t\t\treturn;\t\t\t &#125;\t\t\t else\t\t\t &#123;\t\t\t\tmemcpy(Newp, p, sizeof(T) * True);\t\t\t\tmemcpy(Newp+ True, p+ n, sizeof(T) * (Len - True-1));\t\t\t\tdelete[] p;\t\t\t\tp = Newp;\t\t\t\tNewp = NULL;\t\t\t\tLen--;\t\t\t\treturn;\t\t\t &#125;\t\t&#125;\t\treturn;\t\t&#125;\t&#125;&#125;;\n\n\n顺序表是比较简单的，在这里可以普及一下memcpy函数，这是直接缓存区里进行复制的函数\n一个数右移1位就是除以2，左移1位就是乘以2，移多少位就是2的多少次幂（左正又负）\n\n链表//循环双链表template &lt;typename T&gt;class CMyLink&#123;private:\tCMyLink* Next;\tCMyLink* last;\tT Things;public:\tCMyLink()\t&#123;\t\tNext = last = NULL;\t&#125;\tCMyLink(T Things):Things(Things)\t&#123;\t\tNext = last = NULL;\t&#125;\t~CMyLink()\t&#123;\t\tlast = Next = NULL;\t&#125;\t//插入\tvoid push(T Things)\t&#123;\t\tCMyLink* Newp = new CMyLink;\t\tNewp-&gt;Things = Things;\t\tif (Next)\t\t&#123;\t\t\tCMyLink* Pp = this;\t\t\tNewp-&gt;last = Pp;\t\t\tNewp-&gt;Next = Pp-&gt;Next;\t\t\tPp-&gt;Next = Newp;\t\t\tNewp-&gt;Next-&gt;last = Newp;\t\t&#125;\t\telse\t\t&#123;\t\t\tlast =Next = Newp;\t\t\tNewp-&gt;last = Newp-&gt;Next = this;\t\t&#125;\t\t\t&#125;\t//删除特定元素\tvoid pop(T Things)\t&#123;\t\tCMyLink&lt;T&gt;* Px = this;\t\tbool judge = 1;\t\twhile (judge)\t\t&#123;\t\t\tif (Px-&gt;Things==Things)\t\t\t&#123;\t\t\t\tPx-&gt;Next-&gt;last = Px-&gt;last;\t\t\t\tPx-&gt;last-&gt;Next = Px-&gt;Next;\t\t\t\tdelete Px;\t\t\t\treturn ;\t\t\t&#125;\t\t\tPx = Px-&gt;Next;\t\t\tif (Px == this)\t\t\t&#123;\t\t\t\tjudge = 0;\t\t\t&#125;\t\t&#125;\t&#125;\t//改特定元素\tvoid pop(int n, T Things)\t&#123;\t\tCMyLink&lt;T&gt;* Px = this;\t\tfor (int i = 0; i &lt; n; i++)\t\t&#123;\t\t\tPx = Px-&gt;Next;\t\t&#125;\t\tPx-&gt;Things = Things;\t&#125;\t//输出列表\tvoid print()\t&#123;\t\tCMyLink&lt;T&gt;* Px = this;\t\tbool judge = 1;\t\twhile (judge)\t\t&#123;\t\t\tPx = Px-&gt;Next;\t\t\tif (Px-&gt;Next == this)\t\t\t&#123;\t\t\t\tjudge = 0;\t\t\t&#125;\t\t\tcout &lt;&lt; Px-&gt;Things &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;&#125;;\n\n\n&#x3D;&#x3D;这就是双向循环链表，切记前后链的关系&#x3D;&#x3D;\n\n排序算法   （都以升序为例）冒泡排序void froth(int a[],int length)&#123;\t//每次比出最大的一个放在后面，比length-1次\tfor (int j = 0; j &lt; length-1; j++)\t&#123;\t\tint t = 0;\t\tfor (int i = 0; i &lt; length - 1 - j ; i++)\t\t&#123;\t\t\tif (a[i]&gt;a[i+1])\t\t\t&#123;\t\t\t\tt = a[i + 1];\t\t\t\ta[i + 1] = a[i];\t\t\t\ta[i] = t;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n选择排序void choice(int a[], int len)&#123;\t//每次选则最小的放在合适位置循环len-1次\tfor (int i = 0; i &lt; len-1; i++)\t&#123;\t\tint ts = 0;\t\tint t = i;\t\tfor (int j = i+1; j &lt; len; j++)\t\t&#123;\t\t\tt = ((a[t] &lt; a[j]) ? t : j);\t\t&#125;\t\tts = a[i];\t\ta[i] = a[t];\t\ta[t] = ts;\t&#125;&#125;\n\n插入排序void insert(int a[], int len)&#123;\t//把第一个当成有序数组，后面的依次往里面插\tfor (int i = 1; i &lt; len; i++)\t&#123;\t\tint j=0,t = a[i];\t\tfor (j = i-1; j &gt;= 0 &amp;&amp; a[j] &gt; t ; j--)\t\t&#123;\t\t\ta[j + 1] = a[j];\t\t&#125;\t\ta[j + 1] = t;\t&#125;&#125;\n\n希尔排序void Shell_sort(int a[], int len)&#123;\t//每次分len=len/2组，再在组内做插入排序，一直分到只有一组\tint step = len / 2;\twhile (step)\t&#123;\t\tfor (int i = step; i &lt; len; i++)\t\t&#123;\t\t\tint j = 0,t = a[i];\t\t\tfor (j =i-step; j &gt;= 0 &amp;&amp; a[j] &gt; t; j-=step)\t\t\t&#123;\t\t\t\ta[j + step] = a[j];\t\t\t&#125;\t\t\ta[j + step] = t;\t\t&#125;\t\tstep /= 2;\t&#125;&#125;\n\n\n是插入算法的升级版\n\n基数排序void base_num(int a[], int len)&#123;\t//知道数组中最大的数，然后创建临时数组[最大数+1]，初始化不可能出现的数\t//根据数组下标把数组放进临时数组里\t//把排好序的临时数组放回去---&gt;使用限制非常多\tint max = -5;\tfor (int i = 0; i &lt; len; i++)\t&#123;\t\tif (max &lt;a[i])\t\t&#123;\t\t\tmax = a[i];\t\t&#125;\t&#125;\tint* p = new int[max + 1];\tmemset(p, -1, sizeof(int)*(max+1));\tfor (int i = 0; i &lt; len; i++)\t&#123;\t\tp[a[i]] = a[i];\t&#125;\tint k = 0;\tfor (int i = 0; i &lt; max+1; i++)\t&#123;\t\tif (p[i]!= -1)\t\t&#123;\t\t\ta[k++] = p[i];\t\t&#125;\t&#125;\tdelete[] p;&#125;\n\n\n这种算法是时间复杂度最优的，也是最稳定的没有之一但是其限制很多\n\n\n只能是正整数（有负数转成正数排完再转会负数）\n不能有重复的数据\n特别注意空间—&gt;最好是数字间都离得比较近，离得比较远就不合适了\n\n桶排序void pail_num(int a[], int len)&#123;\t//把数据分类，再用其他的排序方法排序，再组合到一起    //找到最高位\tint Max = 1;\tfor (int i = 0; i &lt; 10; i++)//找到最高位，这个可以传参给的已知、int最高是21亿多所以遍历十次\t&#123;\t\tint n = 0;\t\tfor (int j = 0; j &lt; len; j++)\t\t&#123;\t\t\tif (a[j]/ Max !=0)\t\t\t&#123;\t\t\t\tn++;\t\t\t&#125;\t\t&#125;\t\tif (n==0)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\tMax *= 10;\t&#125;\tint wei = 1;\tint** p = new int* [10];    //创建二维数组\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tp[i] = new int[len];\t&#125;\twhile (wei&lt;Max)\t&#123;        //初始化二维数组\t\tfor (int i = 0; i &lt; 10; i++)\t\t&#123;\t\t\tfor (int j = 0; j &lt; len; j++)\t\t\t&#123;\t\t\t\tp[i][j] = -1;\t\t\t&#125;\t\t&#125;\t\tint date;        //把数据放进箱子里\t\tfor (int i = 0; i &lt; len; i++)\t\t&#123;\t\t\tdate = a[i] / wei % 10;\t\t\tp[date][i] = a[i];\t\t&#125;\t\tint k = 0;        //数据从箱子里拿出来覆盖回原数组\t\tfor (int i = 0; i &lt; 10; i++)\t\t&#123;\t\t\tfor (int j = 0; j &lt; len; j++)\t\t\t&#123;\t\t\t\tif (p[i][j]!=-1)\t\t\t\t&#123;\t\t\t\t\ta[k++] = p[i][j];\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\twei *= 10;\t&#125;&#125;\n\n\n牺牲空间，节约时间\n\n分治思想下的几种排序：二分查找//二分查找---&gt;循环版int Binary_Search(int a[],int len,int num)&#123;\t//每次找数组的中间数，然后判断，如果是返回结果\t//如果大了，或者小了，就缩小边界直到找到，或者查找完成后没有\tint l = 0;\tint r = len - 1;\tint m ;\twhile (1)\t&#123;\t\tif (l&gt;r)\t\t&#123;\t\t\treturn -1;\t\t&#125;\t\tm = l + (r - l) / 2;\t\tif (a[m] ==num)\t\t&#123;\t\t\treturn m;\t\t&#125;\t\telse if (num&gt; a[m])\t\t&#123;\t\t\tl = m + 1;\t\t&#125;\t\telse if (num&lt;a[m])\t\t&#123;\t\t\tr = m - 1;\t\t&#125;\t&#125;&#125;\n\n//二分查找---&gt;递归版int Binary_Search1(int a[], int l,int r, int num)&#123;\t    if (l &gt; r)\t\t&#123;\t\t\treturn -1;\t\t&#125;\t    int m =  l + (r - l) / 2 ;\t\tif (a[m] == num)\t\t&#123;\t\t\treturn m;\t\t&#125;\t\telse if (num &gt; a[m])\t\t&#123;\t\t\treturn Binary_Search1(a, m + 1, r, num);\t\t&#125;\t\telse if (num &lt; a[m])\t\t&#123;\t\t\treturn Binary_Search1(a, l, m-1, num);\t\t&#125;&#125;\t\n\n\n&#x3D;&#x3D;二分查找需要先排序后找&#x3D;&#x3D;\n\n并归排序void merge(int a[], int l, int m, int r);void Separate_and_merge(int a[], int l,int r)//--&gt;这个是为了实现出现两个有序数组数组的&#123;\t//把数组分解为一个个元素，然后再有序的合并\t//更多的用处是为两个有序数组合并为一个的数组排序\tif (l&lt;r)\t&#123;\t\tint m = l + (r - l) / 2;\t\tSeparate_and_merge(a, l, m);\t\tSeparate_and_merge(a, m + 1, r);\t\tmerge(a, l,m, r);\t&#125;&#125;//合---&gt;这才是主要的归并排序void merge(int a[], int l,int m, int r)&#123;    //创建存数据的暂时数组，把两个有顺序的数组左右做比较，谁小谁进临时数组里，把一边的数组比较完算结束\t//把剩下没有存入数组里的数直接存入数组里\tint* p = new int[r - l + 1];\tint l1 = l;\tint Newr = m + 1;\tint k=0;\twhile (l1 &lt;= m &amp;&amp; Newr &lt;= r)\t&#123;\t\tif (a[l1]&lt;a[Newr])\t\t&#123;\t\t\tp[k++] = a[l1++];\t\t&#125;\t\telse\t\t&#123;\t\t\tp[k++] = a[Newr++];\t\t&#125;\t&#125;\twhile (l1&lt;=m)\t&#123;\t\tp[k++] = a[l1++];\t&#125;\twhile (Newr&lt;=r)\t&#123;\t\tp[k++] = a[Newr++];\t&#125;\tk = 0;\tfor (int i = l; i &lt;=r ; i++)\t&#123;\t\ta[i] = p[k++];\t&#125;\tdelete[] p;&#125;\n\n\n这种排序适合两个有序数组合并后排序，尽量不正常数组排序，没有基数排序快\n\n快速排序//快速排序--&gt;效率高一些的分组排序void quick(int a[], int l, int r)&#123;    //找一个数当中间数，比他大的放右边小的放左边，然后两边重复做这样的操作，直到分解为不能分解结束\tif (l&gt;r)\t&#123;\t\treturn;\t&#125;\tint l1 = l;\tint r1 = r;\tint t = a[l1];\twhile (l1&lt;r1)\t&#123;\t\twhile (a[r1]&gt;t)\t\t&#123;\t\t\tr1--;\t\t&#125;\t\ta[l1] = a[r1];\t\twhile (l1&lt;r1&amp;&amp;a[l1]&lt;t)\t\t&#123;\t\t\tl1++;\t\t&#125;\t\ta[r1] = a[l1];\t&#125;\ta[l1] = t;\tquick(a, l, l1-1);\tquick(a, l1 + 1, r);&#125;\n\n二叉树先了解树//创建一个树的结构，这个结构功能有//增删改查template&lt;class T&gt;class Mytree&#123;private:\tstruct Node\t&#123;\t\tNode* on;\t\tNode* down;\t\tNode* r;\t\tT i;\t&#125;;\tNode* tree;public:\tMytree()\t&#123;\t\ttree = NULL;\t&#125;\t~Mytree()\t&#123;\t\tDeleteThis();\t\ttree = NULL;\t&#125;\t//创建\t//创建：首先确定是往下，还是横向，要是有横向成员了，默认只能往后增加，往下同理,如果没有寻找到默认加到根旁边\tvoid create(T i,int n/*第几个*/, bool on = true/*往下*/)\t&#123;\t\tif (tree==NULL)\t\t&#123;\t\t\ttree = new Node;\t\t\ttree-&gt;i = i;\t\t\ttree-&gt;down = NULL;\t\t\ttree-&gt;on = NULL;\t\t\ttree-&gt;r = NULL;\t\t\treturn;\t\t&#125;\t\tint t = n - 1;\t\tNode* one = new Node;\t\tone-&gt;down = NULL;\t\tone-&gt;on = NULL;\t\tone-&gt;r = NULL;\t\tNode* next = tree;\t\tif (on)\t\t&#123;\t\t\tfor (t;t&gt;0;t--)\t\t\t&#123;\t\t\t\tif (next-&gt;down ==NULL)\t\t\t\t&#123;\t\t\t\t\tnext-&gt;down = one;\t\t\t\t\tone-&gt;on = next;\t\t\t\t\tone-&gt;i = i;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t\tnext = next-&gt;down;\t\t\t&#125;\t\t\tnext-&gt;down = one;\t\t\tone-&gt;on = next;\t\t\tone-&gt;i = i;\t\t\treturn;\t\t&#125;\t\telse\t\t&#123;\t\t\tfor (t; t &gt; 0; t--)\t\t\t&#123;\t\t\t\tif (next-&gt;down == NULL)\t\t\t\t&#123;\t\t\t\t\tNode* p = next-&gt;on;\t\t\t\t\twhile (next-&gt;r)\t\t\t\t\t&#123;\t\t\t\t\t\tnext = next-&gt;r;\t\t\t\t\t&#125;\t\t\t\t\tnext-&gt;r = one;\t\t\t\t\tone-&gt;on = p;\t\t\t\t\tone-&gt;i = i;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t\tnext = next-&gt;down;\t\t\t&#125;\t\t\tNode* p = next-&gt;on;\t\t\twhile (next-&gt;r)\t\t\t&#123;\t\t\t\tnext = next-&gt;r;\t\t\t&#125;\t\t\tnext-&gt;r = one;\t\t\tone-&gt;on = p;\t\t\tone-&gt;i = i;\t\t\treturn;\t\t&#125;\t&#125;\t//输出\tvoid Mycout()\t&#123;\t\tNode* p1=tree;\t\tNode* p2;\t\twhile (p1)\t\t&#123;\t\t\tp2 = p1;\t\t\twhile (p2)\t\t\t&#123;\t\t\t\tcout &lt;&lt; p2-&gt;i &lt;&lt; &quot; &quot;;\t\t\t\tp2=p2-&gt;r;\t\t\t&#125;\t\t\tp1=p1-&gt;down;\t\t&#125;\t&#125;\t//删除\t//删除：找到要删掉的节点，把这支删掉,然后把其他的缝上\tvoid Mydelete(T i)\t&#123;\t\tNode* p1 = tree;\t\tNode* p2;\t\twhile (p1)\t\t&#123;\t\t\tp2 = p1;\t\t\twhile (p2)\t\t\t&#123;\t\t\t\tif (p2-&gt;i==i)\t\t\t\t&#123;\t\t\t\t\tp2-&gt;on-&gt;down = p2-&gt;down;\t\t\t\t\tp2-&gt;down-&gt;r = p2-&gt;r;\t\t\t\t\tdelete p2;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t\telse if (p2-&gt;r!=NULL&amp;&amp;p2-&gt;r-&gt;i==i)\t\t\t\t&#123;\t\t\t\t\tNode* p3 = p2;\t\t\t\t\tp3-&gt;r = p3-&gt;r-&gt;r;\t\t\t\t\tdelete p2-&gt;r;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t\tp2 = p2-&gt;r;\t\t\t&#125;\t\t\tp1 = p1-&gt;down;\t\t&#125;\t&#125;\t//注销树\tvoid DeleteThis()\t&#123;\t\tNode* p1 = tree;\t\tNode* p2;\t\twhile (p1)\t\t&#123;\t\t\tp2 = p1;\t\t\tp1 = p1-&gt;down;\t\t\twhile (p2)\t\t\t&#123;\t\t\t\tNode* p3 = p2;\t\t\t\tp2 = p2-&gt;r;\t\t\t\tdelete p3;\t\t\t&#125;\t\t&#125;\t&#125;\t//修改树\tvoid change(T i,T i1)\t&#123;\t\tNode* p1 = tree;\t\tNode* p2;\t\twhile (p1)\t\t&#123;\t\t\tp2 = p1;\t\t\twhile (p2)\t\t\t&#123;\t\t\t\tif (p2-&gt;i == i)\t\t\t\t&#123;\t\t\t\t\tp2-&gt;i = i1;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t\tp2 = p2-&gt;r;\t\t\t&#125;\t\t\tp1 = p1-&gt;down;\t\t&#125;\t&#125;&#125;;\n\n无序二叉树template&lt;class T&gt;class Mytree&#123;\t//树自身本来就有递归的特性，所以需要用递归\t/*已知 中序遍历 和 先序遍历  能推导出  后序遍历\t\t已知 中序遍历 和 后序遍历  能推导出  先序遍历\t\t已知 先序遍历 和 后序遍历, 推导不出*/private:\tstruct Node\t&#123;\t\tNode* l;\t\tNode* r;\t\tT date;\t\tNode(const T date)\t\t&#123;\t\t\tthis-&gt;date = date;\t\t\tl = r = NULL;\t\t&#125;\t&#125;;\tNode* p;\t//插入\tbool _insort(T date, Node*&amp; p)\t&#123;\t\t//首先是判断指针是否为空\t\tif (p==NULL)\t\t&#123;\t\t\tp = new Node(date);\t\t\treturn true;\t\t&#125;\t\t//然后数据放在做还是右-&gt;用标记法\t\tif (p-&gt;date==TAG)\t\t&#123;\t\t\treturn false;\t\t&#125;\t\tif (_insort(date, p-&gt;l))\t\t&#123;\t\t\treturn true;\t\t&#125;\t\treturn _insort(date, p-&gt;r);\t&#125;\t//先序 根 左 右\tvoid _preTravel(Node*p)\t&#123;\t\tif (p==NULL)\t\t&#123;\t\t\treturn;\t\t&#125;\t\tcout &lt;&lt; p-&gt;date &lt;&lt; &quot; &quot;;\t\t_preTravel(p-&gt;l);\t\t_preTravel(p-&gt;r);\t&#125;\t//中序 左 根 右\tvoid _midTravel(Node* p)\t&#123;\t\tif (p == NULL)\t\t&#123;\t\t\treturn;\t\t&#125;\t\t_midTravel(p-&gt;l);\t\tcout &lt;&lt; p-&gt;date &lt;&lt; &quot; &quot;;\t\t_midTravel(p-&gt;r);\t&#125;\t//后序 左 右 根\tvoid _lstTravel(Node* p)\t&#123;\t\tif (p == NULL)\t\t&#123;\t\t\treturn;\t\t&#125;\t\t_lstTravel(p-&gt;l);\t\t_lstTravel(p-&gt;r);\t\tcout &lt;&lt; p-&gt;date &lt;&lt; &quot; &quot;;\t&#125;public:\tMytree()\t&#123;\t\tp = NULL;\t&#125;\t~Mytree()\t&#123;\t&#125;\tvoid insort(T date)\t&#123;\t\t_insort(date, p);\t&#125;\t//遍历\t//type为-1 先序 type为0 中序 type为1 后序\tvoid travel(int type)\t&#123;\t\tswitch (type)\t\t&#123;\t\tcase -1:\t\t\tcout &lt;&lt; &quot;先序遍历：&quot;; _preTravel(p); cout &lt;&lt; endl;\t\t\tbreak;\t\tcase 0:cout &lt;&lt; &quot;中序遍历：&quot;; _midTravel(p); cout &lt;&lt; endl;\t\t\tbreak;\t\tcase 1:cout &lt;&lt; &quot;后序遍历：&quot;; _lstTravel(p); cout &lt;&lt; endl;\t\t\tbreak;\t\t&#125;\t&#125;&#125;;\n\n有序二叉树template&lt;class T&gt;class Mytree&#123;\t//增删查-&gt;因为要有序所以不能改private:\tstruct Node\t&#123;//节点\t\tNode* l;\t\tNode* r;\t\tT date;\t\tNode(T date)\t\t&#123;\t\t\tthis-&gt;date = date;\t\t\tl = r = NULL;\t\t&#125;\t&#125;;\tNode* p;\tvoid _insert(T date,Node*&amp; p)\t&#123;\t\t//有序二叉树是要从高到低插入数据-&gt;升序：左&lt;中&lt;右\t\tif (p==NULL)\t\t&#123;\t\t\tp = new Node(date);\t\t\treturn;\t\t&#125;\t\tif (p-&gt;date&lt;=date)\t\t&#123;\t\t\t_insert(date, p-&gt;r);\t\t\t\treturn;\t\t&#125;\t\telse if (p-&gt;date &gt; date)\t\t&#123;\t\t\t_insert(date, p-&gt;l);\t\t\t\treturn;\t\t&#125;\t&#125;\t//先序\tvoid _preTravel(Node* root)\t&#123;\t\tif (root==NULL)\t\t&#123;\t\t\treturn;\t\t&#125;\t\tcout &lt;&lt; root-&gt;date &lt;&lt; &quot; &quot;;\t\t_preTravel(root-&gt;l);\t\t_preTravel(root-&gt;r);\t&#125;\t//中序\tvoid _midTravel(Node* root)\t&#123;\t\tif (root == NULL)\t\t&#123;\t\t\treturn;\t\t&#125;\t\t_midTravel(root-&gt;l);\t\tcout &lt;&lt; root-&gt;date &lt;&lt; &quot; &quot;;\t\t_midTravel(root-&gt;r);\t&#125;\t//后序\tvoid _lstTravel(Node* root)\t&#123;\t\tif (root == NULL)\t\t&#123;\t\t\treturn;\t\t&#125;\t\t_lstTravel(root-&gt;l);\t\t_lstTravel(root-&gt;r);\t\tcout &lt;&lt; root-&gt;date &lt;&lt; &quot; &quot;;\t&#125;\t//清除树\tvoid _close(Node* p)\t&#123;\t\tif (p==NULL)\t\t&#123;\t\t\treturn;\t\t&#125;\t\t_close(p-&gt;l);\t\t_close(p-&gt;r);\t\tdelete p;\t\tp = NULL;\t&#125;\t//查找\tNode* _findNode(T date,Node* p)\t&#123;\t\tif (p-&gt;date==date)\t\t&#123;\t\t\treturn p;\t\t&#125;\t\tif (p-&gt;r == NULL &amp;&amp; p-&gt;l == NULL)\t\t&#123;\t\t\treturn NULL;\t\t&#125;\t\tif (p-&gt;date &gt; date)\t\t&#123;\t\t\treturn _findNode(date, p-&gt;l);\t\t&#125;\t\telse\t\t&#123;\t\t\treturn _findNode(date, p-&gt;r);\t\t&#125;\t&#125;public:\tMytree()\t&#123;\t\tp = NULL;\t&#125;\t~Mytree()\t&#123;\t\t_close(p);\t&#125;\t//插入树\tvoid insert(T date)\t&#123;\t\t_insert(date, p);\t&#125;\t//遍历\t//遍历  type为-1 先序 type为0 中序 type为1 后序\tvoid travel(int type)\t&#123;\t\tswitch (type)\t\t&#123;\t\tcase -1: cout &lt;&lt; &quot;先序：&quot;; _preTravel(p); cout &lt;&lt; endl;\t\t\tbreak;\t\tcase 0: cout &lt;&lt; &quot;中序：&quot;; _midTravel(p); cout &lt;&lt; endl;\t\t\tbreak;\t\tcase 1:cout &lt;&lt; &quot;后序：&quot;; _lstTravel(p); cout &lt;&lt; endl;\t\t\tbreak;\t\t&#125;\t&#125;\t//查找\tNode* findNode(T date)\t&#123;\t\tNode* ps = _findNode(date, p);\t\tif (ps)\t\t&#123;\t\t\tcout &lt;&lt; &quot;找到了！&quot; &lt;&lt; endl;\t\t\treturn ps;\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; &quot;没找到！&quot; &lt;&lt; endl;\t\t\treturn NULL;\t\t&#125;\t&#125;\t//删除\tvoid deleteNode(T data)\t&#123;\t\tNode* root= _findNode(data, p);\t\tif (root==NULL)\t\t&#123;\t\t\tcout &lt;&lt; &quot;删除失败，没找到&quot; &lt;&lt; endl;\t\t\treturn;\t\t&#125;\t\t//判断根节点，干节点\t\tNode* pd = NULL;\t\tif (root==this-&gt;p)\t\t&#123;\t\t\tpd = this-&gt;p;\t\t\tif (root-&gt;r!=NULL)\t\t\t&#123;\t\t\t\t//把左边的放在右边第一个的最左边\t\t\t\tNode* ps = root-&gt;r;\t\t\t\twhile (ps-&gt;l)\t\t\t\t&#123;\t\t\t\t\tps = ps-&gt;l;\t\t\t\t&#125;\t\t\t\tthis-&gt;p = root-&gt;r;\t\t\t\tps-&gt;l = root-&gt;l;\t\t\t\tdelete pd;\t\t\t\treturn;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tthis-&gt;p = root-&gt;l;\t\t\t\tdelete pd;\t\t\t\treturn;\t\t\t&#125;\t\t&#125;\t      //不是根节点\t\t //把左边的放在右边第一个的最左边\t\tNode* Prevpd = NULL;\t\tpd = this-&gt;p;\t\twhile (pd!=root)\t\t&#123;\t\t\tPrevpd = pd;\t\t\tif (pd-&gt;date&gt;root-&gt;date)\t\t\t&#123;\t\t\t\tpd = pd-&gt;l;\t\t\t&#125;\t\t\telse if (pd-&gt;date &lt; root-&gt;date)\t\t\t&#123;\t\t\t\tpd = pd-&gt;r;\t\t\t&#125;\t\t&#125;\t\tpd = root;\t\tif (root==Prevpd-&gt;l)\t\t&#123;//删除的是左边的\t\t\tif (root-&gt;r!=NULL)\t\t\t&#123;//右边有枝\t\t\t//把左边的放在右边第一个的最左边\t\t\t\tNode* ps = root-&gt;r;\t\t\t\twhile (ps-&gt;l)\t\t\t\t&#123;\t\t\t\t\tps = ps-&gt;l;\t\t\t\t&#125;\t\t\t\tPrevpd-&gt;l= root-&gt;r;\t\t\t\tps-&gt;l = root-&gt;l;\t\t\t\tdelete pd;\t\t\t\treturn;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tPrevpd-&gt;l = root-&gt;l;\t\t\t\tdelete pd;\t\t\t\treturn;\t\t\t&#125;\t\t&#125;\t\telse if(root == Prevpd-&gt;r)\t\t&#123;//删除的是右边的\t\t\tif (root-&gt; r!= NULL)\t\t\t&#123;//右边有枝\t\t\t//把左边的放在右边第一个的最左边\t\t\t\tNode* ps = root-&gt;r;\t\t\t\twhile (ps-&gt;l)\t\t\t\t&#123;\t\t\t\t\tps = ps-&gt;l;\t\t\t\t&#125;\t\t\t\tPrevpd-&gt;r = root-&gt;r;\t\t\t\tps-&gt;l = root-&gt;l;\t\t\t\tdelete pd;\t\t\t\treturn;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tPrevpd-&gt;r = root-&gt;r;\t\t\t\tdelete pd;\t\t\t\treturn;\t\t\t&#125;\t\t&#125;\t\t&#125;&#125;;\n\n深度寻路算法\n需要用到栈，所以🤤\n\n#include&lt;memory&gt;template&lt;class T&gt;class Mystand&#123;private:\tT* p;\tint len;\tint maxlen;public:\tMystand()\t&#123;\t\tlen = maxlen = 0;\t\t\tp = NULL;\t&#125;\t~Mystand()\t&#123;\t\tif (p)\t\t&#123;\t\t\tdelete p;\t\t&#125;\t\tlen = maxlen = 0;\t&#125;\t//插入\tvoid push(T i)\t&#123;\t\t//判断是否需要新开内存\t\tif (maxlen&lt;=len)\t\t&#123;\t\t\t//计算开辟的内存大小-&gt;当不足1的时候就是1大于1的时候就这1.5\t\t\tmaxlen=maxlen+ (((maxlen &gt;&gt; 1) &gt; 1) ? (maxlen &gt;&gt; 1) : 1);\t\t\t//开内存\t\t\tT* t = new T[maxlen];\t\t\tif (p)\t\t\t&#123;\t\t\t\tmemcpy(t, p, sizeof(T) * len);\t\t\t\tdelete[] p;\t\t\t&#125;\t\t\tp = t;\t\t&#125;\t\tp[len++]=i;\t&#125;\t//删除\tvoid pop()\t&#123;\t\tif (len &gt; 0) len--;\t&#125;\t//返回顶端元素\tT GetTop()\t&#123;\t\treturn p[len-1];\t &#125;\t//判断栈是否为空\tbool isEmpty()\t&#123;\t\tif (len==0)\t\t&#123;\t\t\treturn true;\t\t&#125;\t\treturn false;\t&#125;&#125;;\n\n\n这就是栈啦，很简单，比顺序表简单。主意在删除功能中，我们是不用释放内存的，因为我们本来就是要设置内存是大于存储大小的，当需要加入元素的时候可以很好的直接改变元素就行\n\n#include &lt;iostream&gt;#include&lt;Windows.h&gt;#include&quot;栈.h&quot;using namespace std;#define ROWS 10#define COLS 10enum direct&#123;_up=0,_right,_down,_left&#125;;//每个地图节点状态struct pathNode&#123;\tint     dir;\tbool\tisFind;\t//false 0 没有走过  true 1 走过-&gt;方便初始化&#125;;//点类型struct MyPoint&#123;\tint row;\tint cols;\tbool operator ==(MyPoint p1)\t&#123;\t\tif (row == p1.row &amp;&amp; cols == p1.cols) return true;\t\treturn false;\t&#125;&#125;;//绘图void printMap(int map[ROWS][COLS], MyPoint pos) &#123;\tsystem(&quot;cls&quot;);\tfor (int i = 0; i &lt; ROWS; i++) &#123;\t\tfor (int j = 0; j &lt; COLS; j++) &#123;\t\t\tif (i == pos.row &amp;&amp; j == pos.cols) &#123;\t\t\t\tprintf(&quot;人&quot;);\t\t\t&#125;\t\t\telse if (1 == map[i][j]) &#123;\t\t\t\tprintf(&quot;墙&quot;);\t\t\t&#125;\t\t\telse if (0 == map[i][j]) &#123;\t\t\t\tprintf(&quot;  &quot;);\t\t\t&#125;\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;int main()&#123;    //创建地图\tint map[ROWS][COLS] = &#123;\t\t&#123; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 &#125;,\t\t&#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 &#125;,\t\t&#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 &#125;,\t\t&#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 &#125;,\t\t&#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 &#125;,\t\t&#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 &#125;,\t\t&#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 &#125;,\t\t&#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 &#125;,\t    &#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 &#125;,\t\t&#123; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 &#125;\t&#125;;\t//初始化辅助地图\tpathNode pathMap[ROWS][COLS] = &#123; 0 &#125;;\t//创建一个栈\tMystand&lt;MyPoint&gt; stand;\tMyPoint begPos = &#123; 1, 1 &#125;;//起点\tMyPoint endPos = &#123; 8, 1 &#125;;//终点\t//起始点入栈\tstand.push(begPos);\t//标记走过的点\tpathMap[begPos.row][begPos.cols].isFind = true;\t//当前位置\tMyPoint nowp = begPos;\t//探索位置\tMyPoint text;\t//是否着找到终点\tbool YesorNo = false;\twhile (1)\t&#123;//循环寻路\t\t//找探索点\t\ttext = nowp;\t\t//判断所在的点的方向\t\tswitch (pathMap[nowp.row][nowp.cols].dir)\t\t&#123;\t\tcase _up:\t\t\ttext.row--;//探索点\t\t\tpathMap[nowp.row][nowp.cols].dir++;//改变找的方向-&gt;记录当前找的方向的下一个方向\t\t\t//地图是否是路，是否没有走过\t\t\tif (map[text.row][text.cols]==0&amp;&amp;pathMap[text.row][text.cols].isFind==false)\t\t\t&#123;\t\t\t\t//满足条件，直接试探点成为走的点\t\t\t\tnowp = text;\t\t\t\t//地图状态设置\t\t\t\tpathMap[text.row][text.cols].isFind = true;\t\t\t\t//进入栈\t\t\t\tstand.push(nowp);\t\t\t&#125;\t\t\tbreak;\t\tcase _right:\t\t\ttext.cols++;\t\t\tpathMap[nowp.row][nowp.cols].dir++;\t\t\tif (map[text.row][text.cols] == 0 &amp;&amp; pathMap[text.row][text.cols].isFind == false)\t\t\t&#123;\t\t\t\tnowp = text;\t\t\t\tpathMap[text.row][text.cols].isFind = true;\t\t\t\tstand.push(nowp);\t\t\t&#125;\t\t\tbreak;\t\tcase _down:\t\t\ttext.row++;\t\t\tpathMap[nowp.row][nowp.cols].dir++;\t\t\tif (map[text.row][text.cols] == 0 &amp;&amp; pathMap[text.row][text.cols].isFind == false)\t\t\t&#123;\t\t\t\tnowp = text;\t\t\t\tpathMap[text.row][text.cols].isFind = true;\t\t\t\tstand.push(nowp);\t\t\t&#125;\t\t\tbreak;\t\tcase _left:\t\t\ttext.cols--;\t\t\tif (map[text.row][text.cols] == 0 &amp;&amp; pathMap[text.row][text.cols].isFind == false)\t\t\t&#123;\t\t\t\tnowp = text;\t\t\t\tpathMap[text.row][text.cols].isFind = true;\t\t\t\tstand.push(nowp);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//回溯功能\t\t\t\tstand.pop();\t\t\t\tnowp=stand.GetTop();\t\t\t&#125;\t\t\tbreak;\t\t&#125;\t\tSleep(200);\t\tprintMap(map,nowp);\t\t//判断是否找到终点\t\tif (endPos == nowp) &#123;\t\t\tYesorNo = true;\t\t\tbreak;\t\t&#125;\t\t//判断栈是否为空\t\tif (stand.isEmpty()) break;\t&#125;\tint x, y;\tif (YesorNo) \t&#123;\t\tprintf(&quot;找到终点啦!\\n&quot;);\t\twhile (!stand.isEmpty()) &#123;\t\t\ty = stand.GetTop().row; x = stand.GetTop().cols;\t\t\tprintf(&quot;(%d,%d)&quot;, y, x);\t\t\tstand.pop();\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;没有找到终点!\\n&quot;);\t&#125;    return 0;&#125;\n\n\n这是深度寻路算法的核心代码，整体思路很简单，创建一个辅助用的地图，记录每个地图状态，以备需要时调用，然后点是相当于查路的机器人，把可以走的路记录在栈中 地图中。\n这里简单说一下这个代码的逻辑，跟写其他的程序一样，分为4步骤-&gt;创建变量，初始化变量，循环中{ 铺设地图 更新数据 }\n\n广度寻路算法#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;memory&gt;using namespace std;#define ROWS 10#define COLS 10enum &#123;_up=0,_right,_down,_left&#125;;//点struct MyPoint&#123;\tint x;\tint y;\tbool operator==(MyPoint p)\t&#123;\t\treturn (x == p.x &amp;&amp; y == p.y);\t&#125;&#125;;//树的节点struct Mytree&#123;\tMyPoint pos;//坐标\tMytree*  fth;\tvector&lt;Mytree*&gt; p;//指向四周的指针\t//构造函数\tMytree()\t&#123;\t\tfth = NULL;\t&#125;\tMytree(MyPoint p)\t&#123;\t\tfth = NULL;\t\tpos = p;\t&#125;&#125;;int main()&#123;\tint map[ROWS][COLS] = &#123;\t\t&#123; 0, 1, 0, 0, 0, 0, 0, 1, 0, 0 &#125;,\t\t&#123; 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 &#125;,\t\t&#123; 0, 0, 0, 1, 0, 1, 0, 1, 0, 1 &#125;,\t\t&#123; 0, 1, 0, 0, 0, 1, 0, 1, 0, 0 &#125;,\t\t&#123; 0, 1, 0, 1, 0, 0, 0, 1, 1, 0 &#125;,\t\t&#123; 0, 1, 0, 1, 0, 1, 0, 0, 1, 0 &#125;,\t\t&#123; 0, 1, 0, 0, 0, 1, 0, 0, 0, 0 &#125;,\t\t&#123; 0, 1, 0, 1, 0, 0, 0, 1, 1, 0 &#125;,\t\t&#123; 0, 1, 0, 1, 0, 1, 0, 1, 0, 0 &#125;,\t\t&#123; 0, 0, 0, 1, 0, 1, 0, 1, 1, 0 &#125;\t&#125;;\t//辅助地图\tbool pathMap[ROWS][COLS] = &#123; 0 &#125;;\t//设置起始点\tMyPoint begPos = &#123; 0, 0 &#125;;\tMyPoint endPos = &#123; 8, 8 &#125;;\t//创建树\tMytree* tree=new Mytree(begPos);\t//创建两层的数组-&gt;用来记每层又几个元素需要寻路\tvector&lt;Mytree*&gt; cen;\tvector&lt;Mytree*&gt; Nextcen;\t//把根存到第一层去\tcen.push_back(tree);\t//创建需要探索的点\tMyPoint text;\t//跳出多层循环的标志\tbool b=false;\tMytree* p = NULL;\t//寻路\twhile (1)\t&#123;\t\tNextcen.clear();\t\t//遍历每曾的元素\t\tfor (int i = 0; i &lt; cen.size(); i++)\t\t&#123;\t\t\t//标记走过\t\t\tpathMap[cen[i]-&gt;pos.y][cen[i]-&gt;pos.x] = true;\t\t\t//让他们四个方向按个寻找\t\t\tfor (int j = 0; j &lt; 4; j++)\t\t\t&#123;\t\t\t\ttext = cen[i]-&gt;pos;\t\t\t\t//四个方向\t\t\t\tswitch (j)\t\t\t\t&#123;\t\t\t\tcase _up: text.y--;\t\t\t\t\tbreak;\t\t\t\tcase _right: text.x++;\t\t\t\t\tbreak;\t\t\t\tcase _down: text.y++;\t\t\t\t\tbreak;\t\t\t\tcase _left: text.x--;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\t//如果可以走就存树-&gt;不是墙，没有走过，没有越界\t\t\t\tif ((map[text.y][text.x]!=1)&amp;&amp;( pathMap[text.y][text.x]==false)&amp;&amp;\t\t\t\t\t(text.y &gt;= 0 &amp;&amp; text.y &lt;= ROWS &amp;&amp; text.x &gt;= 0 &amp;&amp; text.x &lt;= COLS))\t\t\t\t&#123;\t\t\t\t\t p = new Mytree(text);\t\t\t\t\tp-&gt;fth = cen[i];\t\t\t\t\tcen[i]-&gt;p.push_back(p);\t\t\t\t\tcen.push_back(p);\t\t\t\t\t//判断是否可以跳出循环-&gt;找到终点\t\t\t\t\tif (p-&gt;pos== endPos)\t\t\t\t\t&#123;\t\t\t\t\t\tb = true;\t\t\t\t\t\tbreak;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (b) break;\t\t&#125;\t\tif (b) break;\t\t//没有下一层了\t\tif (Nextcen.size()==0)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\tcen = Nextcen;\t&#125;\tif (b) &#123;\t\tcout &lt;&lt; &quot;找到终点了!&quot; &lt;&lt; endl;\t\twhile (p) &#123;\t\t\tcout &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;pos.y &lt;&lt; &quot;,&quot; &lt;&lt; p-&gt;pos.x &lt;&lt; &quot;)&quot;;\t\t\tp = p-&gt;fth;\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;\telse cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl;    return 0;&#125;\n\n\n相比于深度寻路算法的优缺点：\n\n\n优点是 可以找到最简路线，深度寻路可能有误差\n缺点是耗时长\n\n\n总结是小地图用广度寻路算法，大地图用深度寻路\n\nA星寻路算法#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define ROWS 10#define COLS 10//方位enum &#123;_lup=0,_up,_rup,_l,_r,_ld,_d,_rd &#125;;//点类型struct Mypoint&#123;\t int y;\t int x;\tint f, g, h;\tvoid geth(Mypoint p)\t&#123;\t\tint x1 = ((p.x &gt; x) ? (p.x - x) : (x - p.x));\t\tint y1 = ((p.y &gt; y) ? (p.y - y) : (y - p.y));\t\th = (x1+y1)*10;\t&#125;\tvoid getf()\t&#123;\t\tf = g + h;\t&#125;\tbool operator==(Mypoint p)\t&#123;\t\treturn(p.x == x &amp;&amp; p.y == y);\t&#125;&#125;;//树结构struct tree&#123;\tMypoint pos;\ttree* fth;\tvector&lt;tree*&gt; p;\ttree()\t&#123;\t\tfth = nullptr;\t&#125;\ttree(Mypoint pos)\t&#123;\t\tthis-&gt;pos = pos;\t\tfth = nullptr;\t&#125;&#125;;//判断可以存入的条件bool YesorNo(int map[ROWS][COLS], bool pathmap[ROWS][COLS], Mypoint p)&#123;\tif (p.y&lt;0 || p.y&gt;=ROWS || p.x&lt;0 || p.x&gt;=COLS) return false;\tif (map[p.y][p.x] == 1) return false;\tif (pathmap[p.y][p.x]) return false;\treturn true;&#125;int main()&#123;\t//地图\tint map[ROWS][COLS] = &#123;        &#123; 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 &#125;,\t\t&#123; 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 &#125;,\t\t&#123; 0, 0, 1, 1, 1, 0, 0, 0, 0, 0 &#125;,\t\t&#123; 0, 1, 0, 1, 1, 0, 0, 0, 0, 0 &#125;,\t\t&#123; 0, 1, 1, 0, 1, 0, 0, 0, 0, 0 &#125;,\t\t&#123; 0, 0, 1, 1, 1, 0, 0, 0, 0, 0 &#125;,\t\t&#123; 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 &#125;,\t\t&#123; 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 &#125;,\t\t&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &#125;,\t\t&#123; 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 &#125;\t&#125;;\t//辅助地图\tbool pathMap[ROWS][COLS] = &#123; 0 &#125;;\tMypoint begPos = &#123; 0,0&#125;;//起点2,1\tMypoint endPos = &#123; 6, 7 &#125;;//终点\ttree* Tree = new tree(begPos);\tpathMap[Tree-&gt;pos.y][Tree-&gt;pos.x] = true;\t//存评分点\tvector&lt;tree*&gt; point;\tvector&lt;tree*&gt;::iterator it;\tvector&lt;tree*&gt;::iterator us;\ttree* root=Tree;\ttree* text=NULL;//寻找点\tbool fand = false;\twhile (1)\t&#123;\t\t//八个方位的判断\t\tfor (int i = 0; i &lt; 8; i++)\t\t&#123;\t\t\ttext = new tree(root-&gt;pos);\t\t\t//找到不同方位测试点并评分\t\t\tswitch (i)\t\t\t&#123;\t\t\tcase _lup: text-&gt;pos.y--; text-&gt;pos.x--; text-&gt;pos.g += 14;\t\t\tbreak;\t\t\tcase _up:text-&gt;pos.y--; text-&gt;pos.g += 10;\t\t\tbreak;\t\t\tcase _rup:text-&gt;pos.y--; text-&gt;pos.x++; text-&gt;pos.g += 14;\t\t\tbreak;\t\t\tcase _l:text-&gt;pos.x--; text-&gt;pos.g += 10;\t\t\tbreak;\t\t\tcase _r:text-&gt;pos.x++; text-&gt;pos.g += 10;\t\t\tbreak;\t\t\tcase _ld:text-&gt;pos.y++; text-&gt;pos.x--; text-&gt;pos.g += 14;\t\t\tbreak;\t\t\tcase _d:text-&gt;pos.y++; text-&gt;pos.g += 10;\t\t\tbreak;\t\t\tcase _rd:text-&gt;pos.y++; text-&gt;pos.x++; text-&gt;pos.g += 14;\t\t\tbreak;\t\t\t&#125;\t\t\tif (YesorNo( map,pathMap, text-&gt;pos))\t\t\t&#123;\t\t\t\t//计算f值\t\t\t\ttext-&gt;pos.geth(endPos);\t\t\t\ttext-&gt;pos.getf();\t\t\t\t//入树\t\t\t\troot-&gt;p.push_back(text);\t\t\t\ttext-&gt;fth = root;\t\t\t\t//存入数组\t\t\t\tpoint.push_back(text);\t\t\t\t//标记走过\t\t\t\tpathMap[text-&gt;pos.y][text-&gt;pos.x] = true;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tdelete text;\t\t\t\ttext = nullptr;\t\t\t&#125;\t\t&#125;\t\tif (point.size() == 0)break;\t\t//找到分最少\t\tus= point.begin();\t\tfor (it= point.begin();it!= point.end();it++)\t\t&#123;\t\t\tus = (((*it)-&gt;pos.f &lt; (*us)-&gt;pos.f) ? it : us);\t\t&#125;\t\t//确定当前点\t\troot = *us;\t\t\t//数组中删掉\t\tpoint.erase(us);\t\t//结束条件\t\tif (root-&gt;pos == endPos) &#123; fand = true; break; &#125;\t\t&#125;\t//如果找到终点了，打印路径\tif (fand) &#123;\t\tcout &lt;&lt; &quot;找到终点啦!&quot; &lt;&lt; endl;\t\twhile (root) &#123;\t\t\tcout &lt;&lt; &quot;(&quot; &lt;&lt; root-&gt;pos.y &lt;&lt; &quot;,&quot; &lt;&lt;\t\t\t\troot-&gt;pos.x &lt;&lt; &quot;)&quot;;\t\t\troot = root-&gt;fth;\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;木有找到终点&quot; &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n\n结合了广度和深度的优点，贪心类似\n\n堆\n树结构有，二叉树，满二叉树，完全二叉树，先了解树才可以学习堆\n\n满二叉树：同时满足如下两个条件的二叉树\t1. 要么有两个孩子，要么没有孩子\t2. 叶子节点在同一层\t满二叉树有如下规律：\t如果层数为n\t第n层节点数  一定为  2^(n-1)\t整颗树节点数  为   2^n - 1完全二叉树\t满二叉树 从 下边 右边开始删节点 \t从右往左  从下往上 （和 阅读顺序 相反）\t\t满二叉树一定是完全二叉树\t完全二叉树不一定是满二叉树堆：有序的完全二叉树\t父子之间有序  兄弟之间  其他节点之间 不管    父大于子：最大堆 (大顶堆)    父小于子：最小堆 (小顶堆)已知父节点下标为N左孩子下标为：2*N + 1右孩子下标为：2*N + 2已知左孩子下标为M 父节点下标为： (M-1)/2已知右孩子下标为M 父节点下标为： (M-2)/2已知孩子下标为M 父节点下标为： (M-1)/2\n\n\n以上是堆的公式\n\ntemplate&lt;class T&gt;class  MyHeap&#123;private:\tT* p;\tint len;\tint maxlen;public:\tMyHeap()\t&#123;\t\tp = NULL;\t\tlen = maxlen = 0;\t &#125;\t~MyHeap()\t&#123;\t\tif (p)\t\t&#123;\t\t\tdelete[] p;\t\t&#125;\t\tp = NULL;\t\tlen = maxlen = 0;\t&#125;\t//插入\tvoid puch(T data)\t&#123;\t\t//判断是否需要新开内存\t\tif (maxlen &lt;= len)\t\t&#123;\t\t\t//计算开辟的内存大小-&gt;当不足1的时候就是1大于1的时候就这1.5\t\t\tmaxlen = maxlen + (((maxlen &gt;&gt; 1) &gt; 1) ? (maxlen &gt;&gt; 1) : 1);\t\t\t//开内存\t\t\tT* t = new T[maxlen];\t\t\tif (p)\t\t\t&#123;\t\t\t\tmemcpy(t, p, sizeof(T) * len);\t\t\t\tdelete[] p;\t\t\t&#125;\t\t\tp = t;\t\t&#125;\t\tp[len++] = data;\t\t\t//再排序\t\tint t1 = len - 1;\t\tint t2;\t\twhile (1)\t\t&#123;\t\t\tif (t1&lt;= 0)break;\t\t\tt2 = (t1 - 1) / 2;\t\t\tif (p[t1] &gt; p[t2])\t\t\t&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//交换\t\t\t\tT temp = p[t1];\t\t\t\tp[t1] = p[t2];\t\t\t\tp[t2] = temp;\t\t\t\t//往上移\t\t\t\tt1 =t2;\t\t\t&#125;\t\t&#125;    &#125;\t//遍历\tvoid travel()\t&#123;\t\tcout &lt;&lt; &quot;堆里数据 : &quot;;\t\t\tfor (int i = 0; i &lt; len; i++)\t\t\t&#123;\t\t\t\tcout &lt;&lt; p[i] &lt;&lt; &quot; &quot;;\t\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;\t//删除根节点\tvoid Mydelete()\t&#123;\t\tif (len==0)\t\t&#123;\t\t\tcout &lt;&lt; &quot;堆是空的&quot; &lt;&lt; endl;\t\t\treturn;\t\t&#125;\t\tif (len==1)\t\t&#123;\t\t\tdelete[] p;\t\t\tp = nullptr;\t\t\tlen--;\t\t\tcout &lt;&lt; &quot;堆已清空&quot; &lt;&lt; endl;\t\t\treturn;\t\t&#125;\t\tp[0] = p[len - 1];\t\tint t1 =0;\t\tint t2;\t\twhile (1)\t\t&#123;\t\t\t//数组结束 \t\t\tif ((t1 * 2 + 1) &gt; (len - 1) || (t1 * 2 + 2) &gt; (len - 1))break;\t\t\tt2 = t1 * 2 + 1;\t\t\tif (t2 &gt; (t1 * 2 + 2))\t\t\t&#123;\t\t\t\tt2 = (t1 * 2 + 2);\t\t\t&#125;\t\t\t//交换\t\t\tT temp = p[t1];\t\t\tp[t1] = p[t2];\t\t\tp[t2] = temp;\t\t\tt1 = t2;\t\t&#125;\t\tlen--;\t&#125;&#125;;\n\n\n再写代码的时候发现了很有趣的东西，就是判断符号：（条件）？1：2，这个东西要是一连套的需要用一个括号阔上，否者会出bug\n\n平衡二叉树//节点template&lt;class T&gt;struct spot&#123;\tT datas;//数据\tspot* lp;//左节点\tspot* rp;//右节点\tint len;//高度\tspot(T dates)\t&#123;\t\tthis-&gt;datas = dates;\t\tlp = rp = NULL;\t\tlen = 0;\t&#125;&#125;;template&lt;class T&gt;class ALVtree&#123;public:\tALVtree()\t&#123;\t\tthis-&gt;p = NULL;\t&#125;\t~ALVtree()\t&#123;\t&#125;\t//插入\tvoid init(T num)\t&#123;\t\t_init(this-&gt;p, num);\t&#125;private:\tspot&lt;T&gt;* p;\t//获得节点高度\tint  _getlen(spot&lt;T&gt;* p)\t&#123;\t\tif (p) &#123; return p-&gt;len; &#125;\t\telse return 0;\t&#125;\tvoid _init(spot&lt;T&gt;*&amp; p, T num)\t&#123;\t\t//首先像有序二叉树一样\t\tif (p == NULL)\t\t&#123;\t\t\tp = new spot&lt;T&gt;(num);\t\t&#125;\t\telse if (p-&gt;datas &gt; num)\t\t&#123;\t\t\t_init(p-&gt;lp, num);\t\t\t//然后再旋转\t\t\t//判断是什么旋转\t\t\tif (_getlen(p-&gt;lp) - _getlen(p-&gt;rp) &gt; 1)\t\t\t&#123;\t\t\t\tif (p-&gt;lp-&gt;datas &gt; num)\t\t\t\t&#123;\t\t\t\t\tp = r(p);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tp = lr(p);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\telse \t\t&#123;\t\t\t_init(p-&gt;rp, num);\t\t\t//然后再旋转\t\t\t//判断是什么旋转\t\t\tif (_getlen(p-&gt;rp) - _getlen(p-&gt;lp) &gt; 1)\t\t\t&#123;\t\t\t\tif (p-&gt;rp-&gt;datas &gt; num)\t\t\t\t&#123;\t\t\t\t\tp = l(p);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tp = rl(p);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t//最后设置高度\t\tint leftHeight = _getlen(p-&gt;lp);\t\tint rightHeight = _getlen(p-&gt;rp);\t\tp-&gt;len = 1 + (\t\t\t(leftHeight &gt; rightHeight) ? leftHeight : rightHeight\t\t\t);\t&#125;\t//右旋\tspot&lt;T&gt;* r(spot&lt;T&gt;* p)\t&#123;\t\t//保存数据\t\tspot&lt;T&gt;* temp = p-&gt;lp;\t\t//旋转\t\tp-&gt;lp = temp-&gt;rp;\t\ttemp-&gt;rp = p;\t\t//设置高度\t\tp-&gt;len = 1 + ((_getlen(p-&gt;lp) &gt; _getlen(p-&gt;rp)) ? _getlen(p-&gt;lp) : _getlen(p-&gt;rp));\t\ttemp-&gt;len = 1 + ((_getlen(temp-&gt;lp) &gt; _getlen(temp-&gt;rp)) ? _getlen(temp-&gt;lp) : _getlen(temp-&gt;rp));\t\treturn temp;\t&#125;\t//左旋\tspot&lt;T&gt;* l(spot&lt;T&gt;* p)\t&#123;\t\t//保存数据\t\tspot&lt;T&gt;* temp = p-&gt;rp;\t\t//旋转\t\tp-&gt;rp = temp-&gt;lp;\t\ttemp-&gt;lp = p;\t\t//设置高度\t\tp-&gt;len = 1 + ((_getlen(p-&gt;lp) &gt; _getlen(p-&gt;rp)) ? _getlen(p-&gt;lp) : _getlen(p-&gt;rp));\t\ttemp-&gt;len = 1 + ((_getlen(temp-&gt;lp) &gt; _getlen(temp-&gt;rp)) ? _getlen(temp-&gt;lp) : _getlen(temp-&gt;rp));\t\treturn temp;\t&#125;\t//左右旋\tspot&lt;T&gt;* lr(spot&lt;T&gt;* p)\t&#123;\t\tp-&gt;lp = l(p-&gt;lp);\t\treturn r(p);\t&#125;\t//右左旋\tspot&lt;T&gt;* rl(spot&lt;T&gt;* p)\t&#123;\t\tp-&gt;rp = r(p-&gt;rp);\t\treturn l(p);\t&#125;&#125;;\n\n\n主意在保存数据的时候传参要用引用\n\n23树template&lt;class T&gt;class My23tree&#123;private:\tstruct Node\t&#123;\t\tint type;//识别当前节点是及节点类型的0，2，3，4\t\tT data[3];//存入数据的个数\t\tNode* p[4];//指针的个数\t\tNode()\t\t&#123;\t\t\ttype = 0;\t\t\tmemset(data, 0, sizeof(T) * 3);\t\t\tmemset(p, 0, sizeof(Node*) * 4);//这个函数是创建一个对象，然后把里面的值都初始化为零\t\t&#125;\t&#125;;\tNode* TreeNode;\tvoid _insert(T t, Node* p, Node* onp)\t&#123;\t\tif (p-&gt;type==0)//当节点是0指针的时候\t\t&#123;\t\t\tp-&gt;data[0] = t;\t\t\tp-&gt;type = 2;\t\t\treturn;\t\t&#125;\t\t if (p-&gt;type==2)//当节点是2指针的时候\t\t&#123;\t\t\tif (p-&gt;data[1]&lt;t)//当数据大于第一个数据的时候\t\t\t&#123;\t\t\t\tif (p-&gt;p[0])//当数据有左孩子的时候放到右节点\t\t\t\t&#123;\t\t\t\t\t_insert(t, p-&gt;p[1], p);\t\t\t\t&#125;\t\t\t\telse//没有左孩子直接放到旁边\t\t\t\t&#123;\t\t\t\t\tp-&gt;data[1] = t;\t\t\t\t\tp-&gt;type = 3;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tif (p-&gt;p[0])//当数据有左孩子的时候放到右节点\t\t\t\t&#123;\t\t\t\t\t_insert(t, p-&gt;p[0], p);\t\t\t\t&#125;\t\t\t\telse//没有左孩子直接放到旁边\t\t\t\t&#123;\t\t\t\t\tp-&gt;data[1] = p-&gt;data[0];\t\t\t\t\tp-&gt;data[0] = t;\t\t\t\t\tp-&gt;type = 3;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\telse//当节点是3指针的时候\t\t&#123;\t\t\tif (p-&gt;data[0]&gt;t)//插左边\t\t\t&#123;\t\t\t\tif (p-&gt;p[0])//有孩子\t\t\t\t&#123;\t\t\t\t\t_insert(t, p-&gt;p[0], p);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tp-&gt;data[2] = p-&gt;data[1];\t\t\t\t\tp-&gt;data[1] = p-&gt;data[0];\t\t\t\t\tp-&gt;data[0] = t;\t\t\t\t\tp-&gt;type++;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse if (p-&gt;data[1] &gt; t&amp;&amp;p-&gt;data[0] &lt; t)//插中间\t\t\t&#123;\t\t\t\tif (p-&gt;p[1])//有孩子\t\t\t\t&#123;\t\t\t\t\t_insert(t, p-&gt;p[1], p);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tp-&gt;data[2] = p-&gt;data[1];\t\t\t\t\tp-&gt;data[1] = t;\t\t\t\t\tp-&gt;type++;\t\t\t\t&#125;\t\t\t&#125;\t\t\telse if (p-&gt;data[2] &lt; t)//插右边\t\t\t&#123;\t\t\t\tif (p-&gt;p[2])//有孩子\t\t\t\t&#123;\t\t\t\t\t_insert(t, p-&gt;p[2], p);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tp-&gt;data[2] = t;\t\t\t\t\tp-&gt;type++;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tif (p-&gt;type==4)//当节点是4指针的时候\t\t&#123;\t\t\t//创建两个节点\t\t\tNode* node1 = new Node;\t\t\tNode* node2 = new Node;\t\t\tnode1-&gt;data[0] = p-&gt;data[0];\t\t\tnode1-&gt;p[0] = p-&gt;p[0];\t\t\tnode1-&gt;p[1] = p-&gt;p[1];\t\t\tnode1-&gt;type = 2;\t\t\tnode2-&gt;data[0] = p-&gt;data[2];\t\t\tnode2-&gt;p[0] = p-&gt;p[2];\t\t\tnode2-&gt;p[1] = p-&gt;p[3];\t\t\tnode2-&gt;type = 2;\t\t\tT ts = p-&gt;data[1];//临时存储中间数据\t\t\tif (onp)\t\t\t&#123;\t\t\t\t//5 找位置 做插入\t\t\t\tif (ts&lt; onp-&gt;data[0]) &#123;//左边\t\t\t\t\tif (onp-&gt;p[2]) &#123;//最右边有孩子\t\t\t\t\t\tonp-&gt;data[2] = onp-&gt;data[1];\t\t\t\t\t\tonp-&gt;data[1] = onp-&gt;data[0];\t\t\t\t\t\tonp-&gt;data[0] = ts;\t\t\t\t\t\tonp-&gt;p[3] = onp-&gt;p[2];\t\t\t\t\t\tonp-&gt;p[2] = onp-&gt;p[1];\t\t\t\t\t\tonp-&gt;p[1] = node2;\t\t\t\t\t\tonp-&gt;p[0] = node1;\t\t\t\t\t&#125;\t\t\t\t\telse if (onp-&gt;p[1]) &#123;//最右边没有孩子，中间有孩子\t\t\t\t\t\tonp-&gt;data[1] = onp-&gt;data[0];\t\t\t\t\t\tonp-&gt;data[0] = ts;\t\t\t\t\t\t\t\t\t\t\t\tonp-&gt;p[2] = onp-&gt;p[1];\t\t\t\t\t\tonp-&gt;p[1] = node2;\t\t\t\t\t\tonp-&gt;p[0] = node1;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\telse if (2 == onp-&gt;type ||\t\t\t\t\t(onp-&gt;type &gt; 1)\t\t\t\t\t&amp;&amp;\t\t\t\t\tts &lt; onp-&gt;data[1]) &#123;//中间\t\t\t\t\tif (onp-&gt;p[2]) &#123;//最右边有孩子\t\t\t\t\t\tonp-&gt;data[2] = p-&gt;data[1];\t\t\t\t\t\tonp-&gt;data[1] = ts;\t\t\t\t\t\t\t\t\t\t\t\tonp-&gt;p[3] = onp-&gt;p[2];\t\t\t\t\t\tonp-&gt;p[2] = node2;\t\t\t\t\t\tonp-&gt;p[1] = node1;\t\t\t\t\t&#125;\t\t\t\t\telse if (onp-&gt;p[1]) &#123;//最右边没有孩子，中间有孩子\t\t\t\t\t\tonp-&gt;data[1] = ts;\t\t\t\t\t\tonp-&gt;p[2] = node2;\t\t\t\t\t\tonp-&gt;p[1] = node1;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\telse if (3 == onp-&gt;type ||\t\t\t\t\t(onp-&gt;type &gt; 2) &amp;&amp; (ts&lt; onp-&gt;data[2])) &#123;//右边\t\t\t\t\tif (onp-&gt;p[2]) &#123;\t\t\t\t\t\tonp-&gt;data[2] = ts;\t\t\t\t\t\tonp-&gt;p[3] = node2;\t\t\t\t\t\tonp-&gt;p[2] = node1;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tonp-&gt;type++;\t\t\t\t//6 释放内存\t\t\t\tdelete p;\t\t\t&#125;\t\t\telse//当前是没有父节点\t\t\t&#123;\t\t\t\tmemset(p-&gt;data, 0, sizeof(T) * 3);\t\t\t\tmemset(p-&gt;p, 0, sizeof(Node*) * 4);\t\t\t\tp-&gt;data[0] = ts;\t\t\t\tp-&gt;type = 2;\t\t\t\tp-&gt;p[0] = node1;\tp-&gt;p[1] = node2;\t\t\t&#125;\t\t&#125;\t&#125;public:\tMy23tree() &#123; TreeNode = nullptr; &#125;\t~My23tree()&#123;&#125;\tvoid insert(T t)\t&#123;\t\tif (TreeNode)\t\t&#123;\t\t\t_insert(t, TreeNode, NULL);\t\t&#125;\t\telse\t\t&#123;\t\t\tTreeNode = new Node();\t\t\tTreeNode-&gt;data[0] = t;\t\t\tTreeNode-&gt;type = 2;\t\t&#125;\t&#125;&#125;;\n\n图class Mymap&#123;private:\t//网图-&gt;可以是有向图\t//顶点元素个数\tint num;\t//元素名字\tchar* element;\t//网格-&gt;可以是带权图\tint** arr;\t//辅助数组\tbool isFind[100] = &#123; 0 &#125;;public:\tMymap(int num,char* v)\t&#123;\t\tthis-&gt;num = num;\t\telement = new char[num + 1];\t\tmemcpy(element, v, sizeof(char) * num);\t\tarr = new int* [num];\t\tfor (int i = 0; i &lt; num; i++)\t\t&#123;\t\t\tarr[i] = new int[num];\t\t\tmemset(arr[i], 0, sizeof(int) * num);\t\t&#125;\t\t//自行判断是否越界\t\tcout &lt;&lt; &quot;输入顶点之间关系,输入#结束输入 &gt; &quot; &lt;&lt; endl;\t\tint t = 0;\t\twhile (true)\t\t&#123;\t\t\tchar b[5] = &#123; 0 &#125;; \t\t\tcout &lt;&lt; &quot;第&quot; &lt;&lt; t + 1 &lt;&lt; &quot;次 &quot;;\t\t\tcin &gt;&gt; b;\t\t\tif (b[0]==&#x27;#&#x27;)\t\t\t&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\tt++;\t\t\tint _1 = getSubscript(b[0]);\t\t\tint _2 = getSubscript(b[3]);\t\t\tarr[_1][_2] = 1;\t\t\t//无向边再加一个\t\t\t//arr[_2][_1] = 1;\t\t&#125;\t&#125;\t~Mymap()\t&#123;\t\tdelete[] element;\t\tfor (int i = 0; i &lt; num; i++)\t\t&#123;\t\t\tdelete[] arr[i];\t\t&#125;\t\tdelete[] arr;\t&#125;\t//显示地图\tvoid show()\t&#123;\t\tfor (int i = 0; i &lt;= num; i++)\t\t&#123;\t\t\tfor (int j = 0; j &lt;= num; j++)\t\t\t&#123;\t\t\t\tif (i == 0 &amp;&amp; j == 0)\t\t\t\t&#123;\t\t\t\t\tcout &lt;&lt; &quot; &quot;;\t\t\t\t&#125;\t\t\t\telse if (i == 0)\t\t\t\t&#123;\t\t\t\t\tcout &lt;&lt;element[j-1];\t\t\t\t&#125;\t\t\t\telse if (j == 0)\t\t\t\t&#123;\t\t\t\t\tcout &lt;&lt; element[i - 1];\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tcout &lt;&lt; arr[i-1][j-1];\t\t\t\t&#125;\t\t\t&#125;\t\t\tcout &lt;&lt; endl;\t\t&#125;\t&#125;\t//字符转化为下标\tint getSubscript(char s)\t&#123;\t\tfor (int i = 0; i &lt; num; i++)\t\t&#123;\t\t\tif (element[i]==s)\t\t\t&#123;\t\t\t\treturn i;\t\t\t&#125;\t\t&#125;\t\treturn -1;\t&#125;\t//深度优先遍历\tvoid DFS(char A)//从哪个顶点开始遍历\t&#123;\t\tint a = getSubscript(A);//获得开始顶点的下标\t\tisFind[a] = 1;\t\t\twhile(1)\t\t&#123;\t\t\tint w = getFirstVertex(a);//获得下一顶点的坐标\t\t\tif (w==-1)\t\t\t&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\tif (!isFind[w])\t\t\t&#123;\t\t\t\tcout &lt;&lt; element[w] &lt;&lt; &quot; &quot;;\t\t\t\tDFS(element[w]);\t\t\t&#125;\t\t&#125;\t&#125;\t//广度优先遍历\tvoid BFS(char A)//从哪个边开始遍历\t&#123;\t\t//选的顶点先入队列\t\tint a = getSubscript(A);\t\tqueue&lt;int&gt; q;\t\tq.push(a);\t\tisFind[a] = 1;\t\twhile (!q.empty())//判断不是空的\t\t&#123;\t\t\t//获得队列头，并删掉\t\t\tint hand = q.front();\t\t\tq.pop();\t\t\t//把相邻的顶点都放到队列里\t\t\twhile (1)\t\t\t&#123;\t\t\t\tint w = getFirstVertex(hand);//获得下一顶点的坐标\t\t\t\tif (w==-1)\t\t\t\t&#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\tif (!isFind[w])\t\t\t\t&#123;\t\t\t\t\tisFind[w] = 1;\t\t\t\t\tcout &lt;&lt; element[w] &lt;&lt; &quot; &quot;;\t\t\t\t\tq.push(w);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\t//获得下一个没选过的顶点左边\tint getFirstVertex(int beg)\t&#123;\t\tfor (int i = 0; i &lt; num; i++)\t\t&#123;\t\t\tif (isFind[i])continue;\t\t\tif (arr[beg][i]==1)\t\t\t&#123;\t\t\t\treturn i;\t\t\t&#125;\t\t&#125;\t\treturn -1;\t&#125;\tvoid travel(char A,bool isD = true) &#123;\t\tmemset(isFind, 0, sizeof(bool) * 100);\t\tif (isD) &#123;\t\t\tprintf(&quot;深度优先遍历:%c &quot;, A);\t\t\tDFS(A);\t\t\tprintf(&quot;\\n&quot;);\t\t&#125;\t\telse &#123;\t\t\tprintf(&quot;广度优先遍历:%c &quot;,A);\t\t\tBFS(A);\t\t\tprintf(&quot;\\n&quot;);\t\t&#125;\t&#125;\t&#125;;\n\n图有三种的构造形式，有矩阵，链节，还有邻接图，这次用的是邻接图。\nB树，B+树，红黑树，哈夫曼树B树：23树就是M&#x3D;3的B树。\nB+树：在B树上有两个新优势，1.每次的变型，父节点不再存数据，数据位置没变，而是父节点存的是编号，或者是数据地址，2.每层都有指针把每个数据都连接在一起，像一个链表一样。\n哈夫曼树：又叫最佳搜索树，他是让值最小的方法存储在二叉树里，数据存在叶子节点里，压缩等就用到了此数据结构。，数据编码成哈夫曼编码，然后进行压缩，解压也是由哈夫曼编码从新生成的。\n红黑树：是继平衡二叉树之后，一个增删效率很高的树，但是他并不是十分的平衡-&gt;适当降低平衡性（查找效率），提升增删效率。规则：  1.  根节点和叶子节点是黑色的，干节点是红色的      2.从根节点到空节点每条路径上都有相同数目的黑色叶子节点      3.红黑节点是交替出现的\n字符串查找算法\n爆破查找：\n\nint BF(char* ch1, char* ch2)&#123;\tint i = 0;\tint j = 0;\tint d = 0;\twhile (true)\t&#123;\t\t//判断字符串结束\t\tif (ch1[i]==&#x27;\\0&#x27;||ch2[j]==&#x27;\\0&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;        //判断两个字符串的每一位是否相等\t\tif (ch1[i]==ch2[j])\t\t&#123;\t\t\ti++;\t\t\tj++;\t\t&#125;\t\telse//有不相等的i返回原来的位置再往下移一位，j复原\t\t&#123;\t\t\td++;\t\t\tj = 0;\t\t\ti = d;\t\t&#125;\t&#125;\tif (ch2[j] == &#x27;\\0&#x27;)\t&#123;\t\treturn d;\t&#125;\treturn - 1;&#125;\n\n\nkmp算法\n\n\n在爆破算法上的优化\n\n//我按照老师讲的自己写的：int KMP(char* ch1, char* ch2)&#123;\tint i = 0;\tint j = 0;\tint h1 = strlen(ch1);\tint h2 = strlen(ch2);\tint k=0;\t//判断前面有几个一样的\tfor (int i = 0; i &lt; h2-1; i++)\t&#123;\t\tif (ch2[i]==ch2[i+1])\t\t&#123;\t\t\tk++;\t\t&#125;\t\telse\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\twhile (i &lt; h1 &amp;&amp; j &lt; h2)\t&#123;\t\tif (ch1[i]==ch2[j])//判断俩个字符串的每一个字符是否相同\t\t&#123;\t\t\ti++;\t\t\tj++;\t\t&#125;\t\telse//不相同，往下走\t\t&#123;\t\t\tif (j==0)\t\t\t&#123;              i++;\t\t\t&#125;\t\t\tif (ch1[i] == ch1[i - 1])//判断下面的数是否是相同的字符\t\t\t&#123;\t\t\t\tj = k;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tj = 0;\t\t\t&#125;\t\t&#125;\t&#125;\tif (j==h2)\t&#123;\t\treturn (i-j);\t&#125;\treturn -1;&#125;//老师写的：//创建偏移表的函数void getNext(char* s, int* next)&#123;\tchar* pstr = s;\tint len = strlen(s);\tint j = 0; int k = -1;\tnext[0] = k;//第一个元素k 为-1 表示j没有办法偏移  需要i偏移\twhile (j &lt; len)&#123;\t\tif (k == -1 || pstr[j] == pstr[k])&#123;\t\t\tnext[++j] = ++k;\t\t&#125;\t\telse&#123;\t\t\tk = next[k];\t\t&#125;\t&#125;&#125;//KMP算法int KMP(char* s1, char* s2)&#123;\tchar* pStr1 = s1;\tchar* pStr2 = s2;\tint* next = new int[strlen(s2)];\tgetNext(s2, next);\tint i = 0, j = 0;\twhile (i &lt; strlen(s1) &amp;&amp; j &lt; strlen(s2))&#123;\t\tif (-1 == j || pStr1[i] == pStr2[j])&#123;\t\t\ti++; j++;\t\t&#125;\t\telse&#123;\t\t\tj = next[j];\t\t&#125;\t&#125;\tif (j == strlen(s2)) return (i - j);\treturn -1;&#125;\n\n贪心算法思想大的问题 归纳成小问题 然后迭代能且只能做当前看来最优的选择 如此反复 试图得到最终最优解\n缺陷：\n\n并非一定能得到整体最优解\n每一步都是局部最优\n\n//这是解决三角形从上到下累和最大值的算法//这是爆破算法，不是贪心算法，这是基础的递归#if 0//获取最大路径int getMax(int i, int j)&#123;\t//step1 ：递归方式  每一步都计算  爆破法\t//结束条件-&gt;越界\tif (i &gt;= NUM||j&gt;=NUM) return 0;\t//递归\t\tint n = arr[i][j] + getMax(i + 1, j);\tint m = arr[i][j] + getMax(i + 1, j+1);     t++;\treturn ((n &gt; m) ? n : m);&#125;#endif//这是优化爆破算法的贪心算法#if 0//获取最大路径int getMax(int i, int j)&#123;\t//step2 ：递归方式  有一些没有意义的递归 要省略     存储之前递归计算出来的结果  直接用\t//结束条件-&gt;越界\tif (maxArr[i][j]!=-1) return maxArr[i][j];\t//递归\t\tint n = arr[i][j] + getMax(i + 1, j);\t\tint m = arr[i][j] + getMax(i + 1, j + 1);\t\tmaxArr[i][j] = Max(n, m);\tt++;\treturn maxArr[i][j];&#125;#endif//递归还是有开销就开始优化为循环#if 0//获取最大路径int getMax()&#123;\t//step3 ：循环方式  直接从下往上加\t//先给最下面一层赋值\tfor (int i = 0; i &lt; NUM; i++)\t&#123;\t\tmaxArr[NUM - 1][i] = arr[NUM - 1][i];\t&#125;\t//循环，一层层向上相加\tfor (int i = NUM-2; i &gt;=0; i--)\t&#123;\t\tfor (int j = 0; j &lt;=i; j++)\t\t&#123;\t\t\tint n = maxArr[i + 1][j] + arr[i][j];\t\t\tint m = maxArr[i + 1][j+1] + arr[i][j];\t\t\tmaxArr[i][j] = Max(n, m);\t\t&#125;\t&#125;\t//返回maxArr[0][0]\treturn maxArr[0][0];&#125;#endif//当时间不能再优化后对空间的优化#if 0//获取最大路径int getMax()&#123;\t//step4 ：循环方式  直接从下往上加  空间方面只用一行\tint temp[NUM];\tfor (int i = 0; i &lt; NUM; i++)\t&#123;\t\ttemp[i] = arr[NUM - 1][i];\t&#125;\t//循环，一层层向上相加\tfor (int i = NUM - 2; i &gt;= 0; i--)\t&#123;\t\tfor (int j = 0; j &lt;= i; j++)\t\t&#123;\t\t\tint n = temp[j] + arr[i][j];\t\t\tint m = temp[j + 1] + arr[i][j];\t\t\ttemp[j] = Max(n, m);\t\t&#125;\t&#125;\t//返回temp[0]\treturn temp[0];&#125;#endif\n\n//背包问题-&gt;容量和价值，怎么装才是最优解#define V   20#define N   5struct WuPin&#123;\tint w;//体积\tint c;//价值&#125;;WuPin wp[N] = &#123; &#123; 3, 4&#125;, &#123; 5,6 &#125;, &#123; 6, 7&#125;, &#123; 7,8 &#125;, &#123; 9,10 &#125; &#125;;//返回 a b 中大的那一个int Max(int a, int b)&#123;\treturn ((a &gt; b) ? a : b);&#125;int  main()&#123;    int temp[100] = &#123; 0 &#125;;//存储各种体积对应的价值    for (int i = 0; i &lt; N; i++)&#123;//种类搭配\t  for (int j = wp[i].w; j &lt;= V; j++)&#123;//j表示体积   \t\t    temp[j] = Max(temp[j], temp[j - wp[i].w] + wp[i].c);      &#125;\t&#125;    return 0;&#125;//关键代码： temp[j] = Max(temp[j], temp[j - wp[i].w] + wp[i].c);//原理是贪心算法，自己的理解是：先用第一种物品装满背包，所需装的价值，陈列到数组里，然后用接下来的物品往里装，看是否比之前的更有价值，有就取代，没有继续，直到结束，最后最大值就是最优解。//为什么j++而不是j+=wp[i].w（保险，但是我觉得是）\n\n/*dijkstra算法：解决最短路径问题*/#include &lt;stdio.h&gt;//代表不连通状态#define NO  0xFFFFFF#define MAX   100struct graph&#123;\tchar\tvetexs[MAX];\t\t//顶点数组\tint\t\tvexnum;\t\t\t\t//顶点个数\tint\t\tarcnum;\t\t\t\t//边个数\tint\t\tmatix[MAX][MAX];\t//描述边的二维数组&#125;;//map 图    in 起点下标     dist 存放最短路径的数组void Dijkstra(graph map, int in, int dist[]);int main()&#123;\tgraph  map = &#123;\t\t&quot;12345&quot;,5,7,\t\t&#123;\t\t\t&#123; NO, 10, NO, 30, 100 &#125;,\t\t\t&#123; NO, NO, 50, NO, NO &#125;,\t\t\t&#123; NO, NO, NO, NO, 10 &#125;,\t\t\t&#123; NO, NO, 20, NO, 60 &#125;,\t\t\t&#123; NO, NO, NO, NO, NO &#125; \t\t&#125;\t&#125;;\tint in = 0;//入口\tint dist[MAX] = &#123; 0 &#125;;//存放路径的数组\tDijkstra(map, in, dist);\tfor (int i = 1; i &lt; 10; i++)\t\tprintf(&quot;%d &quot;, dist[i]);\tprintf(&quot;\\n&quot;);\twhile (1);&#125;//map 图    in 起点下标     dist 存放最短路径的数组// 找到当前入口到其他顶点的路径void Dijkstra(graph map, int in, int dist[])&#123;\tint i = 0,j = 0, k = 0;\tint flag[MAX];//标记成功获取的路径\tfor (i = 0; i &lt; map.vexnum; i++)&#123;\t\tflag[i] = 0;\t\tdist[i] = map.matix[in][i];\t&#125;\t//2. 扩充顶点\tflag[in] = 1;//进来的时候标记一下\tint min;//最小值\tfor (i = 1; i &lt; map.vexnum; i++)//每一层进行比较-&gt;每一次循环\t&#123;\t\tmin = NO;\t\tfor (j = 1; j &lt; map.vexnum; j++)\t\t&#123;\t\t\tif (flag[j] == 0 &amp;&amp; dist[j] &lt; min)//没选中过，且值小于最小值\t\t\t&#123;\t\t\t\tmin = dist[j];//更改最小值\t\t\t\tk = j;        //存下标\t\t\t&#125;\t\t&#125;\t\tflag[k] = 1;//更新为选中\t\tfor (j = 1; j &lt; map.vexnum; j++)\t\t&#123;\t\t\tif (flag[j] == 0 &amp;&amp; (min + map.matix[k][j]) &lt; dist[j])//没选中过，且累和小于以存入数据\t\t\t&#123;\t\t\t\tdist[j] = min + map.matix[k][j];//存入数据\t\t\t&#125;\t\t&#125;\t&#125;\tfor (int i = 1; i &lt; map.vexnum; i++)\t&#123;\t\tprintf(&quot;最短路径(%c,%c)=%d\\n&quot;, map.vetexs[in], map.vetexs[i], dist[i]);\t&#125;&#125; \n\n\n\n动态规划\n动态规划又叫  dp\n\n把一个问题分解成若干个子问题        将中间结果保存以避免重复计算         基本步骤：\n\n找出最优解的性质，然后刻画结构特征  （找规律）\n最优解(最好的解决方案 定义)   循环(递归)\n以自上而下或者自下而上的方式来计算最优值(局部的)\n通过最优值来构造最优解\n\n动态规划的案例：\n\n台阶问题-&gt;斐波那契数列\n\n//台阶问题//递归版本int taijie(int n)&#123;//结束条件\tif (n &lt; 1) return 0;\tif (1 == n || 2 == n) return n;\treturn taijie(n - 1) + taijie(n - 2);&#125;//台阶问题//循环版本int taijie(int n)&#123;\tint temp;\tint f1 = 1, f2 = 2;\tfor (int i = 3; i &lt;= n; i++)&#123;\t\ttemp = f1 + f2;\t\tf1 = f2;\t\tf2 = temp;\t&#125;\treturn temp;&#125;\n\n\n最短路径问题\n\n//地图0是边界，从3开始走到8int map[5][5] = &#123;\t&#123; 0, 0, 0, 0, 0 &#125;,\t&#123; 0, 3, 6, 2, 1 &#125;,\t&#123; 0, 4, 3, 0, 6 &#125;,\t&#123; 0, 5, 5, 4, 3 &#125;,\t&#123; 0, 9, 7, 2, 8 &#125;&#125;;//判断谁最小int min(int a, int b)&#123;\treturn ((a &lt; b) ? a : b);&#125;//最小路径问题int findMinPath()&#123;\tint dp[5][5] = &#123; 0 &#125;;//辅助数组\tfor (int i = 1; i &lt; 5; i++)&#123;//往下\t\tfor (int j = 1; j &lt; 5; j++)&#123;//往右\t\t\tif (1 == i)&#123;//只有从左边来的可能\t\t\t\tdp[i][j] = map[i][j] + dp[i][j - 1];\t\t\t&#125;\t\t\telse if (1 == j)&#123;//只有从上边来的可能\t\t\t\tdp[i][j] = map[i][j] + dp[i - 1][j];\t\t\t&#125;\t\t\telse&#123;\t\t\t\tdp[i][j] = map[i][j] + min(dp[i][j - 1], dp[i - 1][j]);\t\t\t&#125;\t\t&#125;\t&#125;\treturn dp[4][4];&#125;\n\n\n求最大上升子串长度问题\n\n//求最大上升子串长度void findMaxStrLength()&#123;    //准备工作\tint N;\tprintf(&quot;请输入字符串长度:&quot;);\tscanf(&quot;%d&quot;, &amp;N);\tint* pBuff = new int[N];\tprintf(&quot;请输入字符串:&quot;);\tfor (int i = 0; i &lt; N; i++)\t\tscanf(&quot;%d&quot;, &amp;pBuff[i]);\t//准备统计最大上升子串长度的临时数组\tint* pMaxLen = new int[N];\tmemset(pMaxLen, 0, sizeof(int)*N);    //正式开始    //因为第一个数肯定是一个最长上升子序列，所以pMaxLen[1] = 1。\tpMaxLen[1] = 1;//第二个为1\tint nTemp;        //这个写法和本代码实现有出入，但是思想都是一样的    //如果pBuff[i]（当前的数） &gt; pBuff[j]（前一个数），则pMaxLen[i]=pMaxLen[j]+1    //否则找到（从后往前）第一个比pBuff[i]小的数pBuff[k]，则pMaxLen[i]=pMaxLen[k]+1    \tfor (int i = 2; i &lt; N; i++)//从第三个开始到串末尾    &#123;\t\tnTemp = 1;//实时记录当前最大上升子串长度\t\tfor (int j = 1; j &lt; i; j++)//从i前面的串里去找        &#123;\t\t\tif (pBuff[j] &lt; pBuff[i])//找到比当前数据要小的数据            &#123;\t\t\t\tif (nTemp &lt; pMaxLen[j])//找到第一个比pBuff[i]小的数pBuff[k]\t\t\t\t\tnTemp = pMaxLen[j];\t\t\t&#125;\t\t\tpMaxLen[i] = nTemp + 1;\t\t\tprintf(&quot;i:%d j:%d %d\\n&quot;,i,j, pMaxLen[i]);\t\t&#125;\t&#125;\tprintf(&quot;最大上升子串长度为:%d\\n&quot;, pMaxLen[N - 1]);&#125;\n\n\n\n动态回溯动态回溯：\t   寻路算法    深度寻路算法\t   动态回溯算法思想：\n\t1. 针对问题来解空间：  根据实际需求用不同方式来描述\n\t\t深度寻路算法： 要找到起点到终点的路径   二维数组来描述地图\n\t2. 确定易于搜索的解空间结构，并构造相应的判断函数\n\t3. 用深度优先搜索的方式来解决问题，并要有合适的回溯方式（栈）\n\n动态回溯 == 问题的解空间 + 深度优先搜索 + 判断结果的结构 + 回溯\n\n动态回溯一般用来解决哪些问题：\t1. 寻路  2. 货物装载 3. 0-1背包问题 4. 图的着色问题(涂格子)\t5. 电路排版问题 6. 旅行者售后员问题 7. N皇后问题\t\t\t8皇后问题： 国际象棋棋盘   在任意两个皇后不能互相触及的前提下 有多少种摆法\n\t\n1 问题的解空间 ： 二维数组\n2 深度优先搜索 ： 递归 一个个去摆  摆了N个皇后结束\n3 判断结果     ： 判断能不能摆  数量是否达标\n4 回溯        ：  给二维数组元素赋值 为1 表示摆放好了 赋值为0 就是回退  \n\n//N皇后问题#include&lt;iostream&gt;using namespace std;//N个皇后#define N 8//统计种数int num = 0;//判断所在格子上是否有棋子bool isfang(int i, int j, int q[][N])&#123;\tint s;//s i 垂直 y轴\tint t;//t j 水平 x轴\t//横向\tfor (s = i, t = 0; t &lt; N; t++)\t&#123;\t\tif (q[s][t] == 1 &amp;&amp; j != t)\t\t&#123;\t\t\treturn false;\t\t&#125;\t&#125;\t//纵向\tfor (s = 0, t = j; s &lt; N; s++)\t&#123; \t\tif (q[s][t] == 1 &amp;&amp; s != i)\t\t&#123;\t\t\treturn false;\t\t&#125;\t&#125;\t//左上\tfor (t = j - 1, s = i - 1; s &gt;= 0 &amp;&amp; t &gt;= 0; s--, t--) \t&#123;\t\tif (q[s][t] == 1)\t\t&#123;\t\t\treturn false;\t\t&#125;\t&#125;\t//左下\tfor (t = j - 1, s = i + 1; s &lt; N &amp;&amp; t &gt;= 0; s++, t--) \t&#123;\t\tif (q[s][t] == 1) \t\t&#123;\t\t\treturn false;\t\t&#125;\t&#125;\t//右上\tfor (t = j + 1, s = i - 1; s &gt;= 0 &amp;&amp; t &lt; N; s--, t++) \t&#123;\t\tif (q[s][t] == 1) \t\t&#123;\t\t\treturn false;\t\t&#125;\t&#125;\t//右下\tfor (t = j + 1, s = i + 1; s &lt; N &amp;&amp; t &lt; N; s++, t++) \t&#123;\t\tif (q[s][t] == 1) \t\t&#123;\t\t\treturn false;\t\t&#125;\t&#125;\treturn true;&#125;//N皇后问题void Queen( int q[][N],int j=0)&#123;\t//因为需要回溯所以用递归简单\t//首先设置结束条件-&gt;王后都放置成功\tif (j==N)\t&#123;\t\tnum++;\t\treturn;\t&#125;\tfor (int i = 0; i &lt; N; i++)//因为每行放一个，一行就不能放第二个了，所以一个循环，表示y\t&#123;\t\tif (isfang(i,j,q))//判断所在的格子上是否有棋子\t\t&#123;\t\t\tq[i][j] = 1;//没有就让它有\t\t\tQueen(q,j+1);//继续放\t\t\tq[i][j] = 0;//回溯\t\t&#125;\t&#125;&#125;int main()&#123;\tint q[N][N] = &#123; 0 &#125;;\tQueen(q);\tcout &lt;&lt; &quot;一共有&quot; &lt;&lt; num &lt;&lt; endl;\treturn 0;&#125;\n\n\n分支定界分支定界思想：一般用来解决寻路问题(最短路径)   广度寻路  A星寻路\t常用广度优先或者以最小耗费(最大收益)优先的方式搜索问题的解空间树。\n\t    \n在分支定界算法思想中，每一个活节点(坐标节点)只有一次机会成为拓展节点\n一旦成为拓展节点，就一次性生成其所有孩子节点。\n在这些孩子节点中，导致不可行解或者非最优解的孩子节点被舍弃(剪枝)，\n其余孩子节点被加入活节点表中(存放，记录，保存)\n此后，从活节点表中获取下一节点成为当前拓展节点，并重复上述节点拓展过程。\n这个过程一直到找到需要的解（找到终点）或者活节点表（buff）为空。\n\n广度寻路：\t爬虫\n给一个网址 \n解析网址：\n连上网页的服务器\n发送请求到网页服务器，获取网页源码\n源码中就有很多的图片链接和网址链接\n把网址链接存到队列中\n循环从队列中一个个取出 取出后\n\t解析网址：\n\t连上网页的服务器\n\t发送请求到网页服务器，获取网页源码\n\t源码中就有很多的图片链接和网址链接\n\t把网址链接存到队列中\n把图片链接存到队列中\n循环从队列中一个个取出 取出后\n\t解析网址：\n\t连上网页的服务器\n\t发送请求到网页服务器，获取图片\n\nA星寻路:图结构\t分支定界法常用的两个数据结构：\t1. 队列式分支定界法\t\t按照队列原则选取下一个节点成为拓展节点。（广度寻路）\t2. 优先队列式分支定界法\t\t按照优先队列中规定的优先级选取优先级最高的节点成为当前拓展节点。（A星寻路）\n","tags":["cpp","数据结构与算法"]},{"title":"设计模式","url":"/posts/364ea8cc.html","content":"[TOC]\n设计模式设计模式分类\n创建型模式\n通常和对象创建有关，设计到对象实例化的方式(5种)\n\n工厂模式\n抽象工厂模式\n建造者模式\n原型模式\n单例模式\n\n\n结构型模式\n描述的是如何组合类和对象获得更大的结构(7种)\n\n代理模式\n装饰者模式\n适配器模式\n桥接模式\n组合模式\n外观模式\n享元模式\n\n\n行为型模式\n描述的类和对象的交互以及分配职责(11种 )\n\n模板方法模式\n命令模式\n责任链模式\n策略模式\n中介者模式\n观察者模式\n备忘录模式\n访问者模式\n状态模式\n解释器模式\n迭代器模式\n\n\n\n面向对象的设计原则依赖倒置原则(DIP)DIP：Dependence Inversion Principle\n\n高层(稳定)不依赖低层(变化)，两者依赖抽象(稳定)。\n抽象(稳定)不依赖细节(变化)，细节依赖抽象(稳定)。\n\n开放封闭原则(OCP)OCP:Open For Extension, Closed For Modification Principle\n\n对扩展开放，对更改封闭\n\n类模块可扩展， 但不可修改\n\n\n单一职责原则(SRP)SRP:Single Responsibility Principle\n\n一个类应该仅有一个引起它变化的原因\n变化的方向隐含类的责任\n\n里氏替换原则(LSP)LSP:Liskov Substitution Principle\n\n子类必须能够替换它们的基类\n继承表达类型抽象\n\n接口隔离原则(ISP)\n不应该强迫客户程序依赖他们不用的方法\n接口应该小而完备\n一个接口应该只提供一种对外功能\n\n优先组合不是继承原则(CARP)CARP：Composite&#x2F;Aggregate Reuse Principle\n\n类的继承通常是”白箱复用”，对象组合通常是”黑箱复用”\n继承在一定程序破坏封装性，子类和父类耦合度高\n\n迪米特法则(LOD)LOD：Law of Demeter\n\n对象应当对其他对象尽可能少的了解\n各个模块之间相互调用时，通常会提供一个统一的接口来实现\n\nc++类图什么是类图类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。它既用于应用程序的系统分类的一般概念建模，也用于详细建模，将模型转换成编程代码。\n类图作用类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。它既用于应用程序的系统分类的一般概念建模，也用于详细建模，将模型转换成编程代码。：描述类的本身结构以及类与类之间一些关系\n类图的元素在类图中一共包含了以下几种模型元素，分别是：类（Class）、接口（Interface）、依赖（Dependency）关系、泛化（Generalization）关系、关联（Association）关系、聚合关系（Aggregation）、组合关系（Composition）和实现（Realization）关系。\n类图中类的组成+: 公有属性-: 私有属性#: 保护属性name:string  成员名:类型eat():void   成员函数:返回值类型斜体:抽象类或者纯虚函数\n\n类中图类的关系\n依赖（Dependency）关系\n依赖关系是指两个或多个类之间的依存关系，如植物类依赖于土壤类。 依赖关系还可以再细分为5种类型，分别是绑定（Binding）依赖、实现（Realization）依赖、使用（Usage）依赖、抽象（Abstraction）依赖和授权（Permission）依赖。\n(依赖关系用虚线箭头来表示，箭头指向为依赖的方向)\n\n泛化（Generalization）关系\n简单的讲就是类之间的继承关系。\n  (用空心三角形-实线来表示，箭头指向为父类)\n\n关联（Association）关系\n关联关系是类之间一种相互影响的关系，影响的方向就是关联的方向。\n（关联关系用实线箭头来表示）\n\n聚合（Aggregation)关系\n聚合关系是类之间的一种较弱的耦合关系，如一个字符串数组和一个字符串就是一种聚合关系。\n（空心的菱形-实线箭头来表示，箭头指向为被聚合的类）\n\n组合（Composition）关系\n组合关系是类之间一种整体与部分之间的关系，如一只青蛙有四条腿，青蛙类与青蛙腿类之间的关系就是组合关系。\n(组合关系用实心的菱形-实线箭头来表示，箭头指向为被组合的类)\n\n实现（Realization）关系\n一般来讲实现关系是针对类与接口之间的关系而言的。\n(实现关系用空心三角形-虚线来表示)\n\n\n单例设计模式什么是单例模式单例模式是一种对象创建型模式，使用单例模式，可以保证为一个类只生成唯一的实例对象。也就是说，在整个程序中，该类只存在一个实例对象。\n单例模式实现步骤\n构造函数私有化\n提供一个全局的静态方法，访问唯一对象\n类中定义一个静态指针，指向唯一对象\n\n为什么使用单例模式在应用系统开发中，我们常常有以下需求：\n1. 需要生成唯一序列的环境2. 需要频繁实例化然后销毁的对象。3. 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。4. 方便资源相互通信的环境\n实际案例:\n\n多线程中网络资源初始化\n回收站机制\n任务管理器\n应用程序日志管理\n…….\n\n单例模式优缺点优点：\n\n在内存中只有一个对象，节省内存空间；\n避免频繁的创建销毁对象，可以提高性能；\n避免对共享资源的多重占用，简化访问；\n为整个系统提供一个全局访问点。\n\n缺点：\n\n不适用于变化频繁的对象；\n如果实例化的对象长时间用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；\n\n单例模式实现代码懒汉式#include&lt;iostream&gt;using namespace std;//懒汉式class Singleton_pattern&#123;public:   //对象指针  static Singleton_pattern* singlenton;  //创建唯一对象  static  Singleton_pattern* getclass()  &#123;    if (singlenton == NULL)    &#123;      singlenton = new Singleton_pattern();    &#125;return  singlenton;  &#125;private:  //构造函数私有化  Singleton_pattern()&#123;&#125;&#125;;//要给静态成员变量赋值否则会报错Singleton_pattern* Singleton_pattern:: singlenton = NULL;int main()&#123;  Singleton_pattern* sing = Singleton_pattern::getclass();  return 0;&#125;\n\n饿汉式#include&lt;iostream&gt;using namespace std;// 饿汉式class Singleton_pattern&#123;public:  //对象指针  static Singleton_pattern* singlenton;  //返回指针  static  Singleton_pattern* getclass()  &#123;    return  singlenton;  &#125;private:  //构造函数私有化  Singleton_pattern()&#123;&#125;&#125;;//直接创建对象，与懒汉式不同是如果代码用不上这个类，就会多占用空间Singleton_pattern* Singleton_pattern::singlenton = new Singleton_pattern();int main()&#123;  Singleton_pattern* sing = Singleton_pattern::getclass();  return 0;&#125;\n\n简单工厂模式什么是简单工厂简单工厂模式属于类的创建型模式,又叫做静态工厂方法模式。\n通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n为什么使用简单工厂减少客户程序对类创建过程的依赖\n简单工厂实现步骤1.提供一个工厂类\n简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。\n2.提供一个抽象产品类\n简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。\n3.提供一个具体产品类\n简单工厂模式所创建的具体实例对象\n简单工厂优缺点优点：\n\n帮助封装\n实现组件封装，面向接口编程\n\n解耦合\n客户端和具体实现类的解耦合\n\n\n缺点：\n\n可能增加客户端的复杂度\n不方便扩展子工厂\n\n简单工厂实现代码#include&lt;iostream&gt;using namespace std;//简单工厂模式设计简单计算器//抽象类class symbol&#123;//简单写模式就不写构造函数了//否者下面的继承类写也写构造麻烦public:  double one=0;  double twe=0;  virtual double getreturn() = 0;&#125;;class addsybol:public symbol&#123;private:  double getreturn()  &#123;    return one + twe;  &#125;&#125;;class minsybol :public symbol&#123;private:  double getreturn()  &#123;    return one - twe;  &#125;&#125;;class musybol :public symbol&#123;private:  double getreturn()  &#123;    return one * twe;  &#125;&#125;;class divsybol :public symbol&#123;private:  double getreturn()  &#123;    if (twe)    &#123;      return one / twe;    &#125;    return -1;  &#125;&#125;;class operatoron&#123;public:  static symbol* getsy(char s)  &#123;    switch (s)    &#123;    case &#x27;+&#x27;: return new addsybol;      break;    ase &#x27;-&#x27;:return new minsybol;      break;    case &#x27;*&#x27;: return new musybol;      break;    case &#x27;/&#x27;: return new divsybol;      break;    default:      return 0;    &#125;  &#125;&#125;;int main()&#123;  symbol* p = operatoron::getsy(&#x27;+&#x27;);  p-&gt;one = 4;  p-&gt;twe=6;  cout&lt;&lt;p-&gt;getreturn();  return 0;&#125;\n\n工厂模式什么是工厂模式工厂方法模式同样属于类的创建型模式又被称为多态工厂模式 。工厂方法模式的意义是 定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。 核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类 必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工 厂角色的情况下引进新的产品\n为什么使用工厂模式工厂方法模式与简单工厂模式在结构上的不同不是很明显。工厂方法类的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。 工厂方法模式之所以有一个别名叫多态性工厂模式是因为具体工厂类都有共同的接口， 或者有共同的抽象父类。 当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体对象以及一个具体工厂对 象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好的符合了“开放－封闭” 原则。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。工厂方法模式退化后可以演变成简单工厂模式。\n工厂模式实现步骤1.提供一个抽象工厂类 :所有具体工厂类的父类\n2.提供与产品对应的工厂类:负责实例化产品对象\n3.提供一个抽象产品类： 所有产品的父类\n4.提供一个或多个产品类:工厂方法模式所创建的具体实例对象\n工厂模式优缺点优点：\n\n需求改变时改动最小\n\n具体的创建实例过程与客户端分离\n\n\n缺点：\n\n新增功能时，工程量稍大\n\n工厂模式实现代码#include&lt;iostream&gt;using namespace std;//先商品再工厂，工厂是创建商品的！//构建商品抽象类class app&#123;public:  virtual void getapp() = 0;&#125;;//构建工厂抽象类class factory&#123;public:  virtual app* makeapp() = 0;&#125;;//创建产品子类-飞机class plantapp :public app&#123;public:  void getapp()  &#123;    cout &lt;&lt; &quot;飞机....\\n&quot;;  &#125;&#125;;//创建工厂子类-飞机class makeplant :public factory&#123;public:  app* makeapp()  &#123;    return new plantapp;  &#125;&#125;;//创建产品子类-飞机class rocketapp :public app&#123;public:  void getapp()  &#123;    cout &lt;&lt; &quot;火箭....\\n&quot;;  &#125;&#125;;//创建工厂子类-火箭class makerocket :public factory&#123;public:  app* makeapp()  &#123;    return new rocketapp;  &#125;&#125;;int main()&#123;  //造飞机  factory* p = new makeplant;  app* t = p-&gt;makeapp();  t-&gt;getapp();  //造火箭  factory* ps = new makerocket;  app* ts = ps-&gt;makeapp();   ts-&gt;getapp(); return 0;&#125;\n\n抽象工厂模式什么是抽象工厂模式抽象工厂模式是所有形态的工厂模式中最为抽象和最其一般性的。抽象工厂模式可以向 客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，能够创建多个产品族的产品对象。\n为什么使用抽象工厂模式抽象工厂方法是针对与一个产品族，使得易于交换产品系列，只需改变具体的工厂就可以使用不同的产品配置。当一个族中的产品对象被设计成一起工作且一个应用只是用同一族的对象，例如设计系统生成不同风格的UI界面，按钮，边框等UI元素在一起使用，并且只能同属于一种风格，这很容易使用抽象工厂实现。\n抽象工厂模式实现步骤**1.提供一个抽象工厂类：**声明一组创建一族产品的工厂方法\n**2.提供一个具体工厂类：**实现了在抽象工厂创建产品的工厂方法\n**3.提供一个抽象产品类：**抽象产品中声明了产品具有的业务方法\n**4.提供一个具体产品类：**实现抽象产品接口中声明的业务方法\n抽象工厂模式优缺点优点：\n\n抽象工厂封装了变化，封装了对象创建的具体细节\n增加新的产品族很方便，无须修改已有系统\n针对接口进行编程而不是针对具体进行编程\n\n缺点：\n\n增加新的产品等级结构需对原系统做较大修改(违背开放封闭)\n\n抽象工厂模式实现代码#include&lt;iostream&gt;using namespace std;//抽象工厂以键盘鼠标为例//抽象商品类class Product&#123;public:  virtual void show() = 0;&#125;;//抽象商品类1class KeyBoard :public Product&#123;&#125;;//具体商品class LogiKeyBoard:public KeyBoard&#123;public:  void show()  &#123;    cout &lt;&lt; &quot;罗技键盘\\n&quot;;  &#125;&#125;;class RazerKeyBoard :public KeyBoard&#123;  void show()  &#123;    cout &lt;&lt; &quot;雷蛇键盘\\n&quot;;  &#125;&#125;;//抽象商品类2class Mouse :public Product &#123;&#125;;//具体商品class LogiMouse :public Mouse&#123;  void show()  &#123;    cout &lt;&lt; &quot;罗技鼠标\\n&quot;;  &#125;&#125;;class RazerMouse :public Mouse&#123;  void show()  &#123;    cout &lt;&lt; &quot;雷蛇鼠标\\n&quot;;  &#125;&#125;;//抽象工厂class Factory&#123;public:  virtual Product* creatkeyboard() = 0;  virtual Product* creatkemouse() = 0;&#125;;//商品集1工厂class LogiFactory :public Factory&#123;  Product* creatkeyboard()  &#123;    return new LogiKeyBoard;  &#125;  Product* creatkemouse()  &#123;    return new LogiMouse;  &#125;&#125;;//商品集2工厂class RazerFactory :public Factory&#123;  Product* creatkeyboard()  &#123;    return new RazerKeyBoard;  &#125;  Product* creatkemouse()  &#123;       return new RazerMouse;  &#125;&#125;;int main()&#123;  //先建立工厂后商品  Factory* p = new LogiFactory();  Product* t = p-&gt;creatkemouse();  Product* s = p-&gt;creatkeyboard();  t-&gt;show();  s-&gt;show();  delete p;  delete t;  delete s;  p = new RazerFactory;  t = p-&gt;creatkemouse();  s = p-&gt;creatkeyboard();  t-&gt;show();  s-&gt;show();  return 0;&#125;\n\n建造者模式什么是建造者模式建造者模式是一种对象创建型模式之一，用来隐藏复合对象的创建过程，它把复合对象的创建过程加以抽象，通过子类继承和重载的方式，动态地创建具有复合属性的对象。官方说法就是将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。\n为什么使用建造者模式主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。\n建造者模式实现步骤1.提供抽象建造者类: 为创建产品各个部分，统一抽象接口\n2.提供具体建造者类：具体实现抽象建造者各个部件的接口\n3.提供多个具体产品类:具体的创建产品的各个部分\n4.提供一个指挥类：负责安排和调度复杂对象的各个建造过程\n建造者模式优缺点优点\n\n封装性好，构建和表示分离\n\n扩展性好，各个具体的建造者相互独立，有利于系统的解耦\n\n控制细节风险，客户端无需详知细节，建造者细化创建过程\n\n\n缺点\n\n产品的组成部分必须相同，这限制了其使用范围\n\n产品内部发生变化，建造者需同步修改，后期维护成本较大\n\n\n建造者模式实现代码#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;//电脑组装:显示器、鼠标、键盘、主机（主机又包括cpu、显卡、主板等）//1.找到店铺老板告诉需求//2.客服安排技术员工组装//3.产品组装完成//抽象产品类class Products&#123;public:  virtual void setdisplayer(string displayer) = 0;  virtual void setmouse(string mouse) = 0;  virtual void setkeyboard(string keyboard) = 0;  virtual void sethost(string host) = 0;  virtual void show() = 0;&#125;;//具体产品类class computer :public Products&#123;public:   void setdisplayer(string displayer)  &#123;     list.push_back(displayer);   &#125;   void setmouse(string mouse)   &#123;     list.push_back(mouse);   &#125;   void setkeyboard(string keyboard)   &#123;     list.push_back(keyboard);   &#125;   void sethost(string host)  &#123;     list.push_back(host);    &#125;   void show()   &#123;     cout &lt;&lt; &quot;配置为：\\n&quot;;      for (auto i : list)    &#123;       cout &lt;&lt; i &lt;&lt; endl;    &#125;   &#125;private:  vector&lt;string&gt; list; //组件清单&#125;;//抽象建造者class Builder&#123;public:  Builder():pc(new computer)&#123;&#125;  virtual void builderdisplayer(string displayer) = 0;  virtual void buildermouse(string mouse) = 0;  virtual void builderkeyboard(string keyboard) = 0;  virtual void builderhost(string host) = 0;  //得到电脑   Products* getpc()  &#123;     return pc;  &#125;private:   Products* pc;&#125;;//具体建造者class people :public Builder&#123;public:  void builderdisplayer(string displayer)  &#123;    getpc()-&gt;setdisplayer(displayer);   &#125;  void buildermouse(string mouse)  &#123;    getpc()-&gt;setmouse(mouse);   &#125;  void builderkeyboard(string keyboard)  &#123;    getpc()-&gt;setkeyboard(keyboard);   &#125;  void builderhost(string host)  &#123;    getpc()-&gt;sethost(host);   &#125;&#125;;//指挥者class Director&#123;public:  Director(Builder* p) :pc(p) &#123;&#125;  Products* getpc(string displayer, string mouse, string keyboard, string host)  &#123;    pc-&gt;builderdisplayer(displayer);    pc-&gt;builderkeyboard(keyboard);    pc-&gt;buildermouse(mouse);    pc-&gt;builderhost(host);    return pc-&gt;getpc();  &#125;private:  Builder* pc;&#125;;int main()&#123;  Builder* t = new people;//创建一个建造者  Director* s = new Director(t);//指挥者里放一个建造者  Products* w = s-&gt;getpc(&quot;华为显示器&quot;, &quot;牧马人鼠标&quot;, &quot;雷蛇键盘&quot;, &quot;外星人&quot;);//；建造者建造一个电脑  w-&gt;show();  return 0;&#125;\n\n原型模式什么是原型模式用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象，简单理解就是“克隆指定对象”\n为什么使用原型模式某些结构复杂的对象的创建工作中由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。此时便可以使用原型模式。\n原型模式实现步骤\n提供一个抽象原型类：规定了具体原型对象必须实现的接口。\n提供多个具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。\n提供访问类：使用具体原型类中的 clone() 方法来复制新的对象。\n\n原型模式优缺点优点\n\n如果创建新的对象比较复杂，可以利用原型模式简化对象的创建过程，同时也能够提高效率。\n简化对象的创建，无需理会创建过程。\n可以在程序运行时（对象属性发生了变化）获得一份内容相同的实例，他们之间不会相互干扰\n\n缺点\n\n每一个类都必须配备一个克隆方法,对于已有的没有克隆方法的类来说是致命的。\n\n原型模式实现代码#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//原来的类class monkey&#123;public:  monkey()&#123;&#125;  virtual ~monkey()&#123;&#125;  virtual monkey* cop() = 0;//克隆  virtual void play() = 0;//行为&#125;;//实现的类class sunwukong :public monkey&#123;public:  sunwukong(string name)  &#123;    this-&gt;name = name;  &#125;  ~sunwukong()&#123;&#125;  sunwukong(const sunwukong&amp; s)  &#123;    //当需要申请内存的出现时必须使用深拷贝    name = s.name;  &#125;  void play()  &#123;    cout &lt;&lt; name &lt;&lt; &quot;正在玩\\n&quot;;  &#125;  monkey* cop()  &#123;    return new sunwukong(*this);//创建一个新的  &#125;private:  string name;&#125;;int main()&#123;  monkey* s = new sunwukong(&quot;小猴子&quot;);  monkey* t = s-&gt;cop();  monkey* w = t-&gt;cop();  s-&gt;play();  t-&gt;play();  w-&gt;play();  delete s;  delete w;  delete t;  return 0;&#125;\n\n创建型模式总结工厂模式模式：单个类的对象创建工作\n抽象工厂模式：多个类的对象创建工作\n单例模式:类的全局对象创建工作\n建造者模式:复杂类的对象创建工作\n原型模式：自身类的克隆工作\n到目前为止，五个创建模式都汇总了，各有各的用途，在实际运用中，要多对比，哪种创建模式才适合，设计模式虽好，但要学会正确的运用，将会像把利刃，非常有利于项目的扩展易用等。\n代理模式什么是代理模式代理模式是构造型的设计模式之一，它可以为其他对象提供一 种代理以控制对这个对象的访问。 所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须 通过代理与被代理的目标类交互，而代理一般在交互的过程中（交互前后），进行某些 特别的处理。 \n为什么使用代理模式在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能. \n代理模式的作用：AOP实现，拦截器，中介，黄牛，解耦，专人做专事。\nAOP:面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。\n代理模式实现步骤1.提供一个抽象主题角色：真实主题与代理主题的共同接口\n2.提供一个真实主题角色：定义了代理角色所代表的真实对象\n3.提供一个代理主题角色：含有对真实主题角色的引用\n代理模式优缺点优点\n\n职责清晰：**真实角色就是实现实际业务逻辑，**不关心其他非本职责事务，通过后期代理完成一件事务，附带结果就是编程简介清晰。\n\n高扩展性：具体主题角色可变。\n\n\n缺点\n\n代理模式可能会造成请求的处理速度变慢\n\n代理模式实现代码#include&lt;iostream&gt;using namespace std;//抽象主题类class Subject&#123;public:  virtual void BuyTicket() = 0;&#125;;//用户买票class Use:public Subject&#123;public:  void BuyTicket()  &#123;    cout &lt;&lt; &quot;用户买票\\n&quot;;  &#125;&#125;;//携程买票class Ctrip :public Subject&#123;public:  Ctrip(Subject* t):s(t)&#123;&#125;  void BuyTicket()  &#123;    cout &lt;&lt; &quot;携程买票\\n&quot;;  &#125;private:  Subject* s;&#125;;int main()&#123;  Subject* s = new Use;  s-&gt;BuyTicket();  Subject* t = new Ctrip(s);  t-&gt;BuyTicket();  return 0;&#125;\n\n装饰模式什么是装饰模式装饰（ Decorator ）模式又叫做包装模式。通过一种对客户端透明的方式来扩展对象的功能，是继承关系的一个替换方案。 装饰模式就是把要添加的附加功能分别放在单独的类中，并让这个类包含它要装饰的对 象，当需要执行时，客户端就可以有选择地、按顺序地使用装饰功能包装对象。\n为什么使用装饰模式装饰模式可以动态的给一个对象添加一些额外的职责。就增加功能来说，此模式比生成子类更为灵活,通过子类继承的方式，但是如果后续继续增加功能的话，便要继续继承现有的类，如此就会使继承的层次越来越深，不利与代码的维护和可读性。故最好的方式便是通过装饰者模式来完成。\n装饰模式实现步骤1.提供一个抽象组件类:抽象被装饰者的行为\n2.提供一个或多个具体组件类:被装饰者的行为具体实现\n3.提供一个抽象装饰器类：抽象组件指针与抽象组件一致接口\n4.提供一个具体的装饰器类：为具体组件附加责任\n装饰模式优缺点优点\n\n易于扩展对象功能\n通过装饰类的排列组合，可创造出很多不同行为的组合\n\n缺点\n\n会出现更多的代码，更多的类，增加程序复杂性\n动态装饰时，多层装饰时会更复杂\n\n装饰模式代实现代码#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//写一个变装样例//抽象组件类class AbstractCompent&#123;public:  virtual void show() = 0;  string look;&#125;;//具体组件类class doll :public AbstractCompent&#123;public:  doll()  &#123;    look = &quot;一个洋娃娃&quot;;  &#125;  void show()  &#123;    cout &lt;&lt; look &lt;&lt; endl;  &#125;&#125;;//抽象装饰类class  AbstractDecrate :public  AbstractCompent&#123;public:  AbstractCompent* pBase;&#125;;//具体装饰类1class maxiskit :public AbstractDecrate&#123;public:  maxiskit(AbstractCompent* pBase)  &#123;    this-&gt;pBase = pBase;    this-&gt;pBase-&gt;look += &quot;穿一身长裙&quot;;    &#125;  void show()  &#123;    cout &lt;&lt; pBase-&gt;look &lt;&lt; endl;  &#125;&#125;;//具体装饰类2//具体装饰类1class long_hair :public AbstractDecrate&#123;public:  long_hair(AbstractCompent* pBase)  &#123;    this-&gt;pBase = pBase;    this-&gt;pBase-&gt;look += &quot;长一头暗红色的长发&quot;;  &#125;  void show()  &#123;    cout &lt;&lt; pBase-&gt;look &lt;&lt; endl;  &#125;&#125;;int main()&#123;  doll* g = new doll;  g-&gt;show();  maxiskit* t = new maxiskit(g);  t-&gt;show();  long_hair* s = new long_hair(g);  s-&gt;show();  return 0;&#125;\n\n适配器模式什么是适配器模式适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。好比日本现在就只提供110V的电压，而我的电脑就需要220V的电压，那怎么办啦?适配器就是干这活的，在不兼容的东西之间搭建一座桥梁，让二者能很好的兼容在一起工作。\n为什么使用适配器模式在软件开发中，有的时候系统的数据和行为都正确，但接口不符合，我们应该考虑使用适配器模式，目的是使控制范围之外的一个原有对象与某个接口匹配。举个例子:在开发一个模块的时候，有一个功能点实现起来比较费劲，但是，之前有一个项目的模块实现了一样的功能点;但是现在这个模块的接口和之前的那个模块的接口是不一致的。此时，作为项目经理的你，该怎么办啦?使用适配器模式，将之前实现的功能点适配进新的项目了。\n适配器模式实现步骤\n适配器实现与其中一个现有对象兼容的接口\n现有对象可以使用该接口安全地调用适配器方法\n适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象\n\n一般适配器模式分为以下两类:\n\n对象适配器:适配器实现了其中一个对象的接口， 并对另一个对象进行封装\n类适配器:适配器同时继承两个对象的接口\n\n适配器模式优缺点优点\n\n降低了去实现一个功能点的难度，可以对现有的类进行包装，就可以进行使用了\n提高了项目质量，现有的类一般都是经过测试的，使用了适配器模式之后，不需要对旧的类进行全面的覆盖测试;\n总的来说,提高了效率,降低了成本。\n\n缺点\n\n类适配器模式，由于多继承，可能会出现二义性\n对象适配器模式，如果过多使用适配器模式，会导致代码阅读难度增大\n\n适配器模式实现代码对象适配器实现代码#include&lt;iostream&gt;using namespace std;//电源插头//三口插头class threehand&#123;public:  void threehandout()  &#123;  \tcout &lt;&lt; &quot;三头充电器\\n&quot;;  &#125;&#125;;//用户需要用的接头虚拟类class Abtwo&#123;public:  virtual void three_twe() = 0;&#125;;//两头接口class twohand :public Abtwo&#123;public:  void three_twe()  &#123;    cout &lt;&lt; &quot;两插头充电\\n&quot;;  &#125;&#125;;//对象适配器class AdapterObject :public Abtwo&#123;public:  AdapterObject(threehand* p)  &#123;    th = p;  &#125;  void transition()  &#123;    cout &lt;&lt; &quot;三头转化为二头\\n&quot;;  &#125;  void three_twe()  &#123;    transition();    th-&gt;threehandout();  &#125;  threehand* th;&#125;;int main()&#123;  threehand* p = new threehand;  Abtwo* w = new AdapterObject(p);  w-&gt;three_twe();  return 0;&#125;\n\n类适配器实现代码#include&lt;iostream&gt;using namespace std;//电源插头//三口插头class threehand&#123;public:  void threehandout()  &#123;    cout &lt;&lt; &quot;三头充电器\\n&quot;;  &#125;&#125;;//用户需要用的接头虚拟类class Abtwo&#123;public:  virtual void three_twe() = 0;&#125;;//两头接口class twohand :public Abtwo&#123;public:  void three_twe()  &#123;    cout &lt;&lt; &quot;两插头充电\\n&quot;;  &#125;&#125;;//类适配器class AdapterObject :public Abtwo,public threehand&#123;public:  void transition()  &#123;    cout &lt;&lt; &quot;三头转化为二头\\n&quot;;  &#125;  void three_twe()  &#123;    transition();    threehandout();  &#125;&#125;;int main()&#123;  threehand* p = new threehand;  Abtwo* w = new AdapterObject();  w-&gt;three_twe();  return 0;&#125;\n\n桥接模式什么是桥接模式桥接模式是一种结构型设计模式， 可将业务逻辑或一个大类拆分为不同的层次结构， 从而能独立地进行开发。桥接模式通过将继承改为组合的方式来解决这个问题。 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。层次结构中的第一层 （通常称为抽象部分） 将包含对第二层 （实现部分） 对象的引用。 抽象部分将能将一些 （有时是绝大部分） 对自己的调用委派给实现部分的对象。 所有的实现部分都有一个通用接口， 因此它们能在抽象部分内部相互替换。\n为什么使用桥接模式桥接模式在处理跨平台应用、 支持多种类型的数据库服务器或与多个特定种类 （例如云平台和社交网络等） 的 API 供应商协作时会特别有用。\n桥接模式实现步骤1.提供一个抽象类:提供高层控制逻辑,依赖实际底层对象\n2.提供一个精准抽象类:拓展抽象类,更精确的抽象\n3.提供具体实现抽象类:具体实现类的抽象通用接口\n4.提供具体实现类：针对不同底层的通用接口实现\n桥接模式优缺点优点\n\n你可以创建与平台无关的类和程序\n\n客户端代码仅与高层抽象部分互动， 不接触到平台详细信息\n\n开闭原则，可以新增抽象和实现， 且它们之间互不影响\n\n单一职责原则，抽象专注高层逻辑， 实现部分处理平台细节\n\n\n缺点\n\n对高内聚的类使用该模式可能会让代码更加复杂\n\n桥接模式实现代码#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//颜色类class color&#123;public:  virtual void fillcolor() = 0;&#125;;//红色class red :public color&#123;public:  red() :colors(&quot;红色&quot;) &#123;&#125;  void fillcolor()  &#123;    cout &lt;&lt; &quot;\\t颜色：\\t&quot; &lt;&lt; colors&lt;&lt;&quot; \\n&quot;;  &#125;private:  string colors;&#125;;//绿色class green:public color&#123;public:  green():colors(&quot;绿色&quot;) &#123;&#125;  void fillcolor()  &#123;    cout &lt;&lt; &quot;\\t颜色：\\t&quot; &lt;&lt; colors &lt;&lt; &quot; \\n&quot;;  &#125;private:  string colors;&#125;;//形状class Shape&#123;public:  virtual void ShowShape() = 0;  virtual void SetColor(color* color) = 0;protected:  virtual void DrawShape() = 0;  virtual void DrawColor() = 0;  color* colors;&#125;;//圆class circle:public Shape&#123;public:  circle() :shape(&quot;圆&quot;) &#123;&#125;  void ShowShape()  &#123;    DrawShape();    DrawColor();  &#125;  void SetColor(color* colors)  &#123;    this-&gt;colors = colors;  &#125;private:  void DrawShape()  &#123;    cout &lt;&lt; &quot;形状：\\t&quot; &lt;&lt; shape;  &#125;  void DrawColor()  &#123;    this-&gt;colors-&gt;fillcolor();  &#125;  string shape;&#125;;//正方形class square :public Shape&#123;public:  square() :shape(&quot;正方形&quot;) &#123;&#125;  void ShowShape()  &#123;    DrawShape();    DrawColor();  &#125;  void SetColor(color* colors)  &#123;    this-&gt;colors = colors;  &#125;private:  void DrawShape()  &#123;    cout &lt;&lt; &quot;形状：\\t&quot; &lt;&lt; shape;  &#125;  void DrawColor()  &#123;    this-&gt;colors-&gt;fillcolor();  &#125;  string shape;&#125;;int main()&#123;  //创造一个红正方形  Shape* s = new square;  s-&gt;SetColor(new red);  s-&gt;ShowShape();  //创造一个绿圆  Shape* t = new circle;  t-&gt;SetColor(new green);  t-&gt;ShowShape();  return 0;&#125;\n\n外观模式什么是外观模式外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口\n为什么使用外观模式外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便。\n外观模式实现步骤1.提供一个外观类:为调用方, 定义简单的调用接口\n2.提供一个调用者类:通过外观类接口调用提供某功能的内部类群\n3.多个功能提供者类:提供功能的类群（模块或子系统）\n外观模式优缺点优点\n\n你可以让自己的代码独立于复杂子系统\n\n缺点\n\n外观可能成为与程序中所有类都耦合的上帝对象(了解过多或者负责过多的对象)\n\n外观模式实现代码#include&lt;iostream&gt;using namespace std;//多个工作类class one&#123;public:  void dis()  &#123;    cout &lt;&lt; &quot;程序一运行中.....\\n&quot;;  &#125;&#125;;class two&#123;public:  void dis()  &#123;    cout &lt;&lt; &quot;程序二运行中.....\\n&quot;;  &#125;&#125;;class three&#123;public:  void dis()  &#123;    cout &lt;&lt; &quot;程序三运行中.....\\n&quot;;  &#125;&#125;;class four&#123;public:  void dis()  &#123;    cout &lt;&lt; &quot;程序四运行中.....\\n&quot;;  &#125;&#125;;class face&#123;public:  void dis()  &#123;    one q;    two w;    three e;    four r;    q.dis();    w.dis();    e.dis();    r.dis();    cout &lt;&lt; &quot;各个程序正在运行&quot;;  &#125;&#125;;int main()&#123;  face* s = new face;  s-&gt;dis();  return 0;&#125;\n\n享元模式什么是享元模式享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n为什么使用享元模式通过复用相同的对象来减少对象的创建数量，创建更小的对象组，并通过共享实现重用。通过归类，将对象的属性分为内蕴状态和外蕴状态。\n外蕴状态是对象的外部描述，是每个对象的可变部分，比如对工具的使用地点、使用时间、使用人、工作内容的描述，这些属性不属于对象本身，而是根据每回使用情况进行变化的，这就需要制作成接口进行外部调用，而外蕴状态的维护是由调用者维护的，对象内不进行维护。\n享元模式实现步骤1.提供一个抽象享元角色类:具体享元类的父类，规定一些需要实现的公共接口\n2.提供一个或者多个具体享元角色:实现了抽象享元角色规定的方法\n3.提供一个享元工厂角色类:负责创建和管理享元角色\n享元模式优缺点优点\n\n如果程序中有很多相似对象， 那么你将可以节省大量内存。\n\n缺点\n\n你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。\n代码会变得更加复杂。\n\n享元模式实现代码#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;sstream&gt;#include &lt;initializer_list&gt;using namespace std;//以车库提车为例//共享信息class SharedState&#123;public:  SharedState(const string&amp; p, const string&amp; x, const string&amp; c):pinpai(p),xinghao(x),color(c)&#123;&#125;  string getpinpai() &#123; return pinpai; &#125;  string getxinghao() &#123; return xinghao; &#125;  string getcolor() &#123; return color; &#125;  friend ostream&amp; operator&lt;&lt;(ostream&amp; out, SharedState t)  &#123;    return out &lt;&lt; t.pinpai &lt;&lt; &quot; &quot; &lt;&lt; t.xinghao &lt;&lt; &quot; &quot; &lt;&lt; t.color;  &#125;private:  string pinpai;//品牌  string xinghao;//型号  string color;//颜色&#125;;//非共享信息class  UniqueState&#123;public:  UniqueState(const string cz,const string cp):chezhu(cz),chepai(cp)&#123;&#125;  string getchezhu() &#123; return chezhu; &#125;  string getchepai() &#123; return chepai; &#125;  friend ostream&amp; operator&lt;&lt;(ostream&amp; out, UniqueState t)  &#123;    return out &lt;&lt; t.chezhu &lt;&lt; &quot; &quot; &lt;&lt; t.chepai;  &#125;private:  string chezhu;//车主  string chepai;//车牌&#125;;//信息节点class node&#123;private:  SharedState* s;public:  node(const SharedState* t):s(new SharedState(*t))&#123;&#125;//浅拷贝，使用类默认的拷贝构造即可  node(const node* t):s(new SharedState(*(t-&gt;s)))&#123;&#125;  SharedState* getsharedstate()  &#123;    return s;  &#125;  //输出信息  void show(const UniqueState&amp; p)const  &#123;    cout &lt;&lt; &quot;共享信息：&quot;&lt;&lt;s&lt;&lt; endl;    cout &lt;&lt; &quot;私有信息：&quot; &lt;&lt;p &lt;&lt; endl;  &#125;&#125;;//综合管理class management&#123;public:  management(initializer_list&lt;SharedState&gt; sh)  &#123;    for (auto y:sh)    &#123;      this-&gt;s.insert(make_pair&lt;string, node&gt;(this-&gt;getkay(y), node(&amp;y)));    &#125;  &#125;  //找到车型  node findcar(const SharedState&amp; t)  &#123;      if (this-&gt;s.find(getkay(t))==this-&gt;s.end())      &#123;        cout &lt;&lt; &quot;未找到车型\\n&quot;;        s.insert(make_pair&lt;string, node&gt;(this-&gt;getkay(t), node(&amp;t)));      &#125;      else      &#123;        cout &lt;&lt; &quot;找到车型\\n&quot;;      &#125;      return this-&gt;s.at(getkay(t));  &#125;private:  map&lt;string, node&gt; s;  string getkay(SharedState t)//得到键值  &#123;    return t.getpinpai() + &quot;_&quot; + t.getxinghao() + &quot;_&quot; + t.getcolor();  &#125;&#125;;void AddCarToPoliceDataBase(management&amp; ff,  const string&amp; plates, const string&amp; ower,  const string&amp; brand, const string&amp; model, const string&amp; color)&#123;  cout &lt;&lt; &quot;车型匹配结果:&quot; &lt;&lt; endl;  const node&amp; flyweight = ff.findcar(&#123; brand,model,color &#125;);  flyweight.show(&#123; ower,plates&#125;);&#125;int main()&#123;  management* factory = new  management(    &#123; &#123;&quot;雪佛兰&quot;, &quot;Camaro2020&quot;, &quot;pink&quot;&#125;,    &#123;&quot;奔驰&quot;, &quot;C43&quot;, &quot;black&quot;&#125;,    &#123;&quot;奔驰&quot;, &quot;C63&quot;, &quot;red&quot;&#125;,    &#123;&quot;宝马&quot;, &quot;M6&quot;, &quot;red&quot;&#125;,    &#123;&quot;宝马&quot;, &quot;X7&quot;, &quot;white&quot;&#125; &#125;);  AddCarToPoliceDataBase(*factory,    &quot;DK88888&quot;,    &quot;顽石&quot;,    &quot;宝马&quot;,    &quot;M6&quot;,    &quot;red&quot;);  AddCarToPoliceDataBase(*factory,    &quot;DK66666&quot;,    &quot;里奇&quot;,    &quot;宝马&quot;,    &quot;X7&quot;,    &quot;red&quot;);  delete factory;  return 0;&#125; \n\n组合模式什么是组合模式组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。\n为什么使用组合模式组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。 组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。\n组合模式实现步骤1.提供一个组件类：描述复杂元素的通用接口和方法\n2.创建一个叶子节点类：描述简单元素\n3.提供一个容器类：表示复杂元素\n4.容器类中定义添加和删除子元素的方法\n组合模式优缺点优点\n\n你可以利用多态和递归机制更方便地使用复杂树结构。\n开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。\n\n缺点\n\n对于功能差异较大的类， 提供公共接口或许会有困难。 \n在一些特定情况下，可以存在过度一般化组件接口， 使其变得令人难以理解。\n\n组合模式实现代码#include&lt;iostream&gt;#include&lt;list&gt;#include&lt;string&gt;using namespace std;class Root//虚拟类&#123;public:\tvirtual void showname() = 0;\tvirtual void add(Root* p) = 0;\tvirtual void Remove(Root* p) = 0;\tvirtual list&lt;Root*&gt; Getchild() = 0;&#125;;class File :public Root//文件位置&#123;public:\tFile(string name) :name(name) &#123;&#125;\tvoid showname() \t&#123;\t\tcout &lt;&lt; name;\t&#125;\tvoid add(Root* p) &#123;&#125;\tvoid Remove(Root* p) &#123;&#125;\tlist&lt;Root*&gt; Getchild() &#123; return s; &#125;private:\tlist&lt;Root*&gt; s;\tstring name;&#125;;class floder :public Root//文件夹位置&#123;public:\tfloder(string name) :name(name) &#123;&#125;\tvoid showname()\t&#123;\t\tcout &lt;&lt; name;\t&#125;\tvoid add(Root* p) \t&#123;\t\ts.push_back(p);\t&#125;\tvoid Remove(Root* p) \t&#123;\t\ts.remove(p);\t&#125;\tlist&lt;Root*&gt; Getchild() &#123; return s; &#125;private:\tstring name;\tlist&lt;Root*&gt; s;&#125;;//统一接口void UsShow(Root* t, int n)&#123;\tlist&lt;Root* &gt;root;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tcout &lt;&lt; &quot;/&quot;;\t&#125;\tt-&gt;showname();\troot = t-&gt;Getchild();\tif (!root.empty())\t&#123;\t\tfor (auto v : root)\t\t&#123;\t\t\tif (v-&gt;Getchild().empty())\t\t\t&#123;\t\t\t\tfor (int i = 0; i &lt; n; i++)\t\t\t\t&#123;\t\t\t\t\tcout &lt;&lt; &quot;/&quot;;\t\t\t\t&#125;\t\t\t\tv-&gt;showname();\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tcout &lt;&lt; endl;\t\t\t\tUsShow(v, n + 1);\t\t\t&#125;\t\t&#125;\t&#125;&#125;int main()&#123;\tfloder* root = new floder(&quot;C:&quot;);\tfloder* D1 = new floder(&quot;1&quot;);\tFile* T1 = new File(&quot;TEXT1.txt&quot;);\tfloder* D2 = new floder(&quot;2&quot;);\tFile* T2 = new File(&quot;TEXT2.txt&quot;);\troot-&gt;add(D1);\troot-&gt;add(D2);\tD1-&gt;add(T1);\tD2-&gt;add(T2);\tUsShow(root, 0);\treturn 0;&#125;\n\n模板模式什么是模板模式模板方法是一种行为设计模式， 它在基类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n为什么使用模板模式在抽象类中统一操作步骤，并规定好接口，让子类实现接口。这样可以把各个具体的子类和操作步骤解耦合。你只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时，可使用模板方法模式。当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。但其后果就是，只要算法发生变化， 你就可能需要修改所有的类。\n模板模式实现步骤1.提供一个抽象类：负责规定好接口，让子类实现接口，定义一个模板方法\n2.提供具体实现子类:实现抽象类的抽象接口即可\n模板模式优缺点优点\n\n你可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小\n你可将重复代码提取到一个超类中\n\n缺点\n\n部分客户端可能会受到算法框架的限制\n通过子类抑制默认步骤实现可能会导致违反里氏替换原则\n模板方法中的步骤越多， 其维护工作就可能会越困难\n\n模板模式实现代码#include&lt;iostream&gt;using namespace std;class basics&#123;public:\tvirtual void head() = 0;\tvirtual void body() = 0;\tvirtual void clothes() = 0;\tvoid all()\t&#123;\t\thead();\t\tbody();\t\tclothes();\t&#125;&#125;;class one :public basics&#123;public:\tvoid head()\t&#123;\t\tcout &lt;&lt; &quot;长发 &quot;;\t&#125;\tvoid body()\t&#123;\t\tcout &lt;&lt; &quot;微胖 &quot;;\t&#125;\tvoid clothes()\t&#123;\t\tcout &lt;&lt; &quot;长裙&quot; &lt;&lt; endl;\t&#125;&#125;;class two :public basics&#123;public:\tvoid head()\t&#123;\t\tcout &lt;&lt; &quot;偏分 &quot;;\t&#125;\tvoid body()\t&#123;\t\tcout &lt;&lt; &quot;有腹肌 &quot;;\t&#125;\tvoid clothes()\t&#123;\t\tcout &lt;&lt; &quot;西服&quot; &lt;&lt; endl;\t&#125;&#125;;int main()&#123;\tbasics* a = new one;\tbasics* b = new two;\ta-&gt;all();\tb-&gt;all();\treturn 0;&#125;\n\n命令模式什么是命令模式命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。\n为什么使用命令模式在面向对象的程序设计中，一个对象调用另一个对象，整个调用过程比较繁杂，或者存在多处这种调用。这时，使用命令模式对该调用加 以封装，便于功能的再利用。命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。\n命令模式实现步骤1.声明仅有一个执行方法的命令抽象类\n2.抽取请求并使之成为实现命令接口的具体命令类\n3.找到担任发送者职责的类\n4.修改发送者使其执行命令， 而非直接将请求发送给接收者\n5.客户端必须按照以下顺序来初始化对象\n\n创建接收者。\n创建命令， 如有需要可将其关联至接收者。\n创建发送者并将其与特定命令关联。\n\n命令模式优缺点优点\n\n单一职责原则:你可以解耦触发和执行操作的类\n开闭原则:你可以在不修改已有客户端代码的情况下在程序中创建新的命令\n你可以实现撤销和恢复功能\n你可以实现操作的延迟执行\n你可以将一组简单命令组合成一个复杂命令\n\n缺点\n\n代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次\n\n命令模式实现代码#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;//以餐厅为例//厨师class cooker&#123;public:\tvoid cook_unique_technique()\t&#123;\t\tcout &lt;&lt; &quot;辣子鸡一份\\n&quot;;\t&#125;\tvoid cook_specialty_dish()\t&#123;\t\tcout &lt;&lt; &quot;九转大肠一份\\n&quot;;\t&#125;&#125;;//抽象命令class order&#123;public:\torder(cooker* s):p(s)&#123;&#125;\tvirtual void cook() = 0;\tvirtual void nocook() = 0;protected:\tcooker* p;&#125;;//具体命令1class order1:public order&#123;public:\torder1(cooker* s) :order(s) &#123;&#125;\tvoid cook()\t&#123;\t\tp-&gt;cook_specialty_dish();\t&#125;\tvoid nocook()\t&#123;\t\tcout &lt;&lt; &quot;取消厨师拿手菜\\n&quot;;\t&#125;&#125;;//具体命令2class order2 :public order&#123;public:\torder2(cooker* s) :order(s) &#123;&#125;\tvoid cook()\t&#123;\t\tp-&gt;cook_unique_technique();\t&#125;\tvoid nocook()\t&#123;\t\tcout &lt;&lt; &quot;取消本店招牌菜\\n&quot;;\t&#125;&#125;;//点菜class order_dishes&#123;public:\tvoid setOder(order* s)\t&#123;\t\ts-&gt;cook();\t\tl.push_back(s);\t&#125;\tvoid unOder(order* s)\t&#123;\t\ts-&gt;nocook();\t\tl.remove(s);\t&#125;\tvoid in_all()\t&#123;\t\tfor (auto s : l)\t\t&#123;\t\t\ts-&gt;cook();\t\t&#125;\t&#125;private:\tlist&lt;order*&gt; l;&#125;;int main()&#123;\tcooker* a = new cooker;\torder* s = new order1(a);\torder* d = new order2(a);\torder_dishes* e = new order_dishes;\te-&gt;setOder(s);\te-&gt;unOder(s);\te-&gt;setOder(d);\te-&gt;in_all();\te-&gt;setOder(s);\te-&gt;in_all();\treturn 0;&#125;\n\n责任链模式什么是责任链模式责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。比如有三个项目经理，顺序是A-&gt;B-&gt;C，把所有的项目都先传递给A，A拿到所有的项目后，把属于自己负责的项目留下来，把剩下的传递给B，然后B把属于自己的留下来，把不属于自己的再传递给C。\n为什么使用责任链模式该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。 无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。总的来说链条式处理事情。工作流程化、消息处理流程化、事物流程化。\n责任链模式实现步骤1.提供处理类的抽象父类:抽象客户端如何将请求数据传递给方法\n2.依次创建具体处理者子类并实现其处理方法\n\n是否自行处理这个请求\n是否将该请求沿着链进行传递\n\n3.客户端处理链(组装链+触发处理者)，客户端需要准备好处理以下情况：\n\n链中可能只有单个链接\n\n部分请求可能无法到达链尾\n\n其他请求可能直到链尾都未被处理\n\n\n责任链模式优缺点优点\n\n你可以控制请求处理的顺序\n单一职责原则: 你可对发起操作和执行操作的类进行解耦\n开闭原则:你可以在不更改现有代码的情况下在程序中新增处理者\n\n缺点\n\n部分请求可能未被处理\n\n责任链模式实现代码#include&lt;iostream&gt;using namespace std;//以上班请假为例//抽象类class lead&#123;public:\tlead():next(nullptr)&#123;&#125;\t//组织链函数\tvoid nexthr(lead* s)\t&#123;\t\tnext = s;\t&#125;\t//向领导请假\tvirtual void leave(int day) = 0;protected:\tlead* next;&#125;;//主管class hr :public lead&#123;public:\tvoid leave(int day)\t&#123;\t\tcout &lt;&lt; &quot;主管说：&quot;;\t\tif (day &lt;= 1)\t\t&#123;\t\t\tcout &lt;&lt; &quot;可以\\n&quot;;\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; &quot;天数太长，找经理\\n&quot;;\t\t\tnext-&gt;leave(day);\t\t&#125;\t&#125;&#125;;//经理class manager :public lead&#123;public:\tvoid leave(int day)\t&#123;\t\tcout &lt;&lt; &quot;经理说：&quot;;\t\tif (day &lt;= 3)\t\t&#123;\t\t\tcout &lt;&lt; &quot;可以\\n&quot;;\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; &quot;天数太长，找老板\\n&quot;;\t\t\tnext-&gt;leave(day);\t\t&#125;\t&#125;&#125;;//老板class boss :public lead&#123;public:\tvoid leave(int day)\t&#123;\t\tcout &lt;&lt; &quot;老板说：&quot;;\t\tif (day &lt;= 30)\t\t&#123;\t\t\tcout &lt;&lt; &quot;可以\\n&quot;;\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; &quot;天数太长，不予批准\\n&quot;;\t\t&#125;\t&#125;&#125;;int main()&#123;\tlead* a = new hr;\tlead* s = new manager;\tlead* d = new boss;\t//组装链\ta-&gt;nexthr(s);\ts-&gt;nexthr(d);\ta-&gt;leave(10);\treturn 0;&#125;\n\n策略模式什么是策略模式策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换\n为什么使用策略模式策略模式让你能够将对象关联至可以不同方式执行特定子任务的不同子对象， 从而以间接方式在运行时更改对象行为。策略模式让你能将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一个， 从而减少重复代码。策略模式让你能将各种算法的代码、 内部数据和依赖关系与其他代码隔离开来。 不同客户端可通过一个简单接口执行算法， 并能在运行时进行切换。策略模式将所有继承自同样接口的算法抽取到独立类中， 因此不再需要条件语句。 原始对象并不实现所有算法的变体， 而是将执行工作委派给其中的一个独立算法对象。从而解决在同一算法的不同变体中切换时避免使用多重条件判断。\n策略模式实现步骤1.提供一个抽象策略类：定义抽象的函数算法让继承的子类实现\n2.提供具体策略类:封装了继续相关的算法和行为，即函数的具体功能的实现\n3.提供一个策略的容器类：根据不同策略执行不同的行为，策略由外部 环境决定\n策略模式优缺点优点\n\n你可以在运行时切换对象内的算法\n你可以将算法的实现和使用算法的代码隔离开来\n你可以使用组合来代替继承\n开闭原则：你无需对上下文进行修改就能够引入新的策略\n\n缺点\n\n如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂\n客户端必须知晓策略间的不同——它需要选择合适的策略\n借助额外的类和接口可能会让代码不够简洁\n\n策略模式实现代码#include&lt;iostream&gt;using namespace std;//以计算器为例class calculator&#123;public:\tvirtual int ex(int a,int b) = 0;&#125;;class add :public calculator&#123;public:\tint ex(int a, int b)\t&#123;\t\treturn a + b;\t&#125;&#125;;class cc :public calculator&#123;public:\tint ex(int a, int b)\t&#123;\t\tif(b!=0)\t\treturn a / b;\t&#125;&#125;;class sub :public calculator&#123;public:\tint ex(int a, int b)\t&#123;\t\treturn a - b;\t&#125;&#125;;class ee :public calculator&#123;public:\tint ex(int a, int b)\t&#123;\t\treturn a * b;\t&#125;&#125;;class ll&#123;public:\tvoid set(calculator* s)\t&#123;\t\tthis-&gt;s = s;\t&#125;\tvoid calculate(int a,int b)\t&#123;\t\tcout &lt;&lt; s-&gt;ex(a, b) &lt;&lt; endl;\t&#125;private:\tcalculator* s;&#125;;int main()&#123;\tll* s = new ll;\tint a, b;\tchar c;\tcin &gt;&gt; a &gt;&gt; c &gt;&gt; b;\tswitch (c)\t&#123;\tcase &#x27;+&#x27;:\t\ts-&gt;set(new add);\t\ts-&gt;calculate(a, b);\t\tbreak;\tcase &#x27;-&#x27;:\t\ts-&gt;set(new sub);\t\ts-&gt;calculate(a, b);\t\tbreak;\tcase &#x27;*&#x27;:\t\ts-&gt;set(new ee);\t\ts-&gt;calculate(a, b);\t\tbreak;\tcase &#x27;/&#x27;:\t\ts-&gt;set(new cc);\t\ts-&gt;calculate(a, b);\t\tbreak;\t&#125;\treturn 0;&#125;\n\n观察者模式什么是观察者模式观察者模式是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其 他关联对象，自动刷新对象状态\n为什么使用观察者模式当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时，观察者模式适合描述此类问题。当应用中的一些对象必须观察其他对象时，可使用该模式，但仅能在有限时间内或特定情况下使用。\n观察者模式实现步骤1.提供一个抽象目标类：被观察的对象，抽象基本的属性状态及其他操作\n2.提供一个具体目标类：被观察的对象对象具体实现\n3.提供一个抽象观察者类：抽象观察者的具体的业务逻辑处理\n4.提供一个具体观察者类：观察者的具体实现，得到通知后将完成一些具体的业务逻辑处理\n观察者模式优缺点优点\n\n开闭原则： 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）\n你可以在运行时建立对象之间的联系\n依赖倒置：让耦合的双方都依赖于抽象,而不是依赖于具体\n\n缺点\n\n被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间\n⼀个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间\n\n观察者模式实现代码#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;class boss;class stuff&#123;public:\tstuff(string name, boss* a) :name(name) &#123; this-&gt;a = a; &#125;\tvoid cc(string dO)\t&#123;\t\tcout &lt;&lt; name &lt;&lt; &quot;观察到：&quot;;\t\tif(dO==&quot;老板在巡视&quot;)\t\t&#123;\t\t\tcout &lt;&lt;dO&lt;&lt; &quot;立刻工作&quot;;\t\t&#125;\t\telse if(dO==&quot;老板走了&quot;)\t\t&#123;\t\t\tcout &lt;&lt; dO &lt;&lt; &quot;开始摸鱼&quot;;\t\t&#125;\t&#125;private:\tboss* a;\tstring name;&#125;;class boss&#123;public:\tvoid seet(stuff* s)\t&#123;\t\te.push_back(s);\t&#125;\tvoid ee(string ss)\t&#123;\t\tfor (auto s : e)\t\t&#123;\t\t\ts-&gt;cc(ss);\t\t&#125;\t&#125;private:\tvector&lt;stuff*&gt; e;&#125;;int main()&#123;\tboss* a = new boss;\tstuff* s = new stuff(&quot;一一&quot;,a);\ta-&gt;seet(s);\ta-&gt;ee(&quot;老板在巡视&quot;);\treturn 0;&#125;\n\n访问者模式什么是访问者模式访问者模式是行为模式之一，它分离对象的数据和行为，使用访问者模式模式，可以不修改已有类的情况下，增加新的操作角色和职责\n为什么使用访问者模式访问者模式通过在访问者对象中为多个目标类提供相同操作的变体， 让你能在属于不同类的一组对象上执行同一操作；访问者模式将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作；当某个行为仅在类层次结构中的一些类中有意义，而在其他类中没有意义时，你可将该行为抽取到单独的访问者类中， 只需实现接收相关类的对象作为参数的访问者方法并将其他方法留空即可。\n访问者模式实现步骤1.提供一个抽象访问者类：声明了一个或者多个访问操作，形成所有的具体元素角色必须实现的抽象方法\n2.提供一个具体访问者类:实现抽象访问者角色所声明的抽象方法，也就是抽象访问者所声明的各个访问操作\n3.提供一个抽象被访问者类:声明一个接受操作，接受一个访问者对象作为一个变量的抽象方法\n4.提供一个或多个被访问者类:被访问者的抽象方法的具体实现\n5.提供一个结构对象类:可以遍历结构中的所有元素；如果有需要，可提供访问元素接口，元素可设计存储到容器中\n访问者模式优缺点优点\n\n开闭原则: 你可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改\n单一职责原则: 可将同一行为的不同版本移到同一个类中\n访问者对象可以在与各种对象交互时收集一些有用的信息\n\n缺点\n\n每次在元素层次结构中添加或移除一个类时， 你都要更新所有的访问者\n在访问者同某个元素进行交互时， 它们可能没有访问元素私有成员变量和方法的必要权限\n\n访问者模式实现代码#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;list&gt;using namespace std;class scenes;//抽象旅客类class Votcer&#123;public:\tvirtual void look(scenes* s) = 0;protected:\tstring name;&#125;;//抽象场景类-----------要放在前面，否者会报错class scenes&#123;public:\tvirtual void df(Votcer* s) = 0;\tstring getdf() &#123; return dfs; &#125;protected:\tstring dfs;&#125;;//具体旅客类class man :public Votcer&#123;public:\tman()\t&#123;\t\tname = &quot;男生&quot;;\t&#125;\tvoid look(scenes* s)\t&#123;\t\tcout &lt;&lt; name &lt;&lt; &quot;在 &quot; &lt;&lt;s-&gt;getdf()&lt;&lt; &quot;散步&quot; &lt;&lt; endl;\t&#125;&#125;;class woman :public Votcer&#123;public:\twoman()\t&#123;\t\tname = &quot;女生&quot;;\t&#125;\tvoid look(scenes* s)\t&#123;\t\tcout &lt;&lt; name &lt;&lt; &quot;在 &quot; &lt;&lt; s-&gt;getdf() &lt;&lt; &quot;看风景&quot; &lt;&lt; endl;\t&#125;&#125;;//具体场景类class lake:public scenes&#123;public:\tlake()\t&#123;\t\tdfs = &quot;湖&quot;;\t&#125;\tvoid df(Votcer* s)\t&#123;\t\ts-&gt;look(this);\t&#125;&#125;;class woods :public scenes&#123;public:\twoods()\t&#123;\t\tdfs = &quot;小树林&quot;;\t&#125;\tvoid df(Votcer* s)\t&#123;\t\ts-&gt;look(this);\t&#125;&#125;;//管理类class gll&#123;public:\tvoid seet(scenes* b)\t&#123;\t\ts.push_back(b);\t&#125;\tvoid ggt(Votcer* f)\t&#123;\t\tfor (auto v : s)\t\t&#123;\t\t\tv-&gt;df(f);\t\t&#125;\t&#125;private:\tlist&lt;scenes*&gt; s;&#125;;int main()&#123;\tgll* s = new gll;\tVotcer* a = new man;\tVotcer* b = new woman;\tscenes* d = new lake;\tscenes* w = new woods;\ts-&gt;seet(d);\ts-&gt;seet(w);\ts-&gt;ggt(a);\ts-&gt;ggt(b);\treturn 0;&#125;\n\n中介者模式什么是中介者模式中介者模式是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作\n为什么使用中介者模式该模式让你将对象间的所有关系抽取成为一个单独的类， 以使对于特定组件的修改工作独立于其他组件，由于所有组件间关系都被包含在中介者中， 因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式。一般来说，大型的软件在开发的过程中会使用模块化的开发方式。但是无论模块之间如何独立，总是会有需要模块间通信的时候，如果模块有很多，且每个模块都向外提供了唯一的接收消息的接口，那么一个模块如果需要与其他所有模块通信，则需要记录其他所有模块的通信接口，同理每个模块都要记录所有与自己相关联的模块的通信接口。首先这就是一件很冗余并降低开发效率的事情，其次，一旦有一天，某个模块修改了自己所提供的通信接口，或者增加了一个新模块，尤其是后者，在公司项目发展过程中是很正常的事情。那么所有模块关于其他模块通信接口的记录可能都需要修改或增加，这在拥有庞大模块数量的项目中，是很恐怖的事情，此时可以考虑中介者模式\n中介者模式实现步骤1.抽象一个中介者类：定义对象到中介者对象的接口\n2.提供一个具体中介者类：实现抽象接口，并且实现关联类数据处理\n3.提供一个关联类(同事类)的抽象父类 ：多个关联类之间的交互操作的抽象\n4.提供一个或多个具体的关联类(同事类)：实现抽象，通过中介者类完成操作\n中介者模式优缺点优点\n\n单一职责原则: 你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护\n开闭原则: 你无需修改实际组件就能增加新的中介者\n你可以减轻应用中多个组件间的耦合情况\n你可以更方便地复用各个组件\n\n缺点\n\n一段时间后， 中介者可能会演化成为上帝对象\n\n中介者模式实现代码//三平台通信#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;enum class Message&#123;\tATW_MESSAGE,\t\t//移动端到Win\tATM_MESSAGE,\t\t//移动端到Mac\tWTM_MESSAGE,\t\t//Mac到Win&#125;;class AbstractModule;//提供转发接口class AbstractMediator&#123;public:\tvirtual void Transmit(Message message, AbstractModule* pm) = 0;&#125;;class AbstractModule &#123;public:\tAbstractModule(AbstractMediator* pM) :pM(pM) &#123;&#125;\tvoid SendMessage(Message message) \t&#123;\t\tpM-&gt;Transmit(message, this);\t&#125;\tvirtual void  AcceptMessage(Message message) = 0;protected:\tAbstractMediator* pM;&#125;;class App :public AbstractModule&#123;public:\tApp(AbstractMediator* pM) :AbstractModule(pM) &#123;&#125;\tvoid  AcceptMessage(Message message) \t&#123;\t\tswitch (message) \t\t&#123;\t\tcase Message::ATM_MESSAGE:\t\t\tcout &lt;&lt; &quot;App to Mac&quot; &lt;&lt; endl;\t\t\tbreak;\t\tcase Message::ATW_MESSAGE:\t\t\tcout &lt;&lt; &quot;App to Win&quot; &lt;&lt; endl;\t\t\tbreak;\t\t&#125;\t&#125;&#125;;class Win :public AbstractModule&#123;public:\tWin(AbstractMediator* pM) :AbstractModule(pM) &#123;&#125;\tvoid  AcceptMessage(Message message)\t&#123;\t\tswitch (message)\t\t&#123;\t\tcase Message::WTM_MESSAGE:\t\t\tcout &lt;&lt; &quot;Win to Mac&quot; &lt;&lt; endl;\t\t\tbreak;\t\tcase Message::ATW_MESSAGE:\t\t\tcout &lt;&lt; &quot;App to Win&quot; &lt;&lt; endl;\t\t\tbreak;\t\t&#125;\t&#125;&#125;;class Mac :public AbstractModule &#123;public:\tMac(AbstractMediator* pM) :AbstractModule(pM) &#123;&#125;\tvoid  AcceptMessage(Message message)\t&#123;\t\tswitch (message)\t\t&#123;\t\tcase Message::WTM_MESSAGE:\t\t\tcout &lt;&lt; &quot;Win to Mac&quot; &lt;&lt; endl;\t\t\tbreak;\t\tcase Message::ATM_MESSAGE:\t\t\tcout &lt;&lt; &quot;App to Mac&quot; &lt;&lt; endl;\t\t\tbreak;\t\t&#125;\t&#125;&#125;;//中介者实现类class ConcreteMediator :public AbstractMediator &#123;public:\tvoid Transmit(Message message, AbstractModule* pM) \t&#123;\t\tswitch (message)\t\t&#123;\t\tcase Message::ATM_MESSAGE:\t\t&#123;\t\t\t//能通过dynamic_cast转换为不为NULL的指针,可确认指针指向的子类类型\t\t\tApp* app = dynamic_cast&lt;App*&gt;(pM);\t\t\tif (NULL != app)\t\t\t&#123;\t\t\t\tm_mac-&gt;AcceptMessage(message);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tapp-&gt;AcceptMessage(message);\t\t\t&#125;\t\t\tbreak;\t\t&#125;\t\tcase Message::ATW_MESSAGE: \t\t&#123;\t\t\tApp* app = dynamic_cast&lt;App*&gt;(pM);\t\t\tif (NULL != app)\t\t\t&#123;\t\t\t\tm_win-&gt;AcceptMessage(message);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tapp-&gt;AcceptMessage(message);\t\t\t&#125;\t\t\tbreak;\t\t&#125;\t\tcase Message::WTM_MESSAGE:\t\t&#123;\t\t\tWin* win = dynamic_cast&lt;Win*&gt;(pM);\t\t\tif (NULL != win)\t\t\t&#123;\t\t\t\tm_mac-&gt;AcceptMessage(message);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\twin-&gt;AcceptMessage(message);\t\t\t&#125;\t\t\tbreak;\t\t&#125;\t\t&#125;\t&#125;\tvoid SetModuleApp(AbstractModule* app) \t&#123;\t\tthis-&gt;m_app = app;\t&#125;\tvoid SetModuleWin(AbstractModule* win)\t&#123;\t\tthis-&gt;m_win = win;\t&#125;\tvoid SetModuleMac(AbstractModule* mac)\t&#123;\t\tthis-&gt;m_mac = mac;\t&#125;private:\tAbstractModule* m_app=nullptr;\tAbstractModule* m_win= nullptr;\tAbstractModule* m_mac= nullptr;&#125;;int main() &#123;\tAbstractMediator* pM = new ConcreteMediator;\t//指定中介者\tAbstractModule* app = new App(pM);\tAbstractModule* win = new Win(pM);\tAbstractModule* mac = new Mac(pM);\t//为中介者设定模块\tConcreteMediator* pC = dynamic_cast&lt;ConcreteMediator*&gt;(pM);\tpC-&gt;SetModuleApp(app);\tpC-&gt;SetModuleWin(win);\tpC-&gt;SetModuleMac(mac);\t//模块间通信\tapp-&gt;SendMessage(Message::ATM_MESSAGE);\tapp-&gt;SendMessage(Message::ATW_MESSAGE);\twin-&gt;SendMessage(Message::WTM_MESSAGE);\treturn 0;&#125;\n\n备忘录模式什么是备忘录模式备忘录模式是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。（浏览器回退、编辑器撤销与重做、虚拟机生成快照与恢复、游戏悔棋等）\n为什么使用备忘录模式备忘录模式允许你复制对象中的全部状态 （包括私有成员变量）， 并将其独立于对象进行保存。 尽管大部分人因为 “撤销” 这个用例才记得该模式， 但其实它在处理事务 （比如需要在出现错误时回滚一个操作） 的过程中也必不可少;备忘录让对象自行负责创建其状态的快照。 任何其他对象都不能读取快照， 这有效地保障了数据的安全性\n备忘录模式实现步骤1.提供一个原生器类：真正要被保存或恢复的对象，其负责创建一个备忘录，可以存储、恢复需要状态信息\n2.提供一个备忘录类：用于存储原生器对象的的内部状态，防止外部直接访问原生器对象\n3.提供一个管理者类：负责存储备忘录，但不能对备忘录内容进行操作和访问，只能将备忘录传递给其他对象\n备忘录模式优缺点优点\n\n你可以在不破坏对象封装情况的前提下创建对象状态快照\n你可以通过让负责人维护原发器状态历史记录来简化原发器代码\n\n缺点\n\n如果客户端过于频繁地创建备忘录， 程序将消耗大量内存\n负责人必须完整跟踪原发器的生命周期， 这样才能销毁弃用的备忘录\n\n备忘录模式实现代码#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;//象棋为例的下棋退步问题//原生类class chess&#123;public:\tchess(string name,pair&lt;int,int&gt; s):name(name),s(s)&#123;&#125;\tvoid setstop(string name, pair&lt;int, int&gt; s)\t&#123;\t\tthis-&gt;name = name;\t\tthis-&gt;s = s;\t&#125;\tstring getname()\t&#123;\t\treturn name;\t&#125;\tpair&lt;int, int&gt; getss()\t&#123;\t\treturn s;\t&#125;\tvoid show()\t&#123;\t\tcout &lt;&lt; name &lt;&lt; &quot;:(&quot; &lt;&lt; s.first &lt;&lt; &quot;,&quot; &lt;&lt; s.second &lt;&lt;&quot;)&quot; &lt;&lt; endl;\t&#125;protected:\tstring name;\tpair&lt;int, int&gt; s;&#125;;//备忘录类class Memento&#123;public:\tMemento(string name, pair&lt;int, int&gt; s) :name(name), s(s) &#123;&#125;\t//保存\tchess* saves()\t&#123;\t\treturn new chess(name, s);\t&#125;\t//回退\tvoid backspacing(chess* t)\t&#123;\t\tname = t-&gt;getname();\t\ts = t-&gt;getss();\t&#125;\tvoid SetChess(string name, pair&lt;int, int&gt; pos)\t&#123;\t\tthis-&gt;name = name;\t\tthis-&gt;s = pos;\t&#125;protected:\tstring name;\tpair&lt;int, int&gt; s;&#125;;//管理类class Caretaker&#123;public:\t//存档\tvoid  AddMento(chess* s)\t&#123;\t\te.push(s);\t\ts-&gt;show();\t&#125;\t//获取上一步\tchess* GetMemento()\t&#123;\t\te.pop();\t\treturn e.top();\t&#125;\tvoid show()\t&#123;\t\te.top()-&gt;show();\t&#125;private:\tstack&lt;chess*&gt; e;\tint stop=0;&#125;;int main()&#123;\tMemento* e = new Memento(&quot;车&quot;, &#123; 4,3 &#125;);\tCaretaker* s = new Caretaker;\ts-&gt;AddMento(e-&gt;saves());\te-&gt;SetChess(&quot;马&quot;, &#123; 8,8 &#125;);\ts-&gt;AddMento(e-&gt;saves());\te-&gt;SetChess(&quot;炮&quot;, &#123; 6,6 &#125;);\ts-&gt;AddMento(e-&gt;saves());\tcout &lt;&lt; endl;\ts-&gt;show();\ts-&gt;GetMemento();\tcout &lt;&lt; endl;\ts-&gt;show();\treturn 0;&#125;\n\n状态模式什么是状态模式状态模式是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样\n为什么使用状态模式模式建议你将所有特定于状态的代码抽取到一组独立的类中。 这样一来， 你可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本;状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复\n状态模式实现步骤1.提供一个上下文环境类:抽象一个客户程序需要的接口，将与状态相关的操作委托给当前的具体状态类对象来处理\n2.提供一个抽象给状态类：定义一个接口以封装使用上下文环境的的一个特定状态相关的行为\n3.提供一个具体状态类:实现抽象状态定义的接口\n状态模式优缺点优点\n\n单一职责原则: 将与特定状态相关的代码放在单独的类中\n开闭原则: 无需修改已有状态类和上下文就能引入新状态\n通过消除臃肿的状态机条件语句简化上下文代码\n\n缺点\n\n如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作\n\n状态模式实现代码//#include &lt;iostream&gt;using namespace std;class Context;class AbstractState &#123;public:\tvirtual void Handle(Context* p) = 0;&#125;;class ConcreteStateA :public AbstractState &#123;\tvoid Handle(Context* p)\t&#123;\t\tcout &lt;&lt; &quot;A.....&quot; &lt;&lt; endl;\t&#125;&#125;;class ConcreteStateB :public AbstractState&#123;\tvoid Handle(Context* p)\t&#123;\t\tcout &lt;&lt; &quot;B.....&quot; &lt;&lt; endl;\t&#125;&#125;;class Context &#123;public:\tContext(AbstractState* pstate) :pstate(pstate) &#123;&#125;\tvoid  Requst() \t&#123;\t\tif (pstate) \t\t&#123;\t\t\tpstate-&gt;Handle(this);\t\t&#125;\t&#125;\tvoid ChangeState(AbstractState* pstate) \t&#123;\t\tthis-&gt;pstate = pstate;\t&#125;private:\tAbstractState* pstate;&#125;;int main()&#123;\tAbstractState* pA = new ConcreteStateA;\tAbstractState* pB = new ConcreteStateB;\tContext* pC = new Context(pA);\tpC-&gt;Requst();\tpC-&gt;ChangeState(pB);\tpC-&gt;Requst();\treturn 0;&#125;\n\n解释器模式什么是解释器模式解释器模式是属于行为型模式，它提供了评估语言的语法或表达式的方式，这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。\n为什么使用解释器模式在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的\n解释器模式实现步骤1.提供一个解释器上下文环境类：用来存储解释器的上下文环境，比如需要解释的文法，一般用来传递被所有解释器共享的数据\n2.提供一个解释器抽象类:定义解释器的接口，约定解释器的解释操作\n3.提供一个终结符解释器的具体实现类:用来实现语法规则中和终结符相关的操作\n4.提供一个非终结符解释器：用来实现语法规则中非终结符相关的操作，通常一个解释器对应一个语法规则，可以包含其他解释器\n解释器模式优缺点优点\n\n扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。\n容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易\n\n缺点\n\n执行效率较低。解释器模式中通常使用大量的循环和递归调用，句子较复杂时，运行速度很慢，且代码的调试过程也比较麻烦\n会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护\n\n解释器模式实现代码//a+b-c 表达式求值运算#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;typeinfo&gt;using namespace std;//抽象表达式class Expression&#123;public:\tvirtual int Interpreter(map&lt;string, int&gt;&amp; var) = 0;&#125;;//变量解析器class VarExpression :public Expression &#123;public:\tVarExpression(string key) \t&#123;\t\tthis-&gt;key = key;\t&#125;\tint Interpreter(map&lt;string, int&gt;&amp; var) \t&#123;\t\treturn var[key];\t&#125;private:\tstring key;&#125;;//运算符解析器class SymbolExpression :public Expression &#123;protected:\tExpression* left;\tExpression* right;public:\tSymbolExpression(Expression* left, Expression* right) :left(left), right(right) &#123;&#125;\tExpression* GetLeft() &#123; return left; &#125;\tExpression* GetRight() &#123; return right; &#125;&#125;;//加法解析器class AddExpresion :public SymbolExpression &#123;public:\tAddExpresion(Expression* left, Expression* right) :SymbolExpression(left, right) &#123;&#125;\tint Interpreter(map&lt;string, int&gt;&amp; var)\t&#123;\t\treturn left-&gt;Interpreter(var) + right-&gt;Interpreter(var);\t&#125;&#125;;//减法解析器class SubExpresion :public SymbolExpression&#123;public:\tSubExpresion(Expression* left, Expression* right) :SymbolExpression(left, right) &#123;&#125;\tint Interpreter(map&lt;string, int&gt;&amp; var)\t&#123;\t\treturn left-&gt;Interpreter(var) - right-&gt;Interpreter(var);\t&#125;&#125;;//解析器封装类   封装调用接口class Calculator &#123;private:\tExpression* expression;public:\t//解析表达式，构建语法树  a+b-c\tCalculator(string expStr)\t&#123;\t\texpression = NULL;\t\tstack&lt;Expression*&gt; stkExp;\t\tExpression* left = NULL;\t\tExpression* right = NULL;\t\tfor (int i=0;i&lt;expStr.length();i++) \t\t&#123;\t\t\tswitch (expStr[i]) \t\t\t&#123;\t\t\tcase &#x27;+&#x27;:\t\t\t\t//先从栈中取出左操作数\t\t\t\tleft = stkExp.top();\t\t\t\tstkExp.pop();\t\t\t\t//从表达式中取出+号后面的右操作数，并生成终结符解析对象\t\t\t\tright = new VarExpression(expStr.substr(++i, 1));\t\t\t\t//将左右操作数相加，并把结果放入栈中\t\t\t\tstkExp.push(new AddExpresion(left, right));\t\t\t\tbreak;\t\t\tcase &#x27;-&#x27;:\t\t\t\t//先从栈中取出左操作数\t\t\t\tleft = stkExp.top();\t\t\t\tstkExp.pop();\t\t\t\t//从表达式中取出+号后面的右操作数，并生成终结符解析对象\t\t\t\tright = new VarExpression(expStr.substr(++i, 1));\t\t\t\t//将左右操作数相加，并把结果放入栈中\t\t\t\tstkExp.push(new SubExpresion(left, right));\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tstkExp.push(new VarExpression(expStr.substr(i, 1)));\t\t\t&#125;\t\t&#125;\t\t//栈中保存的就是最终语法树的根结点\t\t//本例为SubExpression对象\t\tif (!stkExp.empty()) \t\t&#123;\t\t\texpression = stkExp.top();\t\t\tstkExp.pop();\t\t&#125;\t&#125;\tint Run(map&lt;string, int&gt;&amp; var)\t&#123;\t\treturn (expression == NULL) ? 0 : expression-&gt;Interpreter(var);\t&#125;&#125;;int main() &#123;\tstring expstr = &quot;a+b-c&quot;;\tmap&lt;string, int&gt; var;\tvar[&quot;a&quot;] = 300;\tvar[&quot;b&quot;] = 20;\tvar[&quot;c&quot;] = 30;\tCalculator cal(expstr);\tcout &lt;&lt; cal.Run(var) &lt;&lt; endl;\treturn 0;&#125;\n\n迭代器模式什么是迭代器模式迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （C++STL中的迭代器） 的情况下遍历集合中所有的元素\n为什么使用迭代器模式迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。\n重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。\n迭代器模式实现步骤1.提供一个迭代器类抽象类:抽象实现迭代功能的最小定义方法集\n2.提供一个迭代器类:定义实现迭代功能的最小定义方法集\n3.提供一个容器抽象类:抽象基本功能以及提供类似迭代器类的方法\n4.提供一个容器具体类:定义基本功能以及提供类似迭代器类的方法\n迭代器模式优缺点优点\n\n单一职责原则： 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理\n开闭原则： 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码\n你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态\n\n缺点\n\n如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正\n对于某些特殊集合， 使用迭代器可能比直接遍历的效率低\n\n迭代器模式实现代码//迭代器模式#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T,typename U&gt;class Iterator &#123;public:\ttypedef typename vector&lt;T&gt;::iterator iter_type;\tIterator(U* data, bool reverse = false) :m_data(data)\t&#123;\t\titer = data-&gt;m_data.begin();\t&#125;\tvoid Begin() \t&#123;\t\titer = m_data-&gt;m_data.begin();\t&#125;\tvoid Next() \t&#123;\t\titer++;\t&#125;\tbool End() \t&#123;\t\treturn (iter == m_data-&gt;m_data.end());\t&#125;\titer_type Current() \t&#123;\t\treturn iter;\t&#125;private:\tU* m_data;\titer_type iter;&#125;;template &lt;class T&gt;class Container &#123;\tfriend class Iterator&lt;T, Container&gt;;public:\tvoid Add(T data) \t&#123;\t\tm_data.push_back(data);\t&#125;\tIterator&lt;T, Container&gt;* CreateIterator() \t&#123;\t\treturn new Iterator&lt;T, Container&gt;(this);\t&#125;protected:\tvector&lt;T&gt; m_data;&#125;;class Data &#123;public:\tData(int data = 0) :m_data(data) &#123;&#125;\tvoid SetData(int data) \t&#123;\t\tm_data = data;\t&#125;\tint data() \t&#123;\t\treturn m_data;\t&#125;private:\tint m_data;&#125;;int main() &#123;\tContainer&lt;int&gt; test;\tfor (int i = 0; i &lt; 10; i++) \t&#123;\t\ttest.Add(i);\t&#125;\tIterator&lt;int, Container&lt;int&gt;&gt;* iter = test.CreateIterator();\tfor (iter-&gt;Begin(); !iter-&gt;End(); iter-&gt;Next()) \t&#123;\t\tcout &lt;&lt; *iter-&gt;Current() &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\tContainer&lt;Data&gt; test2;\ttest2.Add(Data(100));\ttest2.Add(Data(200));\ttest2.Add(Data(300));\tIterator&lt;Data, Container&lt;Data&gt;&gt;* iter2 = test2.CreateIterator();\tfor (iter2-&gt;Begin(); !iter2-&gt;End(); iter2-&gt;Next())\t&#123;\t\tcout &lt;&lt; iter2-&gt;Current()-&gt;data() &lt;&lt; &quot; &quot;;\t&#125;\treturn 0;&#125;\n\n设计模式总结创建型的模式总结\n工厂模式模式：单个类的对象创建工作\n抽象工厂模式：多个类的对象创建工作\n单例模式:类的全局对象创建工作\n建造者模式：复杂类的对象创建工作\n原型模式：自身类的克隆工作\n\n结构体型模式总结\n代理模式：提供第三方进行控制访问对象\n装饰者模式：为对象添加新功能\n适配器模式：不兼容的类进行融合过程\n桥接模式：分离变化部分成为独立的一部分\n组合模式：整体和局部进行递归组合\n外观模式: 表面工程(对外提供统一接口访问子系统)\n享元模式:使用对象池减少重复对象的创建\n\n行为型模式总结\n模板方法模式：通过定义一套流程模板进行流程化处理\n命令模式：请求成为命令，记录下\n责任链模式：踢皮球(对象连接成为链，通过链进行传递请求)\n策略模式：封装不同算法，算法之间可以互相转换\n中介者模式：租房中介(中介者类做转发操作)\n观察者模式：交通警察指挥路口(状态发生改变通知观察者)\n备忘录模式：保存对象状态，可以进行恢复\n访问者模式：稳定的数据结构，定义新的操作行为\n状态模式：根据不同的状态做不同的行为\n解释器模式：给定规则，定义语法，定义解释器，做句子分析(摩斯码解析过程)\n迭代器模式：提供一个中方法顺序的访问复合对象的各个元素\n\n关于设计模式的建议\n不存在完美的设计模式，只存在最适合的设计模式\n原有的设计模式并不重要，设计原则才是最重要\n有意无意注意模式问题，通过原则写出自己的设计方法才是最重要的\n\n","tags":["设计模式"]},{"title":"Mysql","url":"/posts/54e1373e.html","content":"[TOC]\nMYSQL数据库数据库是存储在计算机中，有组织，可共享的大量数据的集合，数据库中的数据按照一定的数据模型组织，描述和存储，具有娇小的冗长度，较好的数据独立性和易扩展性，并可以为各种用户共享，所以数据库具有，永久存储、有组织和可共享这三个基本特点。\n除了有数据库外还得有数据库管理系统，才能对数据更好的管理。\n数据库管理系统\n科学的组织和存储数据，可以高效的获得和维护数据。\n\n数据库管理系统和操作系统一样是计算机的基础的软件，也是一个大型复杂的软件系统，主要功能包括这几个方面：数据的操作功能，数据库的事务管理和运行管理、数据定义功能、数据组织、存储和管理数据的建立和维护功能。\n数据库系统是指在计算机系统中引入数据库后的系统。\nSQL\n结构化查询语言\n\nSQL是目前广泛使用的关系数据库语言标准语言。\nSQL的组成部分\n数据操作语言（DML）\n\n\n实现对数据的操作，用于检索或修改数据。\n\n\n数据定义语言 （DDL）\n\n\n用于定义数据的结构，创建、修改或删除数据库对象。\n\n\n数据控制语言 （DCL）\n\n\n用于控制数据库用户的权限。\n\n\n事务语言 （TCL）\n\n\n定义了包含事务开始和结束的相关命令。\n\n\nDLL包含的子部分\n完整性约束\n视图定义\n\n\n\nSQL的优点：\n\n几乎所有的数据库都支持SQL语言。\n简单易学。\n高度非过程化。\n\nSQL语句规范\nSQL语句不分大小写，但字符常量需要区分大小写，建议命令大写，表名库名小写。\nSQL语句可单行或多行书写，以分号结尾。\n用空格和缩进来提高语句可读性。\n注释有三种方式\n单行注释可以用#\n单行注释也可以用–，–与注释之间有空格\n多行注释可用&#x2F;**&#x2F;\n\n\n\n数据库的基本操作在MYSQL数据空中有许多的数据库，可以用show databases;命令来查看所有数据库。\n\ninformation_schema #主要存储了系统的一些数据库对象信息。\nmysql#MYSQL的核心数据库，主要负责存储数据库用户的，用户访问权限等MYSQL自己需要使用的控制和管理信息。\nperformance_schema#主要用于收集数据库服务器性能参数。\nsys#数据库提供一些视图，数据都来自performance_schema，主要为了让开发者和使用者刚方便的查看性能问题。\n\n想要知道当前操作的是哪个数据库可用select database();命令来查询。想使用哪个数据库可用use+库名;命令。想要知道在此数据库下有什么表可以用show tables;命令来查询。想要知道某些数据的表结构可以用dese 表名;命令来查找。如果要自己创建数据库用create database 库名;命令创建。但是如果数据库里已经有同名的了，就会提示创建失败，所有我们在创建之前可以先判断一下，用create database if not exists 库名;命令。如果想要删除数据库用drop database 库名;命令。\n数据库的基本查询SQL数据库查询用select语句来查询。\n查询多个字段select 字段,字段 from 表;# 查询所有字段select 字段,字段 from 表; # 中间写上所有的字段select * from 表;  # 影响效率，不直观# 查询字段，起别名select 字段,字段 AS&#x27;别名&#x27; from 表;select 字段,字段 &#x27;别名&#x27; from 表;# 查询字段，里面的信息不要重复的select distinct 字段 from 表; # 有多个字段就无效了# 在SQL语句中是支持我们简单的运算的select 字段*数字 from 表; # 支持+ - * /(DIV) %(MOD)\n\n条件查询\nselect 字段,字段 from 表 WHERE 条件; WHERE的条件是不能使用统计函数的\n\n条件运算符\n\n\n\n关系运算符\n功能\n\n\n\n&gt;\n大于\n\n\n&gt;&#x3D;\n大于等于\n\n\n&lt;\n小于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&#x3D;\n等于\n\n\n！&#x3D;或&lt;&gt;\n不等于\n\n\n\n\n\n逻辑算符\n功能\n\n\n\nAND或&amp;&amp;\n并且(多个条件同时成立)\n\n\nOR或&#x7C; &#x7C;\n或者(多个条件任意成立一个)\n\n\nnot或！\n非，不是\n\n\n\n\n\n其他\n功能\n\n\n\nbetween…and…\n在某个范围之间(含最小最大值)\n\n\nin(…)\n在in后列表中的值，多选一\n\n\nlile\n模糊匹配(_匹配单个字符，%匹配任意个字符)\n\n\nis[not]null\n是null\n\n\nMySQL也是可以通过表名来进行访问的。\n聚合查询\nSQL允许对表中的数据进行计算，将一列数据作为整体，进行纵向计算\n\n\n\n\n函数名\n功能\n\n\n\nmax\n返回某列的最高值(没有返回null)\n\n\nmin\n返回某列的最低值(没有返回null)\n\n\ncount\n返回某列的行数(不包括null)\n\n\ncount(*)\n返回被选列行数\n\n\nsum\n求和\n\n\navg\n求平均值\n\n\ncount可以用于任何的数据类型(因为他只用来计数)，而sum和svg都只能对数值类型做计算，max和min可用于数值，字符串或是日期时间数据类型。\n分组查询语法：\nselect 分组字段/聚合函数 from 表名 [where 条件] group by /*去重*/ 分组字段 [having 分组后条件]; \n\n主意事项在语法中，分组字段&#x2F;聚合函数必须在group by中出现否则使用是违法的。如果语句种没有出现group by那么select字段中，只能出现统计函数，不允许出现其他字段函数\n错误样例：SELECT job,sal FROM emp GROUP BY job;SELECT enmae,MAX(sal) FROM emp;\n\n排序查询\n通过条件查询语句查到用户想要的数据，但是输出数据的顺序一般是最初添加到表的顺序来的，为了使输出的顺序是用户需要的，MYSQL提供了ORDER BY 关键字来对查询的结果进行排序。\n\n语法:\nSELECT 字段名 FROM 表名...ORDER BY 排序字段名 [ASC/DESC];\n\n语法注意\n排序字段名:表示需要排序的字段名，多个字段时用字段隔开。\nASC&#x2F;DESC:ASC表示字段按升序排列,DESC表示字段按降序排列。ASC是默认值。\n\n特点\nORDER BY一般放在查询语句的最后面，LIMIT字段除外。\n当字段中出现空值时，默认空值按最小值对待。\nORDER BY指定多个字段进行排序的时候，MYSQL会按字段的顺序从左到右依次进行排序。\n注意： 对多个字段排序的时，排序的第一个字段必须有重复值时，才会对第二个字段进行排序。如果第一个字段中所有值都是是唯一的，则不会对第二个字段进行排序。\n\n分页查询\n对于较多的数据，如果在一个页面显示，会看起来显得眼花缭乱，如果能进行分页显示，会更加快捷，清晰的浏览。\n\n语法:\nSELEST 字段名 FROM LIMIT 起始索引,查询记录数;\n\n语句特点\n起始索引从0开始，起始索引&#x3D;(查询页码-1)*每页显示记录数。\n如果查询的是第一页数据，起始索引可以省略，直接简写为LIMIT 10\n\n数据库的函数MySQL函数会对传入的参数进行处理，并返回一个处理结果，也就是一个值。由于函数比较多，我会记录一些常用的函数，罕见的可以到MySQL参考手册去查询。\n字符串函数\n\n\n函数\n作用\n\n\n\nUPPER(列&#x7C;字符串)\n将字符串的每个字符转化为大写\n\n\nLOWER(列&#x7C;字符串)\n将字符串的每个字符转化为小写\n\n\nCONCAT(str1,str2,…)\n将所有字符串连接成一个字符串\n\n\nREPLACE(列&#x7C; 字符串,新字符串)\n使新字符串替换旧字符串\n\n\nLENGTH(列&#x7C; 字符串)\n求字符串长度\n\n\nSUBSTR(列&#x7C; 字符串,开始点[,长度])\n字符串截取\n\n\nLEFT(str,len)\n获得字符串左边len个字符组成的字符串\n\n\nRIGHT(str,len)\n获得字符串右边len个字符组成的字符串\n\n\nMID(str,pos,len)\n获得字符串从pos(第几个)位置开始，长度为len的字符串\n\n\nASCII(字符)\n返回于指定字符对应的十进制整数\n\n\nCHR(数字)\n返回与整数对应的字符\n\n\nRPAD(列&#x7C; 字符串,长度,填充字符)LPAD(列&#x7C; 字符串,长度,填充字符)\n用指定的字符在字符串的左或右填充\n\n\nLTRIM(字符串),RTRIM(字符串)\n去掉字符串左或右的空格\n\n\nTRIM(列&#x7C;字符串)\n去掉字符串左右空格\n\n\nINSTR(列&#x7C;字符串,要查找的字符串,开始位置，出现位置)\n查找一个子字符串是否在指定的位置上出现\n\n\n注： 1. SQL数据库给我们提供了一个虚拟表DUAL，用来给我们做测试用。\n\n起别名可以在字段后面直接空格+别名。\nSUBSTR(列&#x7C; 字符串,开始点[,长度])，长度可以是负数，就从后面数保留几位。\n\n数值函数\n\n\n函数\n作用\n\n\n\nround(小数[,位数])\n对小数四舍五入\n\n\ntruncate(小数,位数)\n截取，不会四舍五入\n\n\nceil(小数)\n向上取整\n\n\nfloor(小数)\n向下取整\n\n\nrand()\n生成[0,1]之间的随机数\n\n\n注：1. 位数要是负数就是表示当前整数的对应位置取0，向上进位的;负数的绝对值不能高于数字的最高位。\n\n\n\n时间日期函数\n\n\n函数\n作用\n\n\n\nCURDATE(),CURRENT_DATE\n返回当前日期\n\n\nCURTIME(),CURRENT_TIME\n返回当前时间\n\n\nNOW(),CURRENT_TIMESTAMP().LOCALTIME(),SYSDATE(),LOCALTIMESTAMP()\n返回当前日期和时间\n\n\nYEAR(日期)\n返回日期中的年份\n\n\nMONTH(日期)\n返回日期中的月份[1,12]\n\n\nDAY(日期)\n返回日期中的天[1,31]\n\n\nHOUR(时间)\n返回时间中的小时\n\n\nMINUTE(时间)\n返回时间中的分钟\n\n\nSECOND(时间)\n返回时间中的秒\n\n\nWEEKDAY(日期)\n返回星期几，0是星期一，1是星期二\n\n\nDAYOFWEEK(日期)\n返回星期几，1是星期日，2是星期一\n\n\nDAYOFYEAR(日期)\n计算指定日期是本年第几天\n\n\nDAYOFMONTH(日期)\n计算指定日期是本月第几天\n\n\nQUARTER(日期)\n计算日期是本年的第几季度\n\n\nTIME_TO_TIME(time)\n将指定时间转换位秒\n\n\nSEC_TO_TIME(sec)\n将以秒为单位的时间转化为时分秒的形式\n\n\nDATEDIFF(d1,d2)\n计算两个日期相隔的天数\n\n\nADDDATE(date,n)\n计算指定日期加上n天后的日期\n\n\nSUBDATE(date,n)\n计算两个日期相隔的天数\n\n\nADDTIME(time,n)\n计算指定时间加上n天后的时间\n\n\nSUBTIME(time,n)\n计算指定时间减去n秒后的时间\n\n\nDATE_FORMAT(date,f)\n按格式返回日期\n\n\nTINE_FORMAT(time,f)\n按格式返回时间\n\n\n注: 再格式化返回时间的时候注意%后面的字母的大小写，表示时间不是%m是%i。\n条件判断函数\n\n\n函数\n作用\n\n\n\nIF(expr,v1,v2)\n如果表达式expr成立，返回结果v1，否则，返回结果v2\n\n\nIFNULL(v1,v2)\n如果v1的值不为NULL，则返回v1，否则返回v2\n\n\nCASE\n分支\n\n\ncase有两种语法：\n语法一：CASE    WHEN expr1 THEN V1    WHEN expr2 THEN V2    ......    ELSE vnEND\n\n语法二：CASE expr    WHEN e1 THEN V1    WHEN e2 THEN V2    ......    ELSE vnEND\n\n其他函数系统信息函数\n系统信息函数用来查询MYSQL数据库信息。\n\n\n\n\n函数\n作用\n\n\n\nVERSION\n返回数据库的版本号\n\n\nCONNECTION_ID()\n返回数据库连接id\n\n\nDATABASE()、SCHEMA\n返回服务器名\n\n\nUSER()、SYSTEN_USER()、SESSION_USER()、CURRECT_USER()、CURRENT_USER()\n返回当前用户\n\n\nCHARSET(str)\n返回字符串str的字符集\n\n\nCOLLATION(str)\n返回字符串str的字符排列方式\n\n\n加密函数\n加密函数是MYSQL用来对数据进行加密的函数\n\n\n\n\n函数\n作用\n\n\n\nMD5(str)\n对字符串进行散列，可以用于一些普通的不需要解密的数据加密，如密码\n\n\nsha1\n对字符串进行散列，可以用于一些普通的不需要解密的数据加密，如密码比MD5更安全\n\n\n其他的函数\n进制转换\n\n\n\n\n函数\n作用\n\n\n\nBIN(x)\n返回x的二进制\n\n\nHEX(x)\n返回x的十六进制\n\n\nOCT(x)\n返回x的八进制\n\n\nCONV(x,from_base,to_base)\n将form_base进制的x，转成to_base进制\n\n\n\nip地址转换\n\n\n\n\n函数\n作用\n\n\n\nINET_ATON(IP)\n将点分十进制的ip地址转化为数字\n\n\nINET_NTOA(numben)\n将数字形式的IP转化为点分十进制\n\n\n多表查询\n表之间的关系基本分为三种，一对多（多对一），多对多，一对一\n\n我们经常需要查询的时候需要多个表的数据，这就是所谓的联合查询，在具体的实现操作时，首先将两个或两个以上的表按照某个条件连接起来，然后再查询到所要求的数据记录。连接查询分为交叉连接、内连接、外连接查询三种方式。\n查询例子：# 首先需要这两个表是有关系的，外键连接主键SELECT * FROM emp,dept; #出现的结果时笛卡尔积，结果行数是emp行数和dept行数的乘积。# 要是需要正确的，需要where语句SELECT * FROM emp,dept WHERE emp.depton=dept.depton;# 如果，表名太长可以取别名，但是在这条语句中原来的名字是不能用的了。\n\n等值连接vs不等值连接查询例子：# 等值连接SELECT * FROM emp,dept WHERE emp.depton=dept.depton;# where的条件用=连接了，所以是等值连接# 不等值连接SELECT * FROM emp,salgrade WHERE emp.sal between salgrade.locate and salgrade.hisal;\n\n内连接和外连接内连接：在连接条件不成立的时候，条件为NULL或匹配不到数据的时候，左表数据不显示。\n例子：1. 隐式内连接SELECT * FROM emp,dept WHERE emp.depton=dept.depton; 2.显示内连接SELECT * FROM emp INNET JOIN dept ON emp.depton=dept.depton;# INNET JOIN相当于&#x27;,&#x27;了\n\n外连接：连接条件不成立的时候也会显示，外连接分为左外连接，右外连接，全外连接\n例子：1.左外连接,左边显示SELECT * FROM emp LEFT JOIN dept ON emp.depton=dept.depton;2.右外连接，右边显示SELECT * FROM emp RIGHT JOIN dept ON emp.depton=dept.depton;3.全外连接，两边表中的数据都显示，这是运行不了的，因为MYSQL不支持，但是其他的sql支持SELECT * FROM emp FULL JOIN dept ON emp.depton=dept.depton;\n\n七种JOIN实现\n例：左上图：左外连接SELECT * FROM emp LEFT JOIN dept ON emp.depton=dept.depton;右上图：右外连接SELECT * FROM emp RIGHT JOIN dept ON emp.depton=dept.depton;左中图，在左外连接的基础上，去掉满足条件的记录SELECT * FROM emp LEFT JOIN dapt ON emp.dapton=dapt.dapton WHERE emp.depton IS NULL;#只要不满条件的，连接条件不匹配或者为null的右中图SELECT * FROM emp RIGHT JOIN dept ON emp.depton=dept.depton WHERE dapt.deptom IS NULL;左上图和右中图连接就是全外连接SELECT * FROM emp LEFT JOIN dept ON emp.depton=dept.depton UNION #并集 SELECT * FROM emp RIGHT JOIN dept ON emp.depton=dept.depton WHERE dapt.deptom IS NULL;用左中图和右中图连接时右下图SELECT * FROM emp LEFT JOIN dapt ON emp.dapton=dapt.dapton WHERE emp.depton IS NULL UNION SELECT * FROM emp RIGHT JOIN dept ON emp.depton=dept.depton WHERE dapt.deptom IS NULL;\n\n自连接与并集运算隐式连接当想让两个表通过相同字段连接在一起可以用USING()\n例：SELECT * FROM JOIN dept USING(depton);\n\n自连接：\n例：SELECT e.empno,e.ename,m.ename 领导 FROM emp e,emp mWHERE e.mgr=m.empon;\n\n集合运算，MYSQL只支持并集运算 UNION DISTINCT和UNION ALL，UNION后面什么也不写，默认是DISTINCT要求：\n\n输入的查询不能包换ORDER BY 字句，可以为整个集合运算结果选择性的增加一个ORDER BY字句\n两个查询必须包含相同的列数\n集合运算结果中列名由输入的查询1决定，如果要为结果分配结果列，应该在输入的查询1中分配相应的别名\n集合运算时，对行进行比较时，集合运算认为两个null相等\n相应列必须具有兼容的数据类型。兼容个的数据类型:优先级较低的数据类型必须能隐式地转换为较高级的数据类型。比如输入的查询1的第一列为int类型，输入的查询2的第一列为float类型，则较低的数据类型int类型可以隐式地转换为较高级float类型。如果输入的查询1的第一列为char类型，输入的查询2的第一列为datetime类型，则会提示转换失败:从字符串转换日期和&#x2F;或时间时，转换失败\n\n子查询子查询概念子查询是指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MYSQL4.1开始引入的。\n在特定情况下，一个查询语句的条件需要另一个语句来获取，内层查询语句的查询结果，可以为外层查询语句提供查询条件。\n\n内层查询即子查询，外层查询即主查询，只是叫法不同\n\n查询规范\n子查询必须放在小括号里\n子查询一般放在比较操作符的右边，以增强代码可读性\n子查询可以出现在几乎所有的SELECT字句中（如：SELECT、FROM、WHERE、ORDER BY、HAVING子句）\n\n例：SELECT * FROM emp WHERE sal=(SELECT MIN(sal) FROM emp );\n\n按照查询返回的结果分类：标量查询：返回一个标量（一个值）单行单列列子查询：返回的是单行多列列子查询：返回的是多行多列表子查询：查询的是一个表\n按照子查询和主查询之间是否有条件关联分类相关子查询：两个查询之间有一定的条件关联（相互联系）不想关子查询：两个查询之间没有条件关联（相互独立）\n为了方便，对于在何处使用子查询的建议：\n\n子查询出现在WHERE子句中：此时查询返回的结果一般都是单行单列，单行多列，多行多列\n子查询出现在HAVING字句中：此时子查询返回的都是单行单列数据，同时为了使用统计函数操作\n子查询出现在FROM子句中：此时子查询返回的结果图一般都是多行多列，可以按照一张数据表（临时表）的形式操作\n\n标量子查询查询出来的是一个值，用到的符号有&gt;(大于) &lt;(小于) &lt;&gt;(不等于) ！&#x3D;(不等于)\n例：SELECT * FROM emp HWERE sal&gt;(SELECT MIN(sal) FROM emp );\n\n单行子查询例：SELECT * FROM emp WHERE job=(SELECT job FROM emp WHERE ename=&#x27;SCOTT&#x27;)AND sal=(SELECT sal FROM emp WHERE ename=&#x27;SCOTT&#x27;)AND ename&lt;&gt;&#x27;SCOTT&#x27;;上面的可以改写为单行子查询SELECT * FROM emp WHERE (job,sal)=(SELECT job，sal FROM emp WHERE ename=&#x27;SCOTT&#x27;)AND ename&lt;&gt;&#x27;SCOTT&#x27;;\n\n列子查询（多行查询）\n子查询返回的是多行单列数据，就是一列数据。多行查询也称为集合比较子查询\n\n在使用多行子查询·需要使用多行比较操作符\n\n\n\n操作符\n含义\n\n\n\nIN\n等于列表中的任意一个\n\n\nANY\n需要和单行比较操作符一起使用(&gt;、&lt;、&#x3D;、&lt;&gt;…)，与子查询结果中的任何一个值比较，一个成立\n\n\nALL\n需要和单行比较操作符一起使用(&gt;、&lt;、&#x3D;、&lt;&gt;…)，和子查询返回的所有值比较，同时成立\n\n\nSOME\n实际上是ANY的别名，作用相同，一般用ANY\n\n\n表子查询例：SELECT d.deptno,d.dname,d.loc,temp.count,temp.avgsalFROM dept d,(SELECT depton,COUNT(depton) count,ROUND(AVG(sal),2) vagsal FROM emp GROUP BY depton) temp /*临时表必须起别名要不调用了*/WHERE d.depton=temp.depton;### HAVING子句中的子查询```MYSQL例子：SELECT dept.dname,ROUND(AVG(sal),2) avFROM emp e, deptWHERE e.deptno=dept.deptnoGROUP BY dept.dnameHAVING av&gt;=(SELECT MAX(temp.av)FROM(SELECT AVG(sal)  av FROM emp GROUP BY deptno) temp);\n\nSELECT子句中子查询例子：查询公司每个部门的编号、名字、位置、部门人数、平均工资的三种写法1.正常查询SELECT d.deptno,d.dname,d.loc,COUNT(d.deptno),AVG(e.sal)FROM emp e RIGHT JOIN dept dON e.deptno=d.deptnoGROUP BY d.deptno;2.from子句查询SELECT d.deptno,d.dname,d.loc,t.c,t.avFROM dept d,(SELECT e.deptno,COUNT(e.deptno) c,AVG(e.sal) av FROM emp e GROUP BY e.deptno ) tWHERE t.deptno=d.deptno;3.select子句查询SELECT d.deptno,d.dname,d.loc,(SELECT COUNT(deptno) FROM emp WHERE deptno=d.deptno),(SELECT AVG(sal) FROM emp WHERE deptno=d.deptno)FROM dept d;\n\n相关子查询如果子查询的执行依赖外部查询，通常情况下都是因为子查询中的表用到了外部表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就成为关联子查询。\n相关子查询按照一行接一行的顺序指针，主查询的每一行都指向一次子查询。\n例：不相关子查询SELECT *FROM emp WHERE sal&gt;(SELECT sal FROM emp WHERE ename=&#x27;SCOTT&#x27;);相关子查询SELECT e.deptno,e.ename,e.salFROM emp eWHERE sal&gt;(SELECT AVG(sal) FROM emp WHERE e.deptno=deptno);\n\nWITH和EXISTX语句公共表表达式(WITH)是一个命名的临时结果集，存在于单个语句的范围内，定义后可以在该语句中引用它，可以多次引用。\n在SQL中提供了一个existx结构用于判断子查询是否有数据返回。如果子查询中有数据返回，existx结构返回true，否则返回false\n例：WITH  temp AS(SELECT depton,MAX(sal) maxsal FROM emp GROUP BY depton)  SELECT e.empon,e.ename,e.job,e.hiredate, e.sal,d.deptno,d.dname  FROM emp e  JOIN dapt d ON e.deptno=d.deptno  JOIN ON e.deptno=t.depton AND e.sal=t.maxsal;\n\n数据管理插入数据\n使用INSERT INTO语句来向表中插入数据。\n\n语法：\n\n给指定字段添加数据INSERT INTO表名 (字段1，字段2....)VALUES (value1,value2....);# value与字段是一一对应的\n给全部字段添加数据INSERT INTO 表名 VALUES (value1,value2....);\n批量添加数据(用单条INSERT语句处理多个插入要比使用多条INSERT语句更快)\n\nINSERT INTO 表名(字段1，字段2...) VALUES (value1,value2....)                                 VALUES (value1,value2....)                                 VALUES (value1,value2....)                                 .........;\n\n语法说明如下：\n\n&lt;表名&gt;：指定被操作的表名。\n&lt;列表&gt;：指定需要插入数据的列表。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用INSERT INTO 表名 VALUES (value1,value2....);即可。\nVALUES或VALUE语句：该子句包含要插入的数据清单。数据清单数据的顺序要个列的顺序相对应。\n\n如果想把一个表的数据拷贝到令一张表上可以用：INSERT INTO 表名 SELECT * FROM 表名 WHERE 条件;INSERT INTO 表名(字段1，字段2....) SELECT * FROM 表名 WHERE 条件;\n修改数据使用UPDATE…SET语句来修改表中的数据。语法：UPDATE 表名 SET 字段= value[字段1=value,...][WHERE 子句][ORDER BY 子句][LIMIT 子句];语法说明如下：\n\n&lt;表名&gt;： 用指定要更新的表名称。\nSET子句： 用于指定表中要修改的列名及其列值。其中，每个只当的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可以用关键字DEFAULT表示列值。\nWHERE子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。\nORDER BY子句：可选项。用于限定表中的行被修改的次序。\nLIMIT子句：可选项。用于限定被修改的行数。\n注意：在不使用WHERE条件的时候，将修改所有记录的字段。\n\n当一个UPDATE语句中出现查询语句的时候时，查询语句要变成一张临时表才可以，否则会报错。\n在修改数据中ORDER BY需要和LIMIT联合使用\n删除数据使用 DELETE FROM语句来删除表中的数据。语法：DELETE FROM 表名 [WHERE 子句][ORDER BY 子句][LIMIT 子句];语法说明：\n\n&lt;类名&gt;：指定要删除数据的表名\nORDER BY子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。\nWHERE子句：可选项。表示为删除操作限定删除条件，若省略该句子，则代表该表中的所有行。\nLIMIT子句：可选项。用于告知服务器在控制命令被返回到客服端被删除行的最大值。\n注意：在不使用WHERE条件的时候，将删除所有数据。\n\n表管理基础知识表的基本概念在MYSQL数据库中，表是一种很重要的数据库对象，是组成数据库的基本元素，由若干的字段组成，主要用来实现数据库记录。表的操作包含创建表、查看表、删除表和修改表。这些操作是数据库对象的管理中，最基本、最重要的操作。\n\n表的相关概念；\n表的基本操作：创建、查找、更新、删除；\n表的使用策略。\n\n表是包含数据库中所有数据的数据库对象。数据在表中的组织方式与在电子表格中的相似，都是按行和列的格式组织的。其中每一行代表一条唯一的记录，每一列代表记录中的一个字段。\n标识符命名规范\n数据库名，表名不能超过三十个字符，变量名现在为29个\n只能包含大写、小写、数字字符以及下划线\n同一个MYSQL软件中，数据库不能同名；同一个库中，表不能同名；同一个表中，字段不能重名\n不能和保留字、函数名冲突\n保留子段名和类名一致性：假如某个字段在一个表里面是整型，那在另一个表里面可就别变成字符串了\n\n创建数据库方式一：CREATE DATABASE 库名;方式二：CREATE DATABASE 库名 CHARACTER SET &#x27;编码格式&#x27;;# gdk格式是专门用于中文的编码格式，UTF8是全球通用的，一般出现乱码，就是这两个字符集转换出现错误方式三(推荐)：CREATE DATABASE IF NOT EXISTS 库名 CHARACTER SET &#x27;编码格式&#x27;;查看创建数据库时使用的语句：SHOW CREATE DATABASE 库名;查看所有的数据库SHOW DATABASES;使用数据库USE 数据库名;查看当前使用的数据库SELECT DATABASE();查看数据库下面所有的表SHOW TABLES FROM 库名;修改数据库-&gt;由于数据库不能再次改名字，所以起名字的时候要慎重。ALTER DATABASE 库名 CHARACTER SET &#x27;字符集&#x27;;查看数据库支持的字符集SHOW CHARSET;查看默认字符集SHOW VARIABLES LIKE &#x27;%character%&#x27;;删除数据库DROP DATABASE IF EXISTS  库名;\n\n数据类型\n\n\n类型\n具体类型\n\n\n\n整数类型\nTINYINT,SMALLINT,MEDIUMINT,INT(或INTEFER),BIGINT\n\n\n浮点类型\nFLOAT,DOUBLE\n\n\n定点数类型（精度最高）\nDECIMAL\n\n\n位类型\nBIT\n\n\n日期时间类型\nYEAR,TIME,DATE,DATETIME,TIMESTAMP\n\n\n文本字符串类型\nCHAR,VARCHAR,TINYTEXT,TEXT,MEDIUMTEXT,LONGTEXT\n\n\n枚举类型\nENUM\n\n\n集合类型\nSET\n\n\n二进制字符串类型\nBINARY,VARBINARY,TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOB\n\n\njson类型\nJSON对象,JSON数组\n\n\n空间数据类型（不常用）\n单值：GEMETRY,POINT,LINESTRING,POLYGON集合：MULTPOINT,MULTILINESTRING,MULTIPOLGON,GEOMTRYCOLLECTION\n\n\n\n创建表：方法一：CREATE TABNE 表名(  属性 类型,  属性 类型,  ......)[CHARACTER SET &#x27;字符集&#x27;];方法二：基于其他的表创建新表单个表：CREATE TABNE 表名ASSELECT 字段,...FROM 库名.表名;多个表：把所有的属性和内容都复制下来了CREATE TABNE 表名ASSELECT 字段,...FROM 库名.表名,..... WHERE 条件;想要只复制属性，不复制数据可以：CREATE TABNE 表名ASSELECT 字段,...FROM 库名.表名,..... WHERE 1=2;选择一个永远不成立的条件查看表SHOW TABLE FROM 表名;查看表结构DESC 表名;SHOW CREATE TABLE 表名;\n\n注释在创建完表和库后很久后可能会忘记，就需要我们来写注释\n例：CREATE TABNE 表名(  属性 类型 COMMENT &#x27;注释&#x27;,  属性 类型 COMMENT &#x27;注释&#x27;,  ......)COMMENT &#x27;注释&#x27;;用这种方法就可以在过了很久以后能知道每个属性是干什么的了修改字段注释：ALTRE TABLE  表名 MODIFY 字段 数据类型 COMMENT &#x27;新注释&#x27;;修改表的注释：ALTRE TABLE  表名 COMMENT &#x27;新注释&#x27;;\n\n修改表修改数据表的前提是数据库已经存在该表，修饰表指的是修改数据库中已存在的数据表的结构。修改数据表的操作也是数据库管理中必不可少的，就像画素描一样，话多了可以再用橡皮擦掉，画少了可以用笔加上。\n\n修改表名\n\n方法一：通过ALTER TABLE语句来修改表名ALTER TABLE &lt;旧表名&gt; RENAME[10]&lt;新表名&gt;;方法二：通过RENAME TABLE语句来修改表名RENAME TABLE&lt;旧表名&gt; TO &lt;新表名&gt;[，旧表名2 TO 新表名2]修改字符集ALTER TABLE 库名.表名 CONVERT TO CHARACTER SET &#x27;格式&#x27;;修改字段添加1.在最后面添加ALTER TABLE 表名 ADD 新字段 数据类型 ;2.在最前面添加ALTER TABLE 表名 ADD 新字段 数据类型  FIRST;3.在指定位置添加字段ALTER TABLE 表名 ADD 新字段 数据类型 AFTER 一个字段的名字;删除ALTER TABLE 表名 DROP 字段名;修改1.修改字段的数据类型ALTER TABLE 表名 MODIFY 字段名 数据类型;2.修改字段名字ALTER TABLE 表名 CHANGE 字段名 新名字 数据类型;3.修改字段顺序  1.把字段放到第一个  ALTER TABLE 表名 MODIFY 新字段 数据类型  FIRST;  2.把字段放到指定字段后  ALTER TABLE 表名 MODIFY 新字段 数据类型 AFTER 一个字段的名字;删除表DROP TABLE IF EXISTS 表名;\n\n约束约束概念为什么需要约束对于已经创建好的表，虽然字段的数据类型决定了所能存储的数据类型，但是表中所存储的数据是否合法并没有进行检查。具体使用MYSQL软件时，如果对表中的数据做一些完整性检查操作，可能通过表的约束来完成。\n数据完整性是指数据的精确性和可靠性。他是防止数据库中存在不符合语义规定的数据和防止因为错误信息的输入输出造成无效操作或错误信息而提出来的。\n为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制，主要从一下赐个方面考虑：\n\n实体完整性 如：同一个表，不能存在两条完全一样的记录\n域完整性 如：年龄范围0-120\n引用完整性 如：员工部门一定在员工表里存在的\n用户自定义完整性 如：用户名唯一\n\n什么是约束约束时表级的强制约束\n约束的分类\n根据约束的字段分类：单列约束、多列约束\n根据约束的作用范围分类：列级约束、表级约束\n根据约束的作用分类：非空约束、唯一约束、主键约束、自增长、外键约束、检查约束、默认约束\n\n创建约束：\n\n在创建表时添加约束\n创建表之后添加约束\n\n非空约束概念：当数据库表中的某个字段上的内容不希望设置为NULL时，则可以使用NK约束进行设置。即NK约束在创建数据库表时为某些字段加上“NOT NULL”约束条件，保证所有记录中该字段都有值。如果用户在插入记录中，该字段为空值，则数据库管理系统会报错。\n特点:\n\n默认情况下，所有类型的值都可以时NULL\n一个表可以有很多字段指定非空约束\n空串“”不等于NULL,0也不等于NULL，NULL也不等于NULL\n\n例子：1.在创建时候CREATE TABNE 表名(  属性 类型 NOT NULL,  属性 类型 NOT NULL,  ......);当创建新的数据的时候，相对应的字段不能写null，会报错，提示不能填空，当创建数据的时候不写就会提示少写了一个数据。2.修改ALTER TABLE 表名 MODIFY 字段 类型 NOT NULL;当有数据为空的时候更改不了，会提示不明确，需要把所有数据都改为非空后才可以再执行此语句3.删除非空约束ALTER TABLE 表名 MODIFY 字段 类型 NULL;NULL可以省略不写\n\n唯一约束概念：当数据库表中的某个字段上的内容不允许重复时，则可以使用UK约束进行设置。即UK约束进行设置。即UK约束在创建数据库时为某些字段加上”UNIQUE”约束条件，保证所有记录中该字段上的值不重复，则数据库管理系统会报错。\n特点：\n\n同一个表可以有多个唯一约束\n唯一约束允许值为NULL\n在创建唯一约束的时候，如果不给唯一约束命名，那么约束名和字段名相同\n\n例子：1.在创建时候CREATE TABNE 表名(  属性 类型 ,  属性 类型 UNIQUE,  ......,  也可以用表约束来写：  CONSTRAINT 名字(起的新名字) UNIQUE KEY(需要唯一的字段，已有的)# KEY可以省略);查看表以存在的约束：SELECT *FROM information_schema.TABLE_CONSTRAINTS WHERE table name=&#x27;需要查的字段名&#x27;;2.修改ALTER TABLE 表名 MODIFY 字段 类型 UNIQUE;添加表约束：ALTER TABLE 表名 ADD  CONSTRAINT 名字(起的新名字) UNIQUE KEY (需要唯一的字段，已有的)# KEY可以省略3.删除约束ALTER TABLE 表名 DROP INDEX 字段;\n\n主键约束概念当想用数据库表中的某个字段来唯一标识所有记录时，则可以使用PK约束进行设置。即PK约束在创建数据库表时为某些字段加上”PRIMARY KEY”约束条件，则该字段可以唯一地标示所有记录。在数据库表中之所以设置主键，是为了便于数据库管理系统快速的查找到表中的记录。在具体设置主键约束时，必须要满足主键字段的值是唯一、非空。由于主键可以是单一字段，也可以是多个字段，因此分为单字段主键和多字段主键。特点：\n\n主键约束相当于唯一约束+非空约束，意味着不允许重复和NULL值\n主键约束对应着表中的一列或多列（复合主键）\n如果时多列组合的复合主键约束，那么这些列都不允许为NULL值，并且组合的值不允许重复\nMYSQL的主键名总是PRIMARY，就算是自己命名了主键约束也没有用\n当创建主键约束时，系统默认会在所在的列或组合上建立对应的主键索引（能够根据主键查询的，就根据主键传讯，效率更高），如果删除主键约束，主键约束对应的索引就自动删除了\n需要注意一点的时，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。\n\n例子：1.在创建时候CREATE TABNE 表名(  属性 类型  PRIMRY KEY,# 一个表中只能有一个主键约束，否者会报错  属性 类型 ,  ......,  也可以用表约束来写：  CONSTRAINT 名字(起的新名字) PRIMRY KEY(需要唯一的字段，已有的)# KEY可以省略);查看表以存在的约束：SELECT *FROM information_schema.TABLE_CONSTRAINTS WHERE table name=&#x27;需要查的字段名&#x27;;添加表约束：ALTER TABLE 表名 ADD   PRIMRY KEY（名字(起的新名字)）;3.删除约束ALTER TABLE 表名 DROP PRIMRY KEY（名字(起的新名字)）;\n\n自增长约束概念：AUTO_INCREMENT是MYSQL唯一扩展的完整性约束，当为数据库表中插入新的记录时，字段上的值会自动生成唯一的id。在具体设置AUTO_INCREMENT约束时，一个数据库表中只能有一个字段使用该约束，该字段的数据类型必须是整数类型，由于设置AUTO_INCREMENT约束后的字段会生成唯一的id，所以该字段也经常会设置成pk主键。\n特点：\n\n一个表最多只有一个自增长列\n当需要生产唯一标识符或顺序值时，可设置自增长\n自增长列约束的列必须时键列（主键列，唯一键列）\n自增长约束的列的数据类型必须时整数类型\n如果自增列定制了0或者NULL。会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接使用具体值。\n\n&#x3D;&#x3D;在删除一个元素后，再添加一个元素，序列仍是在原先的基础上自增长的&#x3D;&#x3D;\n例子：1.在创建时候CREATE TABNE 表名(  属性 类型 AUTO_INCREMENT,  属性 类型 ,  ......,);添加表约束：ALTER TABLE 表名 MODIFY 名字 数据类型  AUTO_INCREMENT;3.删除约束ALTER TABLE 表名 MODIFY 名字 数据类型;\n\n检查约束（check）检查某个字段的值是否符合xx要求，一般指的是值的范围\n\n在MYSQL5.7可以使用，但是没有作用，在8.0版本开始生效，可以正确进行检查\n\n例子：1.在创建时候CREATE TABNE 表名(  属性 类型  CHECK(条件)，  属性 类型 ,  ......,#也可以用表约束来限制CONSTRAINT 别名 CHECK(条件););\n\n删除约束：ALTER TABLE 表名 DROP CHECK 字段;添加约束：ALTER TABLE 表名 ADD CONSTRAINT 字段 CHECK(条件);\n默认值约束（DEFAULT）当为数据库表中插入一条新纪录时，如果灭有为某个字段赋值，那么数据库系统会自动为这个字段插入默认值。为了达到这种效果，可以通过SQL语句关键字DEFAULT来设置。\n语法：\nCREATE TABLE 表名(    字段 类型,    字段 类型 DEFAULT 字符串;)\n\n删除约束：ALTER TABLE 表名 MODIFY 字段 类型;添加约束：ALTER TABLE 表名 MODIFY 字段 类型 DEFAULT 默认值;\n外键约束外键约束保证多个表（通常两个表）之间的参照完整性，即构造与两个字段之间的关系。\n概念设置外键约束的两个表之间具有父子关系，即子表中某个字段的取值范围由父表所决定。例如：表示一种部门和雇员关系，即每个部门有多个雇员。首先应该有连个表：部门表和雇员表，然后雇员表中有一个表示部门编号的字段deptno，其依赖于部门表的主键，这样字段depton就是雇员的外键，通过该字段部门表建立了关系。对于两个具有关联的表而言，相关关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。在具体设置fk约束时，设置fk约束的字段必须依赖于数据库中已经存在的父表的主键，同时外键可以为null。\n其特点\n从表的外键必须引用（参考）主表的主键或唯一约束的列：因为参考的值必须是唯一的\n在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动生产一个外键名，也可以指定外键约束名\n创建表时必须先创建主表，再创建从表\n删除表必须先删除从表（或先删除外键约束），再删除主表\n当主表的记录被从表参考时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖字段的记录，然后才可以删除主表中的记录\n当创建外键约束时，系统默认会在所在的列上建立对应的普通索引；删除外键约束之后，必须手动删除对应的索引\n\n添加外键约束CREATE TABLE 主表名(  字段1 类型 PRIMARY KEY,  字段2 类型 ,  ....)CREATE TABLE 从表名(  字段1 类型 PRIMARY KEY,  字段2 类型 ,# 需要有字段和主表主键一样  ....  CONSTRAINT 字段别名 FOREIGN KEY(主表主键名) REFERENCES 主表(主键))#删除外键约束ALTER TABLE 表名 DROP FOREIGN KEY 别名;#删除外键创建时自动创建索引ALTER TABLE 表名 DROP INDEX 别名;添加外键约束ALTER TABLE 表名 ADD CONSTRAINT 别名 FOREIGN KEY(主表主键名) REFERENCES 主表(主键);\n\n级联操作\n级联操作指的就是，当你操作主表时，自动的操作从表\n\n两种级联操作\n\n级联删除：当删除主表数据时自动删除从表的相关数据\n级联更新：当主表外键约束字段（一般是主键） 更新时，自动更新从表的数据\n\n五种级联方式\n定义从表的外键时指定的ON UPDATE&#x2F;ON DELETE子句，InnoBD支持5种方式：\n\nCASCADE级联方式\n在主表上update&#x2F;delete记录时，同步update&#x2F;delete掉从表的匹配记录\n\n\nSET NULL设置为NULL\n在主表上update&#x2F;delete记录时，将从表上匹配记录的列为NULL\n\n\nNO ACTION不允许更新和删除\n如果从表种有匹配的记录，则不允许对表的关联字段更新\n\n\nRESTRICT限制\n同时NO ACTION\n\n\nSET DEFAUT\n主表有变更时，子表将外键列设置成一个默认值，但InnoBD不能识别\n\n\n\n#1.主表更新或者删除的时候，从表的相关记录也会更新或删除ALTER TABLE 表名 ADD CONSTRAINT 别名 FOREIGN KEY（主表名）REFERNECES 字段（主表名）ON UPDATE CASCADE ON DELETE CASCADE;  #可以把两个表都建立完后再写这个指令，不要初始化。#2.主表更新或者删除的时候，从表的相关记录的外键字段会自动设置为NULLALTER TABLE 表名 ADD CONSTRAINT 别名 FOREIGN KEY（主表名）REFERNECES 字段（主表名）ON UPDATE SET NULL ON DELETE SET NULL; # ON UPDATE 后面的两个可以任意搭配\n\nSQL数据类型整数类型\n\n\n类型\n说明\n大小（字节）\n\n\n\nTINYING\n很小的整数\n1\n\n\nSMALLINT\n小的整数\n2\n\n\nMEDIUMINT\n中等大小的整数\n3\n\n\nINT&#x2F;INTGER\n普通大小的整数\n4\n\n\nBIGINT\n大整数\n8\n\n\n浮点类型\n\n\n类型\n说明\n大小（字节）\n\n\n\nFLOAT\n单精度浮点数\n4\n\n\nDOUBLE\n双精度浮点数\n8\n\n\nREAL\n默认为DOUBLE\n把SQL模式设定为”REAL_AS_FLOAT”,REAL就是FLOAT SEL sql_mode&#x3D;”REAL_AS_FLOAT”\n\n\n定点类型\n\n\n类型\n说明\n大小（字节）\n\n\n\nDECIMAL&#x2F;DEC\n压缩的”严格”定点数\nM+2\n\n\nDECIMAL(M,D)。其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。0&lt;&#x3D;M&lt;&#x3D;65,0&lt;&#x3D;D&lt;&#x3D;30,D&lt;M。例如：定义为DECIMAL(5,2),表示该列的取值范围是[-999.99,999.99]。\n\nDECIMAL(M,D)的最大范围与DOUBLE类型一样，但是有效的数据方位是由M和D决定的。DECUNAK的存储空间并不固定，由精度M决定，总共占用的存储空间为M+2个字节。也就是说，在一些精度要求不高的场景下，比起占用相同样字节长度的定点数，浮点数表达的数值范围可以更大。\n\n定点数再MYSQL内部是以字符串的形式进行存储的，这就决定了他一定是精确的。\n\n当DECIMAL类型不指定精度和标度时，其默认值DECIMAL(10,0),当数据的精度超出了定点数的精度范围时，则MYSQL同样会四舍五入。\n\n浮点数vs定点数\n\n浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是精度不精确，适用于需要取值范围大，又可以容忍误差的科学计算场景\n定点数类型取值范围相对小，但是精确，没有误差，设置对于精度要求极高的场景（比如设计金融计算的成精）\n\n\n\n二进制类型\n用于存储图片、音频、视频等二进制数据。\n\n下表种列出了MYSQL中的二进制数据类型，括号中的M表示可以为其指定长度。\n\n\n\n类型名称\n说明\n大小（字节）\n\n\n\nBIT(M)\n位字段类型\n大约（M+7）&#x2F;8字节\n\n\nBINARY(M)\n固定长度二进制字符串\nM字节\n\n\nVARBINARY(M)\n可变长度二进制字符串\nM+1字节\n\n\nTINYBLOB(M)\n非常小的BLOB\nL+1字节，在次，L&lt;2^8\n\n\nBLOB(M)\n小BLOB\nL+2字节，在次，L&lt;2^16\n\n\nMEDIUMBLOB(M)\n中等大小的BLOB\nL+3字节，在次，L&lt;2^24\n\n\nLONGBLOB(M)\n非常大的BLOB\nL+4字节，在次，L&lt;2^32\n\n\n日期&#x2F;时间类型\n\n\n类型名称\n说明\n日期范围\n大小（字节）\n\n\n\nYEAR\nYYYY\n1901-2155\n1\n\n\nTIME\nHH:MM:SS\n-838:59:59~838:59:59\n3\n\n\nDATE\nYYYY-MM-DD\n1000-01-01~9999-12-3\n3\n\n\nDATETIME\nYYYY-MM-DD HH:MM:SS\n1000-01-01 00:00:00~9999-12-31 23:59:59\n8\n\n\nTIMESTAMP\nYYYY-MM-DD HH:MM:SS\n1970-01-01 00:00:00UTC~2038-01-19 03:14:07 UTC\n4\n\n\n\n要是创建的变量要每次登录更新可以在类型后面加上ON UPDATE再加上类型即可\n\n字符串类型| 类型名称     | 说明         |长度范围|占用的存储空间|\n| ———– | ———— | ———— |———— ||CHAR(M)|固定长度|0&lt;&#x3D;M&lt;&#x3D;255|M个字节||VARCHAR(M)|变长字符串|0&lt;&#x3D;M&lt;&#x3D;65535|M+1个字节||TINYTEXT|非常小字符串|0&lt;&#x3D;L&lt;&#x3D;255|L+1个字节||TEXT|小的字符串|0&lt;&#x3D;L&lt;&#x3D;65535|L+2个字节||MEDIUMTEXT|中等大小的字符串|0&lt;&#x3D;L&lt;&#x3D;16777215|L+3个字节||LONGTEXT|大的字符串|0&lt;&#x3D;L&lt;&#x3D;4294967295|L+4个字节||ENUM|枚举类型，只能有一个枚举字符串值|0&lt;&#x3D;L&lt;&#x3D;65535|1或2个字节，取决于枚举值的数目（最大值为65535）||SET|字符串集合，字符串对象可以有零个或多个SET成员|0&lt;&#x3D;L&lt;&#x3D;64|1，2，3，4或8个字节，取决于集合成员的数量（最多64个成员）|\n视图视图可以帮助我们使用表的一部分而不是整个表，令一方面也可以针对不同的用户定制不同的查询视图。\n\n视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，他是sql中的一个重要概念。视图建立在已有表的基础上，视图赖以建立的这些表称为基表。视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增删改的操作时，基表中的数据会相应地发生变化，反之亦然。向视图提供数据内容的语句为select语句，可以将视图理解为存储起来的select语句。视图，是向用户提供基表数据的另一种表现形式。小项目用不到，大项目用可以提高效率。\n\n视图语法# 完整版本:CREATE [OR REPLACE] [ALGORITHM=&#123;UNDEFINED|MERGE|TEMPTABLE&#125;]VIEM 视图名称[(字段列表)]AS 查询语句[WITH [CASCADED|LOCAL] CHECK OPTION]# 简单版本:CREATE VIEW 视图名称AS 查询语句\n\n视图的查看：\n1.查看数据库里有哪些表和视图SHOW TABLES2.查看视图结构DESC 视图名字3.查看视图的属性信息SHOW TABLE STATUS LIKE 视图名字4.查看创建视图的·时候的语句SHOW CREATE VIEW\n\n更新视图数据Mysql支持使用insert，update和delete语句对视图中的数据进行插入，更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。\n在数据的插入阶段时，如果有没有指定的字段，并且字段没有默认值，则插入失败。\n不可更新视图要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：\n\n在定义视图的时候指定了 ALGORITHM=TEMPTABLE，视图将不支持insert和delete操作\n视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持insert操作\n在定义视图的select语句中使用了join联合查询，视图将不支持insert操作\n在定义属兔的select语句后的字段列表中使用distinct，聚合函数，group by，having，union等，视图将不支持insert，update和delete\n在定义视图的select语句中包含了子查询，而子查询中引用了from后面的表，视图将不支持insert，update和delete\n\n注意：虽然可以更新视图，但是总的来说，视图作为虚拟表，主要用于方便查询，不建议更新视图数据。对视图数据更改，都是通过对实际数据表里数据的操作来完成的。\n视图的删除与修改删除视图DROP VIEW IF EXISTS 视图名称DROP VIEW IF EXISTS 视图名称1，视图名称2，视图名称3...\n\n删除视图只是删除视图定义，不会删除基表的数据\n修改视图方法1，使用CREATE OR REPLACE VIEW子句修改视图CREATE OR REPLACE VIEW 视图名称AS查询语句方法2，ALTER VIEWALTER VIEWAS查询语句\n\n存储过程和函数MYSQL再5.0版本开始支持存储过程和函数，存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑而只需要简单的调用存储过程和函数即可\n存储过程概念存储过程，他的思路很简单，他就是一组经过预先编译的sql语句的封装。存储过程预先存储在MYSQL服务器上，需要执行的时候，客服端只需要向服务器发出调用存储的命令，服务器就可以把预先存储好的这一系列SQL语句全部执行。\n好处\n简化操作，提高SQL语句的重用性，减少了开发程序员的压力\n减少操作过程中的失误，提高效率\n较少网络传输量（客服端不需要把所有的SQL语句通过网络发送给服务器）\n减少SQL语句暴露在网上的风险，提高了数据查询的安全性\n\n语法CREATE PROCEDURE [IF NOT EXISTS] 存储过程名称([IN|OUT|INPUT 参数名 参数类型,...])[charcateristics ...]BEGIN存储过程体END\n\n\n存储过程名称不能与已存在的存储过程名重名。推荐存储过程名命名为procedu_xxx或者proc_xxx\n\n参数分类存储过程的参数可以是IN、OUT、INOUT\n\nIN表示传入参数\nOUT表示传出参数\nINOUT表示既可以传入也可以传出\n也可以不写参数\n也可以多个不同类型的参数\n\ncharcateristics可选参数：\nLANGUAGE SQL|[NOT] DETERMINISTTIC|&#123;CONTAINS SQL|NO SQL|READS SQL DATA|MODIFIESC SQL DATA&#125;|SQL DECURITY&#123;DEFINER|INVOKER&#125;|COMMENT &#x27;string&#x27;\n\n\nLANGUAGE SQL:说明存储过程体是由SQL语句组成的，当前系统支持的语言为SQL\n\n[NOT] DETERMINISTTIC：指明存储过程执行的结果是否确定。DETERMINISTTIC 表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。[NOT] DETERMINISTTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。\n\n{CONTAINS SQL|NO SQL|READS SQL DATA|MODIFIESC SQL DATA}：指明子程序使用SQL语句的限制\n\nCONTAINS SQL 表示当前存储过程的子程序包含SQL语句，但是并不会包含读写数据的SQL语句；\nNO SQL 表示当前存储过程的子程序中不包含任何SQL语句；\nREADS SQL DATA 表示当前存储过程的子程序中包含读数据的SQL语句\nMODIFIESC SQL DATA 表示当前存储过程的子程序中包含写数据的SQL\n默认情况下，系统会指定为CONTAINS SQL。\n\n\nSQL DECURITY{DEFINER|INVOKER}:执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。\n\nDEFINER表示只有当前存储过程的创建者或者定义这才能执行当前存储过程\nINVOKER表示拥有当前存储过程的访问权限的用户能够执行当前的存储过程\n如果没有设置相关的值，则MYSQL默认指定值为DEFINER\n\n\nCOMMENT ‘string’注释信息，可以用来描述存储的过程。\n\n\n存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以忽略BEGIN和END编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的SQL语句。\nBEGIN...END:中间包含了多个语句，每个语句都可以用（;）号为结束符DECLARE：DECLARE用来声明变量，使用的位置在于BEGIN...END语句中间，而且需要在其他语句使用之前进行变量的声明SET：赋值语句，对于对变量进行赋值SELECT...INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值\n\n需要设置新的结束标记\nDELIMITER 新的结束标记\n\n因为MYSQL默认的语句结束符号位分号’;’。为了避免与存储过程中SQL语句结束符相冲突，需要使DELIMITER该改变存储过程的结束符。\n比如：”DELIMITER &#x2F;&#x2F;“语句的作用是将MYSQl的结束符设置位&#x2F;&#x2F;，并以”END &#x2F;&#x2F;“结束存储过程。存储过程定义完毕之后再使用”DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他字符作为结束符。\n如果使用的是Navicat工具，那么再编写存储过程的时候，Navicat会自动设置DELIMITER为其他符号，我们不需要再进行DELIMITER的操作。\n\n当使用DELIMITER命令时，应该避免使用反斜杠（’&#39;）字符，因为反斜杠是MYSQL的转义字符。\n\nDELIMITER $CREATE PROCEDURE [IF NOT EXISTS] 存储过程名称([IN|OUT|INPUT 参数名 参数类型,...])[charcateristics ...]BEGINsql语句1;sql语句2;....ENDDELIMITER ;\n\n使用自定义的存储过程\nCALL 函数名(参数);\n\n例子：\n这是有参数的存储过程创建CREATE PROCEDURE  存储过程名称(IN 参数名 参数类型)BEGINsql语句1;END调用有两种：1.CALL 函数名(参数);2.SET @变量名=&quot;&quot;;CALL 函数名(@变量名);有返回值的存储过程创建CREATE PROCEDURE  存储过程名称(OUT 返回值 返回值类型)BEGINSELECT ... INTO(返回值)......END--定义变量set @变量名=0;-&gt;需要初始化CALL 函数名(@变量名);SELECT @变量名;传参并返回的存储过程创建CREATE PROCEDURE  存储过程名称(INOUT 返回值 返回值类型)BEGIN 嵌套查询语句...END--定义变量set @变量名=0;-&gt;需要初始化CALL 函数名(@变量名);SELECT @变量名;\n\n存储函数语法分析语法格式\nCREATE FUNCTION 函数名(参数名 参数类型,..)RETURNS 返回值类型[characteristics ...]BEGIN函数体 #函数体里一定有RETURN 语句END\n\n说明：\n\n参数列表：指定参数位IN,OUT,INOUT只对POCEDURE是合法的，FUNCTION中总是默认位IN参数。\nRETURNS type语句表示函数返回数据的类型;\n\n\nRETURNS子句只能对FUNCTION做指定，对函数而言这是强制的。他用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。\n\ncharacteristics创建函数时指定的对函数的约束。取值与创建存储过程时相同。\n函数例子：\n\n在创建多个函数的时候，咱们可以在开头写上：SET GLOBAL log_bin_trust_function_creators&#x3D;1;#默认时0就不会报错了。\n对比存储函数和存储过程\n\n\n\n关键字\n调用语法\n返回值\n应用场景\n\n\n\n函数过程\nPROCEDURE\nCALL存储过程()\n理解为有0个或多个\n一般用于更细\n\n\n存储函数\nFUNCTION\nSELECT函数()\n只能是一个\n一般用于查询结果为一个值并返回时\n\n\n此外，存储函数可以放在查询语句中使用，存储过程不行。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能时存储函数不具备的。\n存储过程和函数的查看、修改、删除查看MYSQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可以直接从系统的information_schema数据库中查询。1.使用SHOW CREATE 语句查看存储过程和函数的创建信息语法：\nSHOW CREATE &#123;PROCEDURE|FUNCTION&#125;存储过程名或函数名\n\n2.使用SHOW STATUS 语句查看存储过程和函数的状态信息基本语法：\nSHOW  &#123;PROCEDURE|FUNCTION&#125; STATUS [LIKE &#x27;pattern&#x27;]\n\n这个语句返回子程序的特征，如数据库，名字，类型，创建者及修改日期。[LIKE ‘pattern’]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MYSQL数据库中存在的所有存储过程或函数的信息。\n3.从information_schema.Routines表中查看存储过程和函数信息MYSQL中存储过程和函数的信息存储在information_schema数据库下Routines表中。可以通过查询该表的记录来查询过程和函数的信息。基本语句：\nSELECT * FROM information_schema.RoutinesWHERE ROUTINE_NAME=&#x27;存储过程或函数名&#x27;[AND ROUTINE_TYPE=&#123;&#x27;PROCEDURE|FUNCTION&#x27;&#125;];\n\n说明：如果在MYSQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE条件查询，指明查询的时存储过程还是函数。\n修改修改存储过程和函数，不影响存储过程或函数的功能，只是修改相关特性。使用ALTER语句来实现。\nALTER &#123;PROCEDURE|FUNCTION&#125; 存储过程或函数的名 [characteristic]\n\n\n修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构时一样的，语句中的所有参数也是一样的。\n\n删除删除存储过程和函数，可以使用DROP语句，其语法结构：\nDROP &#123;PROCEDURE|FUNCTION&#125; [IF EXISTS]存储过程或函数的名\n\nIF EXISTS:如果程序或函数不存储，他可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。\n变量、分支结构、循环结构以及游标变量在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。\n在 MySQL 数据库中，变量分为 系统变量以及用户自定义变量。\n系统变量系统变量分类变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间， MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特  征。这些系统变量的值要么是 编译MySQL时参数 的默认值，要么是 配置文件 （例如my.ini等）中的参数值。大家可以在官网Server System Variables中查看MySQL文档的系统变量。\n系统变量分为全局系统变量（需要添加global关键字）以及会话系统变量（需要添加session关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。**如果不写，默认是会话级别。**静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。\n每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例  会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变  量值的复制。\n\n全局系统变量针对于所有会话（连接）有效，但不能跨重启。\n会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。\n会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。\n\n在MySQL中有些系统变量只能是全局的，例如  max_connections  用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client  用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。\n查看系统变量\n 查看所有或部分系统变量\n#查看所有全局变量SHOW GLOBAL VARIABLES;#查看所有会话变量SHOW SESSION VARIABLES;#或SHOW VARIABLES;\n\n#查看满足条件得部分系统变量SHOW GLOBAL VARIABLES LIKE &#x27;%标识符%&#x27;;#查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#x27;%标识符%&#x27;\n\n范例：\nSHOW GLOBAL VARIABLES LIKE &#x27;admin_%&#x27;;\n\n查看指定系统变量\n\n\n作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，  则标记全局系统变量。\n#查看指定的系统变量的值SELECT @@global.变量名;#查看指定的会话变量的值SELECT @@session.变量名;#或SELECT @@变量名;\n\n\n修改系统变量的值\n\n有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、  特征。具体方法：\n方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）\n方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值\n#为某个系统变量赋值#方式1：SET @@global.变量名=值;#方式2：SET GLOBAL 变量名=值;#为某个会话变量赋值#方式1：SET @@session.变量名=值;#方式2：SET SESSION 变量名=值\n\n范例：\nSELECT @@global.autocommit;SET GLOBAL autocommit=0;\n\nSELECT @@session.tx_isolation;SET @@session.tx_isolation=&#x27;read-uncommitted&#x27;;\n\nSET GLOBAL max_connections = 1000;SELECT @@global.max_connections;\n\n补充：MySQL 8.0的新特性——全局变量的持久化在MySQL数据库中，全局变量可以通过SET  GLOBAL语句来设置。例如，设置服务器语句超时的限制，可以通过设置系统变量max_execution_time来实现：\nSET GLOBAL MAX_EXECUTION_TIME=2000;\n\n使用SET GLOBAL语句设置的变量值只会 临时生效 。 数据库重启 后，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了 SET PERSIST 命令。例如，设置服务器的最大连接数为1000：\nSET PERSIST global max_connections = 1000;\n\nMySQL会将该命令的配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。\n举例：\n查看全局变量max_connections的值，结果如下：\nmysql&gt; show variables like &#x27;%max_connections%&#x27;;+------------------------+-------+| Variable_name | Value  |+------------------------+-------+| max_connections | 151  || mysqlx_max_connections | 100|+------------------------+-------+2 rows in set, 1 warning (0.00 sec)\n\n设置全局变量max_connections的值：\nmysql&gt; set persist max_connections=1000; Query OK, 0 rows affected (0.00 sec)\n\n重启MySQL服务器，再次查询max_connections的值：\nmysql&gt; show variables like &#x27;%max_connections%&#x27;;+------------------------+-------+| Variable_name | Value |+------------------------+-------+| max_connections | 1000 || mysqlx_max_connections | 100 |+------------------------+-------+2 rows in set, 1 warning (0.00 sec)\n\n用户变量用户变量分类用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用范围不同，又分为会话用户变量和局部变量。\n\n会话用户变量：作用域和会话变量一样，只对当前连接会话有效。\n局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在存储过程和函数中使用。\n\n注意：在 MySQL 5.0以前的版本中是大小写敏感的，因此要注意（在 MySQL 5.0以后已经不区分大小写了）。\n会话用户变量\n变量的定义\n\n#方式1：&quot;= 或 &quot;:=SET @用户变量=值SET @用户变量:=值#方式2：&quot;:=&quot; 或 INTO关键字SELECT @用户变量 :=表达式[FROM等子句];SELECT 表达式 INTO @用户变量 [FROM等子句];\n\n\n查看自定义变量的值\n\nSELECT @用户变量;\n\n范例：\nSET @n1 =1;SET @n2 :=3;SET @sum := @n1+@n2;SELECT @sum;\n\nSELECT @num := COUNT(*) FROM emps;SELECT @num;\n\nSELECT AVG(sal) INTO @avgsal FROM emps;SELECT  @avgsal;\n\n#查看某个未定义的变量时，将得到NULL值SELECT @maye;\n\n局部变量定义：可以使用 DECLARE 语句定义一个局部变量作用域：仅仅在定义它的 BEGIN … END 中有效\n位置：只能放在 BEGIN … END 中，而且只能放在第一句\nBEGIN  #声明局部变量  DECLARE 变量1 数据类型 [DEFAULT 默认值];  DECLARE 变量2,变量3,... 数据类型 [DEFAULT 默认值];  #为局部变量赋值  SET 变量1 = 值;  SELECT 字段 INTO 变量2 [FROM 子句];  #查看局部变量的值  SELECT 变量1,变量2,变量3;END\n\n定义变量DECLARE 变量名 类型 [DEFAULT 值]; # 如果没有DEFAULT子句，初始值为NULL\n\n范例：\nDECLARE num INT DEFAULT 100;\n\n变量赋值 方式1：一般用于赋简单的值\nSET 变量=值;SET 变量:=值;\n\n方式2：一般用于赋表中的字段值\nSELECT 字段名或表达式 INTO 变量名 FROM 表;\n\n使用变量 SELECT 局部变量名;\n\n**范例1：**声明局部变量，并分别赋值为emps表中empno为7369的ename和sal。\nCREATE PROCEDURE set_value() BEGIN  DECLARE emp_name VARCHAR(25);   DECLARE em_sal DOUBLE(10,2);    SELECT ename,sal INTO emp_name,emp_sal   FROM emps  WHERE empno = 7369;  SELECT emp_name,emp_sal; END;\n\n**范例2：**声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）\n#方式1：使用用户变量SET @m=1;SET @n=2;SET @sum = @m+@n;SELECT @sum;\n\n#方式2：使用局部变量CREATE PROCEDURE add_value()BEGIN  DECLARE m INT DEFAULT 1;  DECLARE n INT DEFAULT 3;  DECLARE sum INT;  SET sum=m+n;  SELECT sum;END;\n\n**范例3：**创建存储过程“diff_sal”查询某员工和他领导的薪资差距，并用IN参数eno接收员工编号，用OUT参数dif_sal输出薪资差距结果。\nCREATE PROCEDURE different_sal(IN eno INT,OUT dif_sal DOUBLE) BEGIN  #声明局部变量  DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;   DECLARE mgr_no INT;  SELECT sal INTO emp_sal FROM emps WHERE empno = eno; \t  SELECT mgr INTO mgr_no FROM emps WHERE empno = eno;   SELECT sal INTO mgr_sal FROM emps WHERE empno = mgr_no;  SET dif_sal = mgr_sal - emp_sal; END;#调用SET @emp_no = 102;CALL different_salary(@emp_no,@diff_sal);#查看SELECT @diff_sal;\n\n会话用户变量与局部变量对比\n\n\n变量类型\n作用域\n定义位置\n语法\n\n\n\n会话用户变量\n作用域当前会话\n定义位置会话的任何地方\n语法加@符号，不用指定类型\n\n\n局部变量\n定义它的BEGIN END中\nBEGIN END的第一句话\n一般不用加@，需要指定类型\n\n\n异常处理机制定义条件是事先定义程序执行过程中可能遇到的问题， 处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。\n说明：定义条件和处理程序在存储过程、存储函数中都是支持的。\n案例分析**案例分析：**创建一个名称为“UpdateData”的存储过程。代码如下：\nCREATE PROCEDURE UpdateData() BEGIN  SET @x = 1;  UPDATE emps SET sal = NULL WHERE ename = &#x27;WARD&#x27;;   SET @x = 2;  UPDATE emps SET sal = 200 WHERE ename = &#x27;WARD&#x27;;   SET @x = 3;END ;\n\n调用存储过程：\nmysql&gt; CALL UpdateData();ERROR 1048 (23000): Column &#x27;sal&#x27; cannot be nullmysql&gt; SELECT @x;+------+| @x |+------+| 1 |+------+1 row in set (0.00 sec)\n\n可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件  和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，  不再向下继续执行。\n定义条件定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个错误名字和错误条件关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中。\n定义条件使用DECLARE语句，语法格式如下：\nDECLARE 错误名称 CONDITION FOR 错误码(或错误条件)\n\n错误码的说明：\n\nMySQL_error_code 和 sqlstate_value 都可以表示MySQL的错误。\n\nMySQL_error_code是数值类型错误代码。\nsqlstate_value是长度为5的字符串类型错误代码。\n\n\n例如，在ERROR 1048 (23000)中，1048是MySQL_error_code，’23000’是sqlstate_value。\n\n例如，在ERROR 1146（42S02）中，1146是MySQL_error_code，’42S02’是sqlstate_value。\n\n\n**范例1：**定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR  1048  (23000)”对应。\n#使用MySQL_error_codeDECLARE Field_Not_Be_NULL CONDITION FOR 1048;#使用sqlstate_valueDECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE &#x27;23000&#x27;;\n\n**范例2：**定义”ERROR 1148(42000)”错误，名称为command_not_allowed。\n#使用MySQL_error_codeDECLARE command_not_allowed CONDITION FOR 1148;#使用sqlstate_valueDECLARE command_not_allowed CONDITION FOR SQLSTATE &#x27;42000&#x27;;\n\n定义处理程序可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句  的语法如下：\nDECLARE 处理方式 HANDLER FOR 错误类型 处理语句;\n\n\n处理方式：处理方式有3个取值：CONTINUE、EXIT、UNDO。\n\nCONTINUE ：表示遇到错误不处理，继续执行。\nEXIT ：表示遇到错误马上退出。\nUNDO ：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。\n\n\n错误类型：（即条件）可以有如下取值：\n\nSQLSTATE &#39;字符串错误码&#39; ：表示长度为5的sqlstate_value类型的错误代码；\nMySQL_error_code ：匹配数值类型错误代码；\n错误名称 ：表示DECLARE … CONDITION定义的错误条件名称。\nSQLWARNING ：匹配所有以01开头的SQLSTATE错误代码； \nNOT FOUND ：匹配所有以02开头的SQLSTATE错误代码；\nSQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；\n\n\n\n处理语句：：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是  像“ SET 变量 &#x3D; 值 ”这样的简单语句，也可以是使用 BEGIN … END 编写的复合语句。\n定义处理程序的几种方式，代码如下：\n#方法1：捕获sqlstate_valueDECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27; SET @info = &#x27;NO_SUCH_TABLE&#x27;;#方法2：捕获mysql_error_valueDECLARE CONTINUE HANDLER FOR 1146 SET @info = &#x27;NO_SUCH_TABLE&#x27;;#方法3：先定义条件，再调用DECLARE no_such_table CONDITION FOR 1146;DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#x27;NO_SUCH_TABLE&#x27;;#方法4：使用SQLWARNINGDECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#x27;ERROR&#x27;;#方法5：使用NOT FOUNDDECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#x27;NO_SUCH_TABLE&#x27;;#方法6：使用SQLEXCEPTIONDECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#x27;ERROR&#x27;;\n\n案例解决在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行\nCONTINUE操作，并且将@proc_value的值设置为-1。\nCREATE PROCEDURE UpdateDataNoCondition() BEGIN  #定义处理程序  DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;  SET @x = 1;  UPDATE emps SET sal = NULL WHERE ename = &#x27;WARD&#x27;;   SET @x = 2;  UPDATE emps SET sal = 200 WHERE ename = &#x27;WARD&#x27;;   SET @x = 3;END ;\n\n调用过程：\nmysql&gt; CALL UpdateDataWithCondition(); Query OK, 0 rows affected (0.01 sec)mysql&gt; SELECT @x,@proc_value;+------+-------------+| @x  | @proc_value |+------+-------------+| 3 | -1 |+------+-------------+1 row in set (0.00 sec)\n\n**范例：**创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。\n在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操   作，并且将@proc_value的值设置为-1。\n#准备工作CREATE TABLE depts ASSELECT * FROM test.dept;ALTER TABLE deptsADD CONSTRAINT uk_dept_name UNIQUE(deptno);\n\nCREATE PROCEDURE InsertDataWithCondition() BEGIN  DECLARE duplicate_entry CONDITION FOR SQLSTATE &#x27;23000&#x27; ;   DECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value = -1;  SET @x = 1;  INSERT INTO depts(dname) VALUES(&#x27;测试&#x27;);   SET @x = 2;  INSERT INTO depts(dname) VALUES(&#x27;测试&#x27;);  SET @x = 3;END ;\n\n调用存储过程：\nmysql&gt; CALL InsertDataWithCondition(); Query OK, 0 rows affected (0.01 sec)mysql&gt; SELECT @x,@proc_value;+------+-------------+| @x | @proc_value |+------+-------------+| 2 | -1 |+------+-------------+1 row in set (0.00 sec)\n\n流程控制解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中  SQL  语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：\n\n顺序结构 ：程序从上往下依次执行\n分支结构 ：程序按条件进行选择执行，从两条或多条路径中选择一条执行\n循环结构 ：程序满足一定条件下，重复执行一组语句\n\n针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。\n\n条件判断语句 ：IF 语句和 CASE 语句\n循环语句 ：LOOP、WHILE 和 REPEAT 语句\n跳转语句 ：ITERATE 和 LEAVE 语句\n\n分支结构之 IFIF 语句的语法结构是：\nIF 表达式1   THEN 操作1[ELSEIF 表达式2 THEN 操作2] ...[ELSE 操作N]END IF\n\n根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。\n\n特点：① 不同的表达式对应不同的操作​       ② 使用在begin end中\n\n范例1：\n\n\nIF val IS NULLTHEN SELECT &#x27;val is null&#x27;;ELSE SELECT &#x27;val is not null&#x27;;\tEND IF\n\n**范例2：**声明存储过程“update_sal_by_eno”，定义IN参数eno，输入员工编号。判断该员工 薪资如果低于2000元并且入职时间超过5年，就涨薪500元；否则就不变。\nCREATE PROCEDURE update_sal_by_eno1(IN eno INT) BEGIN  DECLARE emp_sal DOUBLE;   DECLARE hire_year DOUBLE;  SELECT sal INTO emp_sal FROM emps WHERE empno = eno;  SELECT DATEDIFF(CURDATE(),hiredate)/365 INTO hire_year   FROM emps WHERE empno = eno;  IF emp_sal &lt; 2000 AND hire_year &gt; 5  THEN UPDATE emps SET sal = sal + 500 WHERE empno = eno;   END IF;END ;\n\n**范例3：**声明存储过程“update_sal_by_eno2”，定义IN参数eno，输入员工编号。判断该员工  薪资如果低于3000元，就更新薪资为3000元；薪资如果大于等于3000元且低于5000的，但是奖金 比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。\nDELIMITER //CREATE PROCEDURE update_sal_by_eno2(IN eno INT) BEGIN  DECLARE emp_sal DOUBLE;   DECLARE emp_comm DECIMAL(5,2);  SELECT sal INTO emp_sal FROM emps WHERE empno = eno;   SELECT comm INTO emp_comm FROM emps WHERE empno = eno;  IF emp_sal &lt; 3000    THEN UPDATE emps SET sal = 3000 WHERE empno = eno;    SELECT &#x27;1&#x27;;  ELSEIF emp_sal &lt; 5000 AND emp_comm IS NULL    THEN UPDATE emps SET comm = 0.01*sal WHERE empno = eno;    SELECT &#x27;2&#x27;;  ELSE    UPDATE emps SET sal = sal + 100 WHERE empno = eno;     SELECT &#x27;3&#x27;;  END IF;END //DELIMITER //\n\n分支结构之 CASECASE 语句的语法结构1：\n #情况一：类似于switch CASE 表达式WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号) WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句，需要加分号)END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）\n\nCASE 语句的语法结构2：\n#情况二：类似于多重if CASEWHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号)WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句，需要加分号)END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）\n\n**范例1：**使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。\nCASE val  WHEN 1 THEN SELECT &#x27;val is 1&#x27;;   WHEN 2 THEN SELECT &#x27;val is 2&#x27;;  ELSE SELECT &#x27;val is not 1 or 2&#x27;; END CASE;\n\n**范例2：**使用CASE流程控制语句的第2种格式，判断val是否为空、小于0、大于0或者等于0。\nCASE  WHEN val IS NULL THEN SELECT &#x27;val is null&#x27;;   WHEN val &lt; 0 THEN SELECT &#x27;val is less than 0&#x27;;  WHEN val &gt; 0 THEN SELECT &#x27;val is greater than 0&#x27;;   ELSE SELECT &#x27;val is 0&#x27;;END CASE;\n\n**范例3：**声明存储过程“update_salary_by_eno4”，定义IN参数eno，输入员工编号。判断改员工所属部门，如果在10号部门，工资加500；如果在20号部门，工资加600；如果在30号部门，工资加700;其他部门加300。\nCREATE PROCEDURE update_salary_by_eno4(IN eno INT) BEGIN  DECLARE dept_no,emp_sal INT;   SELECT sal,deptno INTO emp_sal,dept_no FROM emps WHERE empno = eno;   CASE deptno  WHEN 10    THEN UPDATE emps SET sal=emp_sal+500 WHERE empno = eno;   WHEN 20    THEN UPDATE emps SET sal=emp_sal+600 WHERE empno = eno;   WHEN 30    THEN UPDATE emps SET sal=emp_sal+700 WHERE empno = eno;  ELSE     UPDATE emps SET sal=emp_sal+300 WHERE empno = eno;\t  END CASE;END //\n\n**范例4：**声明存储过程pro_sal_grade，定义IN参数eno，输入员工编号。判断该员工的薪资等级，如果在[700,1200]之间，为等级一；如果在[1201，1400]之间，为等级二；如果在[1401,2000]之间，为等级三；如果在[2001,3000]之间，为等级四；如果在[3001,9999]之间，为等级五；\nCREATE PROCEDURE sal_grade(IN eno INT) BEGIN  DECLARE emp_sal INT;   SELECT sal INTO emp_sal FROM emps WHERE empno = eno;  CASE     WHEN emp_sal&gt;=700 AND emp_sal&lt;=1200      THEN SELECT &#x27;等级一&#x27;;    WHEN emp_sal&gt;=1201 AND emp_sal&lt;=1400       THEN SELECT &#x27;等级二&#x27;;          WHEN emp_sal&gt;=1401 AND emp_sal&lt;=2000       THEN SELECT &#x27;等级三&#x27;;    WHEN emp_sal&gt;=2001 AND emp_sal&lt;=3000       THEN SELECT &#x27;等级四&#x27;;    WHEN emp_sal&gt;=3001 AND emp_sal&lt;=999       THEN SELECT &#x27;等级五&#x27;;  END CASE;END //\n\n循环结构之 LOOPLOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子  句），跳出循环过程。\nLOOP语句的基本格式如下：\n[loop_label:] LOOP    循环执行的语句END LOOP [loop_label] \n\n其中，loop_label表示LOOP语句的标注名称，该参数可以省略。\n**范例1：**使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。\n DECLARE id INT DEFAULT 0;add_loop:LOOP  SET id = id +1;  IF id &gt;= 10   THEN LEAVE add_loop;   END IF;END LOOP add_loop;\n\n**范例2：**当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_sal_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.1倍。直到全公司的平均薪资达到8000结束。并统计循环次数。\nCREATE PROCEDURE update_sal_loop(OUT num INT) BEGIN  DECLARE avg_sal DOUBLE;   DECLARE loop_count INT DEFAULT 0;  SELECT AVG(sal) INTO avg_sal FROM emps;  label_loop:LOOP    IF avg_sal &gt;= 8000     THEN LEAVE label_loop;     END IF;    UPDATE emps SET sal = sal * 1.1;     SET loop_count = loop_count + 1;    SELECT AVG(sal) INTO avg_salary FROM emps;   END LOOP label_loop;SET num = loop_count; END ;\n\n循环结构之 WHILEWHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如  果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：\n [while_label:] WHILE 循环条件 DO  循环体END WHILE [while_label];\n\nwhile_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直   至循环条件为假，退出循环。\n**范例1：**WHILE语句示例，i值小于10时，将重复执行循环过程，代码如下：\n CREATE PROCEDURE test_while()BEGIN  DECLARE i INT DEFAULT 0;  WHILE i &lt; 10 DO     SET i = i + 1;  END WHILE;  SELECT i;END ;#调用CALL test_while();\n\n**范例2：**市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到3000结束。并统计循环次数。\nCREATE PROCEDURE update_sal_while(OUT num INT) BEGIN  DECLARE avg_sal DOUBLE ;  DECLARE while_count INT DEFAULT 0;  SELECT AVG(sal) INTO avg_sal FROM emps;   WHILE avg_sal &gt; 3000 DO    UPDATE emps SET sal = sal * 0.9;     SET while_count = while_count + 1;    SELECT AVG(sal) INTO avg_sal FROM emps;   END WHILE;  SET num = while_count; END //\n\n循环结构之 REPEATREPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。\nREPEAT语句的基本格式如下：\n[repeat_label:] REPEAT    循环体的语句UNTIL 结束循环的条件表达式END REPEAT [repeat_label]\n\nrepeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。\n范例1：\nCREATE PROCEDURE test_repeat() BEGIN  DECLARE i INT DEFAULT 0;  REPEAT    SET i = i + 1;   UNTIL i &gt;= 10  END REPEAT;  SELECT i;END ;\n\n**范例2：**当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到9000结束。并统计循环次数。\nCREATE PROCEDURE update_salary_repeat(OUT num INT) BEGIN  DECLARE avg_sal DOUBLE ;  DECLARE repeat_count INT DEFAULT 0;  SELECT AVG(sal) INTO avg_sal FROM emps;   REPEAT    UPDATE emps SET sal = sal * 1.15;        SET repeat_count = repeat_count + 1;    SELECT AVG(sal) INTO avg_sal FROM emps;   UNTIL avg_sal &gt;= 9000  END REPEAT;  SET num = repeat_count; END //\n\n对比三种循环结构：\n1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。\n2、 LOOP：一般用于实现简单的”死”循环 WHILE：先判断后执行 REPEAT：先执行后判断，无条件至少执行一次\n跳转语句之 LEAVE语句LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。\n基本格式如下：\nLEAVE 标记名\n\n其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。\n**范例1：**创建存储过程 “leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在BEGIN…END中使用IF语句判断num参数的值。\n\n如果num&lt;&#x3D;0，则使用LEAVE语句退出BEGIN…END； \n如果num&#x3D;1，则查询“emps”表的平均薪资； \n如果num&#x3D;2，则查询“emps”表的最低薪资； \n如果num&gt;2，则查询“emps”表的最高薪资。\n\nIF语句结束后查询“emp”表的总人数。\nCREATE PROCEDURE leave_begin(IN num INT) \tbegin_label: BEGIN\t\tIF num&lt;=0\t\t\tTHEN LEAVE begin_label; \t\tELSEIF num=1\t\t\tTHEN SELECT AVG(sal) FROM emps; \t\tELSEIF num=2\t\t\tTHEN SELECT MIN(sal) FROM emps; \t\tELSE\t\t\tSELECT MAX(sal) FROM emps; \t\tEND IF;\t\tSELECT COUNT(*) FROM emps; END ;\n\n**范例2：**当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公  司的平均薪资小于等于10000，并统计循环次数。\nCREATE PROCEDURE leave_while(OUT num INT)BEGIN\t#\tDECLARE avg_sal DOUBLE;#记录平均工资\tDECLARE while_count INT DEFAULT 0; #记录循环次数\tSELECT AVG(sal) INTO avg_sal FROM emps; #① 初始化条件\twhile_label:WHILE TRUE DO #② 循环条件\t\t#③ 循环体\t\tIF avg_sal &lt;= 10000 \t\t\tTHEN LEAVE while_label;\t\tEND IF;\t\tUPDATE emps SET sal = sal * 0.9; \t\tSET while_count = while_count + 1;\t\t#④ 迭代条件\t\tSELECT AVG(sal) INTO avg_sal FROM emps; \tEND WHILE;\t#赋值\tSET num = while_count; END ;\n\n\n\n跳转语句之 ITERATE 语句ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序   转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为  continue，意思为“再次循环”。\n语句基本格式如下：\n ITERATE label\n\nlabel参数表示循环的标志。ITERATE语句必须跟在循环标志前面。\n范例： 定义局部变量num，初始值为0。循环结构中执行num + 1操作。\n\n如果num &lt; 10，则继续执行循环；\n\n如果num &gt; 15，则退出循环结构；\n\n\nCREATE PROCEDURE test_iterate() BEGIN\tDECLARE num INT DEFAULT 0;\tmy_loop:LOOP\t\tSET num = num + 1;\t\tIF num &lt; 10\t\t\tTHEN ITERATE my_loop; \t\tELSEIF num &gt; 15\t\t\tTHEN LEAVE my_loop; \t\tEND IF;\t\tSELECT &#x27;顿开教育：让每个学员都学有所成&#x27;; \tEND LOOP my_loop;END //\n\n游标什么是游标（或光标）虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录， 但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是随意定位到某一条记录 ，并对记录的数据进行处理。\n这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录  进行定位，并对指向的记录中的数据进行操作的数据结构。游标让 SQL 这种面向集合的语言有了面向过程开发的能力。\n在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用 ，我们可以通过操作游标来对数据行进行操作。\nMySQL中游标可以在存储过程和函数中使用。\n比如，我们查询了 emps数据表中工资高于1500的员工都有哪些：\nSELECT empno,ename,sal FROM emps WHERE sal &gt; 1500;\n\n\n这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“7698”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。\n使用游标步骤游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。   如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。\n第一步，声明游标\n在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：\nDECLARE cursor_name CURSOR FOR select_statement;\n\n这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：\nDECLARE cursor_name CURSOR IS select_statement;\n\n 要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是\nSELECT 语句，返回一个用于创建游标的结果集。\n比如：\nDECLARE cur_emp CURSOR FORSELECT empno,sal FROM emps;\n\nDECLARE cursor_dept CURSOR FOR SELECT deptno,dname, loc FROM depts ;\n\n第二步，打开游标\n打开游标的语法如下：\nOPEN cursor_name\n\n当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT  语句的查询结果集就会送到游标工作区，为后面游标的 逐条读取 结果集中的记录做准备。\nOPEN cur_emp ;\n\n 第三步，使用游标（从游标中取得数据）\n语法如下：\nFETCH cursor_name INTO var_name [, var_name] ...\n\n这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。\n注意：var_name必须在声明游标之前就定义好。\n FETCH cur_emp INTO emp_no, emp_sal ;\n\n注意：游标的查询结果集中的字段数，必须跟 INTO  后面的变量数一致，否则，在存储过程执行的时候，MySQL 会提示错误。\n 第四步，关闭游标\nCLOSE cursor_name\n\n有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源 ，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。\n关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。\nCLOSE cur_emp; \n\n举例创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary；声明OUT参数total_count。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和 达到limit_total_salary参数的值，返回累加的人数给total_count。\nCREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_sal INT,OUT total_count INT)BEGIN\t#声明变量\tDECLARE sum_sal INT DEFAULT  0;   #记录累加的总工资\tDECLARE emp_count INT DEFAULT  0; #记录循环总次数\tDECLARE emp_sal INT;               #当前员工的工资\t\t#声明游标\tDECLARE  cursor_emp CURSOR FOR SELECT sal FROM emp ORDER BY sal DESC;\t#打开游标\tOPEN cursor_emp;\t#使用游标\tWHILE sum_sal &lt; limit_total_sal DO\t\t\tFETCH cursor_emp INTO emp_sal;\t\t\tSET sum_sal = emp_sal+sum_sal;\t\t\tSET emp_count = emp_count+1;\tEND WHILE;\t\t#关闭游标\tCLOSE cursor_emp;\t#设置传出参数值\tSET total_count = emp_count;END;\n\n小结游标是 MySQL 的一个重要的功能，为 逐条读取 结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。\n但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行加锁 ，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会  消耗系统资源 ，造成内存不足，这是因为游标是在内存中进行的处理。\n建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。\n触发器MYSQL从5.0.2版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MYSQL服务器的一段程序。\n触发器是由事件来触发某个操作的。所谓事件就是指用户的动作或者触发某项行为。如当对数据表中的数指向插入、更新和删除操作，需要自动执行一些数据库逻辑时。可以使用触发器来实现。\n触发器的创建触发器的语法：\nCREATE TRIGGER 触发器名称&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名FOR EACH ROW触发器执行的语句块;\n\n说明：\n\n表名:表示触发器监控对象。\n\nBEFORE|AFTER:表示触发的事件。BEFORE表示在事件之前触发;AFTER表示在事件之后触发。\n\nINSERT|UPDATE|DELETE：表示触发的事件。\n\nINSERT 表示插入记录时触发\nUPDATE 表示更新记录时触发\nDELETE 表示删除记录时触发\n\n\n触发器执行的语句块：可以时单条SQL语句，也可以时由BEGIN…END结构组成的复合语句块。\n\n\nOLD和NEW在触发器正文中，OLD和new关键字使您能够访问受触发器影响的行中的列。old和new使MYSQL对触发器的扩展；他们区别分大小写\n在insert触发器中，只能使用new.col_name没有旧行。在delete触发器中，只能使用old.col_name；没有新行。在update触发器中。您可以使用old.col_name来引用行更新之前的列，使用new.col_name来引用行更新后的列。\n以old命名的列使只读的。您可以参考他（如果您有select权限)，但不能修改他。如果您具有select权限，则可以引用以new命名的列。在before触发器中，如果您具有update权限，您还可以使用set new.col_name&#x3D;value更改其值。这意味着您可以使用触发器来修改要插入新行或用于更新行的值。在before触发器中，auto_increment列的new值为0，而不是实际擦汗如新行时自动生成的序列号。\n插入失败手动报错：SIGNAL SQLSTATE ‘错误编号’ SET MESSAGE_TEXT &#x3D;’错误提示’;\n查看、删除触发器查看触发器是查看数据库中已经纯在的触发器的定义、状态和语法信息等\n方法1：查看当前数据库的所有触发器的定义SHOW TRIGGERS;方法2：查看当前数据库中某个触发器的定义SHOW CREATE TRIGGERS 触发器名;方法3：从系统库information_schema的TRIGGERS表中查询指定数据库的触发器信息。SELECT * FROM information_schema.TRIGGERS WHERE trigger_schema&#x3D;’db_14’;\n删除触发器\n\n触发器也是数据库对象，删除触发器也用DROP语句\n如果您删除一个表，该表的所有触发器也会被删除\n\nDROP TRIGGER IF EXISTS 触发器名称;\n触发器的优缺点\n优点\n\n保证数据的完整性\n帮助我们记录操作日志\n可以用在操作数据前，对数据进行合法性检查\n\n\n缺点\n\n可读性差\n相关数据该表可能会导致触发器出错\n\n\n\n用户与权限管理MYsql用户可以分为普通用户和root用户。root用户是超级管理员，拥有所有的权限，包括创建用户、删除用户和修改用户的密码等管理权限，普通用户只拥有被授权的各种权限。\nmysql提供了许多语句来管理用户的账户，这些语句可以用来管理登录和退出MySQL服务器、创建用户、删除用户、密码权限管理和权限管理内容等内容。\nMySQL数据库的安全性需要通过账户管理来保证。\n登录MySQL服务器启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令：\nmysql [-h hostanme|hostIP -P port] -u username -p databaseName -e &quot;SQL语句&quot;\n\n参数详解：\n\n-h参数：指定MySQL服务所在的主机名或者主机IP。若不指定则自动连接本地的MySQL\n-p参数：指定MySQL服务器端口，默认端口是3306，若不指定则自动连接到3306端口\n-u参数：指定登录MySQL的用户名\n-p参数：会提示输入密码\ndatabaseName：登录之后选择的数据库\n\n创建用户使用CREATE USER ‘username’[@’登录主机名’] [IDENTIFIED] BY ‘密码’];\n参数详细：\n\nusingname:指定创建的用户账户，格式为‘usingname@hostname’usingname是用户名，hostname为主机名，即用户连接MySQL时所在主机的名字。若在创建的过程中，只给出了账户的用户名，而没有指定主机名，则主机名默认为”%”，表示一组主机。\nIDENTIFIED BY：用于指定账户对应的口令，若该用户账号无口令，则可省略此子句。\n密码：指定用户账户的口令\n\n使用注意事项：\n\n如果使用CREATE USER语句时没有为用户指定口令，那么MySQL允许该用户可以不使用口令登录系统，然而从安全的角度而言，不推荐这种做法。\n使用CREATE USER语句必须拥有MySQL中MySQL数据库的INSERT权限或全局CREATE USER权限，\n使用CREATE USER语句创建一个用户后，会在系统自身的MySQL数据库的user表中添加一条新纪录。若创建的账户已存在，则语句执行时会出现错误。\n新创建的用户拥有的权限很少。他们可以登录MySQL，只允许进行不需要权限的操作，如使用SHOW语句查询所有存储引擎和字符集的列表等。\n如果两个用户具有相同的用户名和不同的主机名，MySQL会将他们视为不同的用户，并允许为这两个用户分配不同的权限集合。\n\n删除用户方式一：使用DROP USING语句删除（推荐）\nDROP USER user;\n\n方式二：使用DELETE FROM 方式删除\nDELETE FROM mysql.user WHERE Host=&#x27;hostname&#x27; AND User=&#x27;username&#x27;;\n\n执行完DELETE命令后，需要使用FLUSH命令来使用户生效：\nFLUSH PRIVILEGES;#不刷新的话，还是可以登录的\n\n修改用户名和密码使用UPDATA语句修改用户名：\nUPDATA mysql.user SET USER=&#x27;新名字&#x27;WHERE USER=&#x27;旧名字&#x27;;FLUSH PRIVILEGES;\n\n适用于root用户修改自己的密码以及普通用户登录之后修改自己的密码。\n1.使用ALTER USER语句来修改当前用户密码，基本语法：\nALTER USER USER() IDENTIFIED BY &#x27;新密码&#x27;;\n\n2.使用SET语句来修改当前用户密码\nSET PASSWORD=&#x27;新密码&#x27;\n\n修改其他用户密码\nroot用户不仅可以修改自己的密码，还可以修改其他普通用户的密码\n1.使用ALTER语句来修改普通用户密码，基本语法：\nALTER USER user [IDENTIFIED BY &#x27;新密码&#x27;];\n\n2.使用SET语句来修改普通用户密码：\nSET PASSWORD FOR &#x27;username&#x27;@&#x27;hostname&#x27;=&#x27;新密码&#x27;;\n\n3.使用UPDATE语句来修改普通用户密码(不推荐)\nUPDATA mysql.user SET authentication_string=PASSWORD(&quot;新密码&quot;)WHERE User=&#x27;usrname&#x27; AND Host=&#x27;hostname&#x27;;\n\n密码的管理MySQL中记录使用过的历史密码，目前包括如下密码管理功能:\n\n密码过期：要求定期修改密码\n密码重用限制：不允许使用旧密码\n密码强度评估:要求使用高强度密码\n\n密码过期策略\n\n在MySQL中，数据库管理员可以手动设置账号密码过期，也可以建立一个自动密码过期策略。\n过期策略可以是全局的，也可以为每个账号单独设置过期策略。\n\n1.设置密码立即过期\nALTER USER user PASSWORD EXPLRE;\n\n2.设置指定事件过期\n如果密码使用的时间大于允许的时间，服务器会自动设置为过期，不需要手动设置。MySQL使用default_password_lifetime系统变量建立全局密码过期策略。\n\n他的默认值是0，表示禁用密码自动过期\n他允许的值是正整数N，表示允许的密码生存期，密码必须每隔N天进行修改\n\n全局设置\n\n方法一:使用SQL语句更改该变量的值并持久化\n\nSET PERSIST default_password_lifetime=N;\n\n\n方法2:把变量添加到配置晚间my.ini中\n\n[mysqld]default_password_lifetime=N\n\n指定用户过期\n每个账户既可以沿用全局密码过期策略，也可以单独设置。在CREATE USER和ALTER USER语句上加入PASSWORD EXPIRE选项并指定时长即可。\n\n设置密码90天过期一次\n\nCREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD EXPIRE INTERVAL 90 DAY;ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD EXPIRE INTERVAL 90 DAY;\n\n\n设置密码永不过期\n\nCREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD EXPIRE NERVER;ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27;  PASSWORD EXPIRE NERVER;\n\n\n沿用全局密码过期策略\n\nCREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD EXPIRE DEFAULT;ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27;  PASSWORD EXPIRE DEFAULT;\n\n密码重用策略MySQL限制使用已用过的密码。重用限制策略基础密码更改的数量和使用的时间。重用策略可以是全局的，也可以为每一个账户单独设置。\n\n账户的历史密码包含过去该账号所使用的密码。MySQL基于一下规则来限制密码重用：\n\n如果账号的密码限制基于密码更改的数量，那么新的密码不能从最近限制的密码数量中选择。例如：密码更改的最小值为3，那么新密码不能于最近3个密码中任意一个相同\n如果账户密码限制基于时间，那么新密码不能从规定时间内选择。例如：如果密码重用周期为60天，那么新密码不能从最近60天内使用的密码中选择。\n\n\nMySQL使用password_history和password_reuse_interval系统变量设置密码重用策略。\n\npassword_history：规定密码重用的数量\npassword_reuse_interval：规定密码重用的周期\n\n\n这两个变量在服务器的配置文件中进行维护，也可以在允许期间使用SQL语句更改变量的值并持续化。\n\n\n全局设置\n方法1：使用SQL\nSET PERSIST password_history=N;# 设置不能选最近使用的N个密码SET PERSIST password_reuse_interval=N;# 设置不能选最近使用N天的密码\n\n方法2：把变量添加到配置文件my.ini中\n[mysqld]password_history=Npassword_reuse_interval=N\n\n单独设置\n#不能使用最近N个密码：CREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD HISTORY N;ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD  HISTORY N;#不能使用最近N天内的密码：CREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD REUSE INTERVAL N DAY;ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD  REUSE INTERVAL N DAY;#即不能使用最近N个密码，也不能使用最近N天内的密码：CREATE USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD HISTORY N PASSWORD REUSE INTERVAL N DAY;ALTER USER &#x27;用户名&#x27;@&#x27;主机号&#x27; PASSWORD HISTORY N PASSWORD REUSE INTERVAL N DAY;\n\n权限管理关于MySQL的权限简单的理解就是MySQL允许你做你权力以内的事情，不可以越界。比如只允许你执行SELECT语句，那么你就不能执行UPDATE语句；只允许你从某台机器上连接MySQL，那么你就不能从除那台极其以外的其他机器上连接MySQL。\n在cmd上查看MySQL，中文会出现乱码的情况，我们需要在登录的时候写：\nmysql -u用户名 -p密码 --default-character-set=utf8\n\nMySQL到底都有哪些权限呢？\nshow privileges;\n\n\n\n\n权限\n含义和可授予级别\n\n\n\nALL [PRIVILEGES]\n授予除 GRANT OPTION 和 PROXY 之外的指定访问级别的所有权限。\n\n\nALTER\n启用修改表权限；Levels: Global, database, table.\n\n\nALTER ROUTINE\n允许更改或删除存储的例程(过程和函数)。. Levels: Global, database, routine.\n\n\nCREATE\n允许创建数据库和表. Levels: Global, database, table.\n\n\nCREATE ROLE\n允许创建角色. Level: Global.\n\n\nCREATE ROUTINE\n允许创建存储例程。 Levels: Global, database.\n\n\nCREATE TABLESPACE\n允许创建、更改或删除表空间和日志文件组。Level: Global.\n\n\nCREATE TEMPORARY TABLES\n允许使用CREATE TEMPORARY TABLE创建临时表。 Levels: Global, database.\n\n\nCREATE USER\n允许 CREATE USER, DROP USER, RENAME USERand REVOKE ALL PRIVILEGES. Level: Global.\n\n\nCREATE VIEW\n允许创建和修改视图. Levels: Global, database, table.\n\n\nDELETE\n允许使用 DELETE. Level: Global, database, table.\n\n\nDROP\n允许删除数据库、表和视图。 Levels: Global, database, table.\n\n\nDROP ROLE\n允许删除角色。Level: Global.\n\n\nEVENT\n为 Event Scheduler 启用事件。Levels: Global, database.\n\n\nEXECUTE\n允许用户执行存储的例程。 Levels: Global, database, routine.\n\n\nFILE\n允许用户通过服务器读取或写入文件. Level: Global.\n\n\nGRANT OPTION\n允许向其他帐户授予或删除权限。 Levels: Global, database, table, routine, proxy.\n\n\nINDEX\n允许创建或删除索引。。Levels: Global, database, table.\n\n\nINSERT\n允许使用 INSERT. Levels: Global, database, table, column.\n\n\nLOCK TABLES\n允许在拥有 SELECT 权限的表上启用 LOCK TABLES。。Levels: Global, database.\n\n\nPROCESS\n允许用户使用SHOW PROCESSLIST查看所有进程。Level: Global.\n\n\nPROXY\n允许使用代理。 Level: From user to user.\n\n\nREFERENCES\n允许创建外键。 Levels: Global, database, table, column.\n\n\nRELOAD\n允许 FLUSH 操作. Level: Global.\n\n\nREPLICATION CLIENT\n使用户能够询问源或副本服务器在哪里。 Level: Global.\n\n\nREPLICATION SLAVE\n使副本能够从源读取二进制日志事件。Level: Global.\n\n\nSELECT\n允许使用 SELECT. Levels: Global, database, table, column.\n\n\nSHOW DATABASES\n允许 SHOW DATABASES 显示所有数据库. Level: Global.\n\n\nSHOW VIEW\n允许使用 SHOW CREATE VIEW. Levels: Global, database, table.\n\n\nSHUTDOWN\n允许使用 mysqladmin shutdown. Level: Global.\n\n\nSUPER\n启用其他管理操作，例如 CHANGE REPLICATION SOURCE TO, CHANGE MASTER TO, KILL, PURGE BINARY LOGS, SET GLOBAL, and mysqladmin debug command. Level: Global.\n\n\nTRIGGER\n启用触发器操作. Levels: Global, database, table.\n\n\nUPDATE\n允许使用 UPDATE. Levels: Global, database, table, column.\n\n\nUSAGE\n和 “no privileges”一样，意为没有权限\n\n\n（1） CREATE和DROP权限 ，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。  \n（2） SELECT、INSERT、UPDATE和DELETE权限 允许在一个数据库现有的表上实施操作。\n（3） SELECT权限只有在它们真正从一个表中检索行时才被用到。\n（4） INDEX权限 允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。\n （5） ALTER权限 可以使用ALTER TABLE来更改表的结构和重新命名表。\n（6） CREATE ROUTINE权限 用来创建保存的程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序， EXECUTE权限 用来执行保存的程序。\n （7） GRANT权限 允许授权给其他用户，可用于数据库、表和保存的程序。\n （8） FILE权限 使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务  器可以访问这些文件）。\n授予权限的原则：\n权限控制主要是出于安全因素，因此需要遵循以下几个 经验原则 ：\n1、只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。\n2、创建用户的时候限制用户的登录主机 ，一般是限制成指定IP或者内网IP段。\n3、为每个用户设置满足密码复杂度的密码。\n4、 定期清理不需要的用户 ，回收权限或者删除用户。\n授予权限：\n给用户授权的方式有 2 种，分别是通过把角色赋予用户给用户授权和直接给用户授权。用户是数据库的使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。\n授权命令：\nGRANT priv_type[,priv_type1...] ON databasename.tablename TO username@hostname;\n\n范例：\n\n给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。\nGRANT SELECT,INSERT,DELETE,UPDATE ON test.* TO &#x27;maye&#x27;@&#x27;localhost&#x27;;\n\n授予通过网络方式登录的tom用户  ，对所有库所有表的全部权限。注意这里唯独不包括grant的权限\nGRANT ALL PRIVILEGES ON *.* TO &#x27;tom&#x27;@&#x27;%&#x27;;\n\n\nALL PRIVILEGES 是表示所有权限，你也可以使用SELECET、UPDATE等权限。\nON用来指定权限针对哪些数据库和表\n*.* 前面的*用来指定数据库名，后面的*用来指定表名；在这里表示所有数据库的所有表\nTO表示将权限赋予某个用户。\nmaye@’localhost’表示maye用户，@后面接限制的主机，可以是IP、IP段、域名以及%\n\n\n如果需要赋予包括GRANT的权限，添加参数WITH GRANT OPTION选项即可，表示该用户可以将自己拥有的权限授予给别人。经常有人在创建操作用户的时候不指定WITH GRANT OPTION选项导致后来该用户不能使用GRANT命令创建用户或者给其他用户授权。\n\n\n MySQL 的 权限，分别可以作用在多个层次上\n\n所有库的所有表\n单库下的所有表（最常用的授权级别）\n单表下的所有列\n单列权限：企业里称单列授权为 脱敏，即脱离敏感信息，涉及到敏感信息一定要脱敏\n例如：\n授予vip账号对某一表下所有列的查询权限\n而授予非vip账号对某一表下的某一列的查询权限\n\n\n针对存储过程的权限\n针对函数的权限\n\n#（1）针对所有库的所有表：*.* grant select on *.* to maye@&#x27;localhost&#x27;; #（2）针对某一数据库：test.*grant select on test.* to maye@&#x27;localhost&#x27;; #（3）针对某一个表：test.t1grant select on db1.t1 to maye@&#x27;localhost&#x27;;  #（4）针对某一个字段：grant select(empno,ename,job),update (comm) on test.emp to maye@&#x27;localhost&#x27;; #（5）作用在存储过程上：DELIMITER //CREATE PROCEDURE pro_show()BEGINSELECT * FROM test.emp;END //show procedure status; -- 查看到db1下有一个名为p1的存储过程 grant execute on procedure test.emp to maye@&#x27;localhost&#x27;;#（6）作用在函数上：delimiter //create function f1(i1 int,i2 int)returns intBEGIN    declare num int;    set num = i1 + i2;    return(num);END //delimiter ;show function status; -- 查看到db1下有一个名为f1的函数grant execute on function test.f1 to maye@&#x27;localhost&#x27;;\n\n\n我们在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的  分组。\n所谓横向的分组，就是指用户可以接触到的数据的范围，比如可以看到哪些表的数据；\n所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是 删除。\n\n查看权限：\n\n查看当前用户权限\n\nSHOW GRANTS;#orSHOW GRANTS FOR CURRENT_USER;#orSHOW GRANTS FOR CURRENT_USER();\n\n\n查看某用户的全局权限（root用户）\n\nSHOW GRANTS FOR &#x27;user&#x27;@&#x27;hostname&#x27;;\n\n收回权限收回权限就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全  性。MySQL中使用 REVOKE语句取消用户的某些权限。使用REVOKE收回权限之后，用户账户的记录将从db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中   的账户记录使用DROP USER语句）。\n注意：在将用户账户从use表删除之前，应该收回相应用户的所有权限。\n\n收回权限语法\n\nREVOKE  priv_type[,priv_type1...] ON databasename.tablename FROM &#x27;username&#x27;@&#x27;hostname&#x27;;\n\n范例：\n#收回指定用户的全库全表的所有权限REVOKE ALL PRIVILEGES ON *.* FROM &#x27;tom&#x27;@&#x27;%&#x27;;#收回指定用户mysql库下的所有表的增删改查权限REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM &#x27;tom&#x27;@&#x27;localhost&#x27;;\n\n用户重启登录后才生效。\n权限表MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库中。MySQL数据库系统会根据这些权限表的内容为每个用户授予相应的权限。这些权限表中最重要的是user表、db表。除此之外，还有table_priv表、column_priv表和proc_priv表等。在MySQL启动时，服务器将这些数据库表中权限信息的内容读入内存。\n\n\n\n表名\n描述\n\n\n\nuser\n用户账号及权限信息\n\n\nglobal_grants\n动态全局授权\n\n\ndb\n数据库层级的权限\n\n\ntables_priv\n表层级的权限\n\n\ncolumns_priv\n列层级的权限\n\n\nuser表user表是MySQL中最重要的一个权限表， 记录用户账号和权限信息 。需要注意的是，在 user 表里启用的所有权限都是全局级的，适用于所有数据库。\nuser表中的字段可以分成4类，分别是用户列、权限列、安全列和资源控制列。\n用户列用户列存储了用户连接 MySQL 数据库时需要输入的信息。需要注意的是 MySQL 5.7 版本不再使用 Password 来作为密码的字段，而改成了 authentication_string。\n\n\n\n字段\n类型\n是否为Null\n默认值\n说明\n\n\n\nHost\nchar(255)\nNO\n\n主机名\n\n\nUser\nchar(32)\nNO\n\n用户名\n\n\nauthentication_string\ntext\nYES\nNULL\n密码\n\n\n权限列权限列的字段决定了用户的权限，用来描述在全局范围内允许对数据和数据库进行的操作。\n权限大致分为两大类，分别是高级管理权限和普通权限：\n\n高级管理权限主要对数据库进行管理，例如关闭服务的权限、超级权限和加载用户等；\n普通权限主要操作数据库，例如查询权限、修改权限等。\n\nuser 表的权限列包括 Select_priv、Insert_ priv 等以 priv 结尾的字段，这些字段值的数据类型为 ENUM，可取的值只有 Y 和 N：Y 表示该用户有对应的权限，N 表示该用户没有对应的权限。从安全角度考虑，这些字段的默认值都为 N。\n\n\n\n字段\n类型\n是否为Null\n默认值\n\n\n\n\nSelect_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以通过SELECT 命令查询数据\n\n\nInsert_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以通过 INSERT 命令插入数据\n\n\nUpdate_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以通过UPDATE 命令修改现有数据\n\n\nDelete_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以通过DELETE 命令删除现有数据\n\n\nCreate_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以创建新的数据库和表\n\n\nDrop_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以删除现有数据库和表\n\n\nReload_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以执行刷新和重新加载MySQL所用的各种内部缓存的特定命令，包括日志、权限、主机、查询和表\n\n\nShutdown_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以关闭MySQL服务器。将此权限提供给root账户之外的任何用户时，都应当非常谨慎\n\n\nProcess_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以通过SHOW PROCESSLIST命令查看其他用户的进程\n\n\nFile_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以执行SELECT INTO OUTFILE和LOAD DATA INFILE命令\n\n\nGrant_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以将自己的权限再授予其他用户\n\n\nReferences_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以创建外键约束\n\n\nIndex_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以对索引进行增删查\n\n\nAlter_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以重命名和修改表结构\n\n\nShow_db_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以查看服务器上所有数据库的名字，包括用户拥有足够访问权限的数据库\n\n\nSuper_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以执行某些强大的管理功能，例如通过KILL命令删除用户进程；使用SET GLOBAL命令修改全局MySQL变量，执行关于复制和日志的各种命令。（超级权限）\n\n\nCreate_tmp_table_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以创建临时表\n\n\nLock_tables_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以使用LOCK TABLES命令阻止对表的访问&#x2F;修改\n\n\nExecute_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以执行存储过程\n\n\nRepl_slave_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以读取用于维护复制数据库环境的二进制日志文件\n\n\nRepl_client_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以确定复制从服务器和主服务器的位置\n\n\nCreate_view_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以创建视图\n\n\nShow_view_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以查看视图\n\n\nCreate_routine_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以更改或放弃存储过程和函数\n\n\nAlter_routine_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以修改或删除存储函数及函数\n\n\nCreate_user_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以执行CREATE USER命令，这个命令用于创建新的MySQL账户\n\n\nEvent_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以创建、修改和删除事件\n\n\nTrigger_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以创建和删除触发器\n\n\nCreate_tablespace_priv\nenum(‘N’,’Y’)\nNO\nN\n是否可以创建表空间\n\n\n安全列安全列主要用来判断用户是否能够登录成功。\n\n\n\n字段\n类型\n是否为Null\n默认值\n说明\n\n\n\nssl_type\nenum(‘’,’ANY’,’X509’,’SPECIFIED’)\nNO\n\n支持ssl标准加密安全字段\n\n\nssl_cipher\nblob\nNO\nNULL\n支持ssl标准安全字段\n\n\nx509_issuer\nblob\nNO\nNULL\n支持x509字段\n\n\nx509_subject\nblob\nNO\nNULL\n支持x509字段\n\n\nplugin\nchar(64)\nNO\ncaching_sha2_password\n引入plugins以进行用户连接时的密码验证，plugin创建外部&#x2F;代理用户\n\n\npassword_expired\nenum(‘N’,’Y’)\nNO\nN\n密码是否过期\n\n\npassword_last_changed\ntimestamp\nYES\nNULL\n记录密码最近修改时间\n\n\npassword_lifetime\nsmallint unsigned\nYES\nNULL\n设计密码的有效时间，单位为天数\n\n\naccount_locked\nenum(‘N’,’Y’)\nNO\nN\n用户是否被锁定\n\n\n\n注意：即使 password_expired 为“Y”，用户也可以使用密码登录 MySQL，但是不允许做任何操作。\n\n通常标准的发行版不支持 ssl，可以使用 SHOW VARIABLES LIKE “have_openssl” 语句来查看是否具有 ssl 功能。如果 have_openssl 的值为 DISABLED，那么则不支持 ssl 加密功能。\n资源控制列资源控制列的字段用来限制用户使用的资源 ，包含4个字段，分别为：\n\n\n\n字段名\n字段类型\n是否为空\n默认值\n说明\n\n\n\nmax_questions\nint(11) unsigned\nNO\n0\n规定每小时允许执行查询的操作次数\n\n\nmax_updates\nint(11) unsigned\nNO\n0\n规定每小时允许执行更新的操作次数\n\n\nmax_connections\nint(11) unsigned\nNO\n0\n规定每小时允许执行的连接操作次数\n\n\nmax_user_connections\nint(11) unsigned\nNO\n0\n规定允许同时建立的连接次数\n\n\ndb表db 表比较常用，是 MySQL 数据库中非常重要的权限表，表中存储了用户对某个数据库的操作权限。表中的字段大致可以分为两类，分别是用户列和权限列。\n用户列db 表用户列有 3 个字段，分别是 Host、User、Db，标识从某个主机连接某个用户对某个数据库的操作权限，这 3 个字段的组合构成了 db 表的主键。\n\n\n\n字段名\n字段类型\n为空\n默认值\n说明\n\n\n\nHost\nchar(60)\nNO\n无\n主机名\n\n\nDb\nchar(64)\nNO\n无\n数据库名\n\n\nUser\nchar(32)\nNO\n无\n用户名\n\n\n权限列db 表中的权限列和 user 表中的权限列大致相同，只是user 表中的权限是针对所有数据库的，而 db 表中的权限只针对指定的数据库。如果希望用户只对某个数据库有操作权限，可以先将 user 表中对应的权限设置为 N，然后在 db 表中设置对应数据库的操作权限。\ntables_priv表和columns_priv表tables_priv 表用来对单个表进行权限设置，columns_priv 表用来对单个数据列进行权限设置。\ntables_priv 表结构如下表：\n\n\n\n字段名\n字段类型\n为空\n默认值\n说明\n\n\n\nHost\nchar(60)\nNO\n无\n主机\n\n\nDb\nchar(64)\nNO\n无\n数据库名\n\n\nUser\nchar(32)\nNO\n无\n用户名\n\n\nTable_name\nchar(64)\nNO\n无\n表名\n\n\nGrantor\nchar(93)\nNO\n无\n修改该记录的用户\n\n\nTimestamp\ntimestamp\nNO\nCURRENT_TIMESTAMP\n修改该记录的时间\n\n\nTable_priv\nset(‘Select’,’Insert’,’Update’,’Delete’,’ Create’,’Drop’,’Grant’,’References’, ‘Index’,’Alter’,’Create View’,’Show view’,’Trigger’)\nNO\n无\n表示对表的操作权限，包括 Select、Insert、Update、Delete、Create、Drop、Grant、References、Index 和 Alter 等\n\n\nColumn_priv\nset(‘Select’,’Insert’,’Update’,’References’)\nNO\n无\n表示对表中的列的操作权限，包括 Select、Insert、Update 和 References\n\n\ncolumns_priv表的结构:\n\n\n\n字段名\n字段类型\n为空\n默认值\n说明\n\n\n\nHost\nchar(60)\nNO\n无\n主机\n\n\nDb\nchar(64)\nNO\n无\n数据库名\n\n\nUser\nchar(32)\nNO\n无\n用户名\n\n\nTable_name\nchar(64)\nNO\n无\n表名\n\n\nColumn_name\nchar(64)\nNO\n无\n数据列名称，用来指定对哪些数据列具有操作权限\n\n\nTimestamp\ntimestamp\nNO\nCURRENT_TIMESTAMP\n修改该记录的时间\n\n\nColumn_priv\nset(‘Select’,’Insert’,’Update’,’References’)\nNO\n无\n表示对表中的列的操作权限，包括 Select、Insert、Update 和 References\n\n\nprocs_priv表procs_priv表可以对 存储过程和存储函数设置操作权限 ，表结构如下表：\n\n\n\n字段名\n字段类型\n为空\n默认值\n说明\n\n\n\nHost\nchar(60)\nNO\n无\n主机名\n\n\nDb\nchar(64)\nNO\n无\n数据库名\n\n\nUser\nchar(32)\nNO\n无\n用户名\n\n\nRoutine_name\nchar(64)\nNO\n无\n表示存储过程或函数的名称\n\n\nRoutine_type\nenum(‘FUNCTION’,’PROCEDURE’)\nNO\n无\n表示存储过程或函数的类型，Routine_type 字段有两个值，分别是 FUNCTION 和 PROCEDURE。FUNCTION 表示这是一个函数；PROCEDURE 表示这是一个 存储过程。\n\n\nGrantor\nchar(93)\nNO\n无\n插入或修改该记录的用户\n\n\nProc_priv\nset(‘Execute’,’Alter Routine’,’Grant’)\nNO\n无\n表示拥有的权限，包括 Execute、Alter Routine、Grant 3种\n\n\nTimestamp\ntimestamp\nNO\nCURRENT_TIMESTAMP\n表示记录更新时间\n\n\n访问控制（了解一下）正常情况下，并不希望每个用户都可以指向所有的数据库权限。当MySQL允许一个用户执行各种操作时，它首先核实该用户向MySQL服务器发送的连接请求，然后确认用户的操作请求是否被允许。这个过程称为MySQL中的访问控制过程。MySQL的访问控制分为两个阶段：连接核实阶段和请求核实阶段。\n连接核实阶段当用户试图连接MySQL服务器时，服务器基于用户的身份以及用户是否能提供正确的密码验证身份来确定接受或者拒绝连接。即客户端用户会在连接请求中提供用户名、主机地址、用户密码，MySQL服务器  接收到用户请求后，会使用user表中的host、user和authentication_string这3个字段匹配客户端提供信息。\n服务器只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接。如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入阶段2等待用户请求。\n请求核实阶段一旦建立了连接，服务器就进入了访问控制的阶段2，也就是请求核实阶段。对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自user、db、table_priv和column_priv表。\n确认权限时，MySQL首先 检查user表 ，如果指定的权限没有在user表中被授予，那么MySQL就会继续\n查db表 ，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL继续 检查tables_priv表 以及 columns_priv表 ，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将 返回错误信息 ，用户请求的操作不能执行，操作失败。请求核实的过程如图所示:\n\n\n提示：  MySQL通过向下层级的顺序（从user表到columns_priv表）检查权限表，但并不是所有的权限都要执行该过程。例如，一个用户登录到MySQL服务器之后只执行对MySQL的管理操作，此时只  涉及管理权限，因此MySQL只检查user表。另外，如果请求的权限操作不被允许，MySQL也不会继  续检查下一层级的表。\n\n角色管理角色的理解角色是权限的集合，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且像用户账户一样，角色可以有用授予和撤销的权限。\n引入角色的目的是 方便管理拥有相同权限的用户 。恰当的权限设定，可以确保数据的安全性，这是至关重要的。\n\n创建角色创建角色使用 CREATE ROLE 语句，语法如下：\nCREATE ROLE &#x27;role_name&#x27;[@&#x27;host_name&#x27;];\n\n角色名称的命名规则和用户名类似。如果host_name省略，默认为%，role_name不可省略，不可为空。\n练习：我们现在需要创建一个经理的角色，就可以用下面的代码：\nCREATE ROLE &#x27;manager&#x27;@&#x27;localhost&#x27;;\n\n给角色赋予权限创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是：\nGRANT priv_type[,priv_type1...] ON table_name TO &#x27;role_name&#x27;[@&#x27;host_name&#x27;];\n\n上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称.\nSHOW PRIVILEGES;\n\n**范例：**我们现在想给经理角色授予商品信息表、盘点表和应付账款表的只读权限，就可以用下面的代码来实现：\nGRANT SELECT ON demo.settlement TO &#x27;manager&#x27;; GRANT SELECT ON demo.goodsmaster TO &#x27;manager&#x27;;GRANT SELECT ON demo.invcount TO &#x27;manager&#x27;;\n\n查看角色的权限赋予角色权限之后，我们可以通过SHOW GRANTS语句来查看权限是否创建成功了:\nmysql&gt; SHOW GRANTS FOR &#x27;manager&#x27;;+-------------------------------------------------------+| Grants for manager@% |+-------------------------------------------------------+| GRANT USAGE ON *.* TO `manager`@`%` || GRANT SELECT ON `demo`.`goodsmaster` TO `manager`@`%` || GRANT SELECT ON `demo`.`invcount` TO `manager`@`%` || GRANT SELECT ON `demo`.`settlement` TO `manager`@`%` |+-------------------------------------------------------+\n\n只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是连接登录数据库的权限 。代码的最后三行代表了我们给角色“manager”赋予的权限，也就是对商品信息表、盘点表和应付账款表的只读权限。\n结果显示，库管角色拥有商品信息表的只读权限和盘点表的增删改查权限。\n回收角色的权限角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色  授权相同。撤销角色或角色权限使用REVOKE语句。\n修改了角色的权限，会影响拥有该角色的账户的权限。\n撤销角色权限的SQL语法如下：\nREVOKE priv_type[,priv_type1...] ON table_name FROM &#x27;role_name&#x27;;\n\n练习1：撤销school_write角色的权限。\n（1）使用如下语句撤销school_write角色的权限。\nREVOKE INSERT,UPDATE,DELETE ON shool.* FROM &#x27;school_write&#x27;;\n\n（2） 撤销后使用SHOW语句查看school_write对应的权限，语句如下。\nSHOW GRANTS FOR &#x27;school_write&#x27;;\n\n删除角色当我们需要对业务重新整合的时候，可能就需要对之前创建的角色进行清理，删除一些不会再使用的角  色。删除角色的操作很简单，你只要掌握语法结构就行了。\nDROP ROLE role[,role1...];\n\n注意，如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限。\n练习：执行如下SQL删除角色school_read。\nDROP ROLE &#x27;school_read&#x27;;\n\n给用户赋予角色角色创建并授权后，要赋给用户并处于 激活状态 才能发挥作用。给用户添加角色可使用GRANT语句，语法形式如下：\n GRANT role[,role1...] TO user_or_role[,user_or_role];\n\n在上述语句中，role代表角色，user代表用户。可将多个角色同时赋予多个用户，用逗号隔开即可。\n练习：给kangshifu用户添加角色school_read权限。\n（1）使用GRANT语句给kangshifu添加school_read权限，SQL语句如下。\nGRANT &#x27;school_read&#x27; TO &#x27;maye&#x27;@&#x27;localhost&#x27;;\n\n（2） 添加完成后使用SHOW语句查看是否添加成功，SQL语句如下。\nSHOW GRANTS FOR &#x27;maye&#x27;@&#x27;localhost&#x27;;\n\n（3） 使用kangshifu用户登录，然后查询当前角色，如果角色未激活，结果将显示NONE。SQL语句如  下。\nSELECT CURRENT_ROLE();\n\n激活角色方式1：使用set default role 命令激活角色\nSET DEFAULT ROLE ALL TO &#x27;user_name&#x27;@&#x27;localhost&#x27;;\n\n**范例：**为用户激活所有拥有的角色：\nSET DEFAULT ROLE ALL TO &#x27;dev1&#x27;@&#x27;localhost&#x27;, &#x27;read_user1&#x27;@&#x27;localhost&#x27;, &#x27;read_user2&#x27;@&#x27;localhost&#x27;, &#x27;rw_user&#x27;@&#x27;localhost&#x27;;\n\n方式2：将activate_all_roles_on_login设置为ON默认情况：\nmysql&gt; show variables like &#x27;activate_all_roles_on_login&#x27;;+-----------------------------+-------+| Variable_name | Value |+-----------------------------+-------+| activate_all_roles_on_login | OFF |+-----------------------------+-------+1 row in set (0.00 sec)\n\n设置：\n SET GLOBAL activate_all_roles_on_login=ON;\n\n这条 SQL 语句的意思是，对所有角色永久激活 。运行这条语句之后，用户才真正拥有了赋予角色的所有权限。\n撤销用户的角色撤销用户角色的SQL语法如下：\nREVOKE role_name FROM user_name;\n\n **范例：**撤销maye用户的school_read角色。\n （1）撤销的SQL语句如下\nREVOKE &#x27;school_read&#x27; FROM &#x27;maye&#x27;@&#x27;localhost&#x27;;\n\n（2）撤销后，执行如下查询语句，查看maye用户的角色信息\nSHOW GRANTS FOR &#x27;maye&#x27;@&#x27;localhost&#x27;;\n\n执行发现，用户maye之前的school_read角色已被撤销。\n设置强制角色(mandatory role)方式1：服务启动前设置\n[mysqld]mandatory_roles=&#x27;role1,role2@localhost,role3@%.maye.com&#x27;\n\n方式2：运行时设置\nSET PERSIST mandatory_roles=&#x27;role1,role2@localhost,role3@%.maye.com&#x27;;#重启后依然有效SET GLOBAL mandatory_roles=&#x27;role1,role2@localhost,role3@%.maye.com&#x27;;#重启后失效\n\n事务数据库事务概述基本概念\n事务:一组逻辑操作单元，使数据从一种状态变换到另一种状态。\n事务处理的原则:保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来;要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。\nUPDATE account SET money = money - 50 WHERE name=&#x27;A&#x27;;#宕机了3UPDATE account SET money = money + 50 WHERE name=&#x27;B&#x27;;\n\n事务的状态\n我们现在知道事务是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把事务大致划分成几个状态:\n活动的(active)事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。\n部分提交的(partially committed)当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。\n失败的(failed)当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。\n中止的(aborted)如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。\n提交的(committed)当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。一个基本的状态转换图如下所示:\n\n事务的ACID特性\n原子性(atomicity)原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么转账成功，要么转账失败，是不存在中间状态的。如果不发保证原子性会怎么样?就会出现数据不一致的情形，A账户减去100元，而B账户增加100元操作失败，系统将无故丢失100元。\n一致性(consistency)根据定义，一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关。\n那什么是合法的数据状态呢?满足预定的约束的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的(比如满足现实世界中的约束)。满足这个状态，数据就是一致的，不满足这个状态，数据就。是不一致的!如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。\n\n列如: A账户有200元，转账300元出去，此时余额为-100。你自然就发现了此时数据是不一致的，为什么呢?因为你定义了一个状态，余额这列必须&gt;&#x3D;0.\n列如: A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额没有增加。你也知道此时数据是不一致的，为什么呢?因为你定义了一个状态，要求A+B的总余额必须不变。\n\n隔离型(isolation)事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n如果无法保证隔离性会怎么样?假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形:\nUPDATE accounts SET money = money - 50 WHERE name=&#x27;A&#x27;;UPDATE accountsSET money = money + 50 WHERE name=&#x27;B &#x27;;\n\n\n持久性(durability)持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。\n\n总结\nACID是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。\n数据库事务，其实就是数据库设计者为了方便起见，把需要保证原子性、隔高性、一致性和持久性的一个或多个数据操作称为一个事务。\n\n如何使用事务使用事务有两种方式，分别为显式事务和隐式事务。\n显式事务步骤1:START TRANSACTION或者BEGIN，作用是显式开启一个事务。\nmysq1&gt; BEGIN;#或者mysq1&gt; START TRANSACTION\n\nSTART TRANSACTION语句相较于BEGIN特别之处在于，后边能跟随几个修饰符:\n\nREAD ONLY:标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。\nREAD wRITE:标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。\nWITH CONSISTENT SNAPSHOT:启动一致性读。\n\n步骤2:一系列事务中的操作(主要是DML，不含DDL)\n步骤3:提交事务或中止事务(即回滚事务)\n#提交事务。当提交事务后，对数据库的修改是永久性的。mysq1&gt;COMMIT;\n\n#回滚事务。即撤销正在进行的所有没有提交的修改2 mysq1&gt;ROLLBACK;#将事务回滚到某个保存点。mysq1&gt; ROLLBACK [TO SAVEPOINT 名字]\n\n隐式事务MySQL中有一个系统变量autocommit :\nmysql&gt; SHOw VARIABLES LIKE &#x27;autocommit&#x27;;+---------------+-------+| variab1e_name | value |+-—----------———+-------+|autocommit     | ON    |+---------------+-------+1 row in set (0.01 sec)\n\n当然，如果我们想关闭这种自动提交的功能，可以使用下边两种方法之一:\n\n显式的的使用STARTTRANSACTION或者BEGIN语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。\n把系统变量autocommit的值设置为OFF ．就像这样:\n\nSET autocommit = OFF;#或SET autocommit = 0;\n\n例子：\nSELECT @@autocommit=FALSE;SELECT @@autocommit=TURE;#如果autocommit为false，则默认开启事务，每个sql语句，都需要自己提交或者回滚sql语句...COMMIT;#回滚ROLLBACK;\n\n隐式提交数据的情况\n数据定义语言(Data definition language，缩写为:DDL)\n\n隐式使用或修改mysql数据库中的表\n\n事务控制或关于锁定的语句\n\n当我们在一个事务还没提交或者回滚时就又使用STARTTRANSACTION或者BEGIN语句开启了另一个事务时，会隐式的提交上一个事务。即:\n当前的autocommit系统变量的值为OFF，我们手动把它调为ON时，也会隐式的提交前边语句所属的事务。\n使用LOCKTABLES、UNLOCK TABLES等关于锁定的语句也会隐式的提交前边语句所属的事务。\n\n\n加载数据得语句\n\n关于MySQL复制得一些语句\n\n其它得一些语句\n\n\n事务隔离级别MySQL是一个客户端&#x2F;服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话 ( Session )。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分,也就是对于服务器来说可能同时处理多个事务。事务有隔离性的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对性能影响太大，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，那就看二者如何权衡取舍了。\n数据并发问题1.脏写(Dirty Write )对于两个事务Session A、Session B，如果事务Session A修改了另一个未提交事务SessionB修改过的数据，那就意味着发生了脏写。\n\nSession A和session B各开启了一个事务，Session B中的事务先将sno列为1的记录的name列更新为李四，然后session A中的事务接着又把这条sno列为1的记录的name列更新为张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象就称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离级比较了解的话，会发现默认隔离级别下，上面SessionA中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样现象。\n2.脏读(Dirty Read )对于两个事务Session A、Session B，Session A读取了已经被Session B更新但还没有被提交的字段。之后若Session B回滚，Session A读取的内容就是临时且无效的。\nSession A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为张三’，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。\n3.不可重复读(Non-Repeatable Read )对于两个事务Session A、 Session B,Session A 读取)了一个字段，然后Session B更新了该字段。之后Session A再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。\n我们在Session B中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了)，这些事务都修改了sno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为不可重复读。\n4.幻读(Phantom )对于两个事务SessionA、Session B, Session A从一个表中读取了一个字段,然后SessionB在该表中插入了一些新的行。之后,如果SessionA再次诗取同一个表就会多出几行。那就意味着发生了幻读。\nSession A中的事务先根据条件studentno&gt;0这个条件查询表student，得到了name列值为张三’的记录;之后Session B中提交了一个隐式事务，该事务向表student中插入了一条新记录;之后Session A中的事务再根据相同的条件sno&gt;0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为幻读。我们把新插入的那些记录称之为幻影记录。\nSQL中的四种隔离级别上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序:\n\n脏写&gt;脏读&gt;不可重复读&gt;幻读\n\n我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在:设立一些隔离级别，隔离级别越低，并发问题发生的就越多。SQL标准中设立了4个隔离级别:\n\nREAD UNCOMITTED:读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。\n\nREAD COMMITTED:读已提交，它满足了隔离的简单定义:一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)。可以避免脏读，但不可重复读、幻读问题仍然存在。\n\nREPEATABLE READ:可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。\n\nSERIALLIZABLE:可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。\nSQL标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下:\n\n\n\n脏写怎么没涉及到?因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。\n不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下:\n\n查看MySQL当前的隔离级别MySQL的默认隔离级别为REPEATABLE READ，通过全局变量可以查看。\n#查看隔离级别,MySQL 5.7.20的版本之前:mysql&gt; SHOw VARIABLES LIKE &#x27;tx_isolation &#x27; ;+---------------+--—------------—-+| variab1e_name | value           |+---------------+-----------------+| tx_isolation | REPEATABLE-READ  |+---------------+-----------------+1 row in set (0.00 sec)# MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation #查看隔离级别，MySQL 5.7.20的版本及之后: mysq1&gt;SHOW VARIABLES LIKE &#x27;transaction_isolation &#x27;;+-----------------------+-----------------+| variable_name         | value           |+-----------------------+-----------------+| transaction_isolation | REPEATABLE-READ |+-----------------------+-----------------+1 row in set (0.02 sec)\n\n设置MySQL当前的隔离级别通过下面的语句修改事务的隔离级别:\nSET [GLOBALISESSION] TRANSACTION ISOLATION LEVEL隔离级别;#其中，隔离级别格式:&gt;READ UNCOMMITTED&gt;READ COMMITTED&gt;REPEATABLE READ&gt;SERIALIZABLE\n\n或者:\nSET [GLOBAL|SESSION] TRANSACTION_ISOLATION =&#x27;隔离级别&#x27;#其中,隔离级别格式:&gt;READ-UNCOMMITTED&gt;READ-COMMITTED&gt;REPEATABLE-READ&gt;SERIALIZABLE\n\n关于设置时使用GLOBAL或SESSION的影响:\n\n使用GLOBAL关键字(在全局范围影响):\n\nSET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;#或SET GLOBAL TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;\n\n则：当前已经存在的会话无效只对执行完该语句之后产生的会话起作用\n\n使用SESSION关键字(在会话范围影响):\n\nSET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;#或SET SESSION TRANSACTION_ISOLATION =&#x27;SERIALIZABLE&#x27;;\n\n则：对当前会话的所有后续的事务有效如果在事务之间执行，则对后续的事务有效该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务\n小结:数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。\n数据库备份与恢复在任何数据环境下，总会有不确定的以外发生，为了有效的防止数据丢失，并将损失降到最小，应定期对MySQL数据库服务器做备份。如果数据库中的数据丢失或者出现错误，可以使用备份的数据进行恢复。主从服务器之间的数据同步问题可以通过复制功能实现。\n物理备份与逻辑备份物理备份：备份数据文件，转存数据库物理文件到某一目录。物理备份速度比较块，但占用空间比较大，MySQL中可以用xtrabackup工具进行物理备份。\n逻辑备份：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但是占用空间小，更灵活。MySQL中常用的逻辑备份工作mysqldump。逻辑备份就是备份sql语句，在恢复的时候执行备份的sql语句实现数据库数据的重现。\nmysqldump命令实现逻辑备份备份一个数据库\n基本语法：\nmysqldump -u 用户名 -h 主机名称 -p 密码 [tbname,[tbname...]]&gt; 备份文件名称.sql #备份名可以写出存储到的位置 \n\n\n说明：备份的文件并非一定要求后缀为.sql，例如后缀名为.txt的文件也是可以的。\n\n备份全部数据库\n若想用mysqldump备份整个实例，可以使用–all-database或-A参数基本语法：\nmysqldump -u 用户名 -p 密码 --all-database &gt; 备份文件名称.sql mysqldump -u 用户名 -p 密码 -A &gt; 备份文件名称.sql \n\n备份部分数据库\n若想用mysqldump备份部分实例，可以使用–database或-B参数，指定database备份中会存在创建数据库的语句，如果不指定参数，则不存在。基本语法：\nmysqldump -u 用户名 -p 密码 --database [数据库名1 [数据库2...]]  &gt; 备份文件名称.sql \n\n备份部分表比如在表更变前做个备份语法：\nmysqldump -u 用户名 -p 密码 数据库的名称 [表1 [表2...]] &gt; 备份文件名称.sql \n\n备份单表的部分数据有时候表数据很大，我们只需要部分数据，这时候就可以使用–where选项了。where后面附带带需求要满足的条件语法：\nmysqldump -u 用户名 -p 密码 数据库的名称 表名 --where=&quot;条件&quot; &gt; 备份文件名称.sql \n\n只备份结构或只备份数据\n只备份结构的话使用–on-data选项（简写为-d）只备份数据的话使用–no-create-info选项（简写为-t）语法：\nmysqldump -u 用户名 -p 密码 数据库的名称 --no-data &gt; 备份文件名称.sql mysqldump -u 用户名 -p 密码 数据库的名称 --no-create-info &gt; 备份文件名称.sql \n\n备份中包含存储过程、函数、事件\nmysqldump备份默认是不包含存储过程，自定义函数及事件的。可以使用–routines或-R选项来备份存储过程及函数，使用–events或-E选项来备份事件。\n查看当前库有哪些存储过程或者函数：\nmysql&gt; SELECT SPECIFIC_NAME,ROUTINE_TYPE,ROUTINE_SCHEMA FROM information_schema.Routines WHERE ROUTINE_SCHEMA=&quot;库名&quot;;\n\n备份数据库数据，函数，以及存储过程：\nmysqldump -u 用户名 -p 密码 -R -E --database 数据库的名称 &gt; 备份文件名称.sql \n\n排除某些表的备份\n如果我们想备份某个库，但是某些表数据很大或者业务关联不大，这个时候可以考虑排除掉这些表，同样的，选项–ignore-table 可以完成这个功能。\nmysqldump -u用户名 -p 密码   数据库的名称 --ignore-table=数据库名.表名 &gt; 备份文件名称.sql \n\nMySQL命令恢复数据基本语法：\nmysql -u用户名 -p 密码   [dbname] &lt; 备份文件名称.sql #如果备份中有建立数据库的语句就可以不用建立数据库，如果没有需要自己先建立数据库\n\n表的导出使用SELECT…INTO OUTFILE导出文本文件（不会导出表头）\n1.选择数据库，并查询表\nuse 库名select * from 表名 ;\n\n2.导出emp表到指定的目录\nSELECT *FROM 数据库.表名 INTO OUTFILE &#x27;位置/名字.txt&#x27;;SELECT *FROM 数据库.表名 INTO OUTFILE &#x27;位置/名字.csv&#x27; FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\\&quot;&#x27;;\n\n在使用INTO OUTFILE这个语句的时候会出现错误\n错误原因是：变量secure_file_priv的选值不对\n变量secure_file_priv可选值和作用：\n\n如果设置为empty，表示不限制文本生成的位置，这是不安全的；\n如果设置为一个标识路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；\n如果设置为null，就表明进制在这个MySQL实例上执行INTO OUTFILE操作。\n\n**注意：**这个变量是只读变量，不能通过SQL语句修改，只能修改my.ini配置文件，然后重启服务器（变量放到mysqld组中）\n...[mysqld]secure_file_priv=...\n\n使用mysqldump命令导出文本文件\n不会导出表头，只有表数据\n\n举例：使用mysqldump命令将test数据库中emp表中的记录导出到文本文件和sql文件（只包含创建表的语句）\n#注意：结尾不能加分号mysqldump -uroot -p -T &quot;c:/Users&quot; test emp\n\n执行完会生成txt文件（数据）和sql文件（结构）\n举例2∶使用mysqldump将test数据库中的emp表导出到文本文件，使用FIELDS选项，要求字段之间使用逗号,)间隔，字符串类型字段值用双引号括起来:\n1 mysqldump -uroot -p -T &quot;c:/Users/Maye/backup&quot; test emp --fields-terminated-by=，--fields-optional1y-enclosed-by=\\ &quot;\n\n打开account.txt文件，其内容包含创建account表的数据。从文件中可以看出，字段之间用逗号隔开，字符类型的值被双引号括起来.\n1 7369, &quot;SMITH&quot; , &quot;CLERK&quot;,7902, &quot;1980-12-17&quot;, 800, \\N, 20...\n\n使用mysql命令导出文本文件举例1:使用mysql语句导出test数据中emp表中的记录到文本文件(会同时导出表头);\n1 mysq1-uroot -p --execute=&quot;SELECT * FROM emp;&quot; test&gt; &quot;c:/users/Maye/backup/emp_1.txt&quot;\n\n举例2:将test数据库emp表中的记录导出到文本文件，使用–veritcal参数将该条件记录分为多行显示:\n1 mysq1 -uroot -p --vertical --execute=&quot;SELECT * FROM emp;&quot; test &gt; &quot;c:/Users/Maye/backup/emp_11.txt&quot;\n\n举例3:将test数据库emp表中的记录导出到xml，使用–xml参数将该条件记录分为多行显示:\n1 mysq1 -uroot -p --xml --execute=&quot;SELECT * FROM emp;&quot; test &gt; &quot;c:/Users/Maye/backup/emp_11.txt&quot;导出html文件就是使用 --html参数\n\n表的导入1.使用LOAD DATA INFILE方式导入文本文件\n举例1:使用SELECT…INTO OUTFILE将test数据库中emp表的记录导出到文本文件\nSELECT * FROM test.emp INTO OUTFILE &#x27;C:/users/Maye/backup/emp_2.txt &#x27; ;\n\n删除account表中的数据:\nDELETE FROM test.emp;\n\n从文本文件account.txt中恢复数据:\nLOAD DATA INFILE &#x27;C:/Users/Maye/backup/emp_2.txt&#x27;INTO TABLE test.emp;\n\n举例2∶选择数据库test，使用SELECT….NTO OUTFILE将test数据库emp表中的记录导出到文本文件，使用FIELDS选项和LINES选项，要求字段之间使用逗号”，”间隔，所有字段值用双引号括起来:\n1 SELECT * FROM test.emp INTO OUTFILE &#x27;C:/Users/Maye/backup/emp_2.csV&#x27;FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\\&quot;&#x27;;\n\n删除account表中的数据:\nDELETE FROM test.emp;\n\n从’c:&#x2F;users&#x2F;Maye&#x2F;backup&#x2F;emp_2.csv’中导入数据到account表中:\nLOAD DATA INFILE &#x27;c:/Users/Maye/backup/emp_2.csv&#x27;INTO TABLE test.emp FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\\&quot;&#x27;;\n\n2.使用mysqlimport方式导入文本文件\n\n文件名必须是表名\n\n举例:导出文件emp.txt，字段之间使用逗号”,”间隔，字符串字段值用双引号括起来:\n1 SELECT* FROMtest.emp INTO OUTFILE &#x27;C:/Users/Naye/backup/emp_3.csv&#x27;FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\\&quot;&#x27;;\n\n删除emp表中的数据:\nDELETE FROM test.emp;\n\n使用mysqlimport命令将emp.txt文件内容导入到数据库test的emp表中:\nmysq1import -uroot -p --local test “c:/users/Maye/backup/emp_3.csv”--fields-terminated-by=，--fields-optiona1ly-enclosed-by=\\&quot;\n\n当出现问题的时候，上图有解决。\nc&#x2F;c++操作数据库首先需要初始化mysql\n//两种方式初始化//1.MYSQL *mysql=mysql_init(NULL);//2.MYSQL mysql;mysql_init(&amp;mysql);\n\n有初始化，就会有关闭mysql：\nmysql_close(mysql);\n\n在初始化和关闭数据库中间就可以使用数据库了\n首先需要连接数据库：\n//连接数据库mysql_real_connect()//-&gt;一般后面的两个参数填0或者NULL//一般会确保是否连接上数据库了，所以:if(!mysql_real_connect())&#123;  cout&lt;&lt;mysql_error(mysql);&#125;else&#123;  cout&lt;&lt;&quot;连接数据库成功&quot;;&#125;\n\n设置连接超时的时间\nint time=3;mysql_options();//参数查文档\n\n在运行的时候可能会与数据库断开连接，如果想让他重连：\nbool re=true;mysql_options();//参数查文档-&gt;第二个参数是MYSQL_OPT_RECONNECT\n\n注意 mysql_options()函数在mysql_init之后，在mysql_real_connect之前！\n在使用中可以用mysql_ping函数来测试是否与数据库连接！\n执行SQL语句：\nconst char* sql=&quot;SQL语句&quot;;//SQL语句不用加;mysql_query();//执行数据库mysql_real_query();//这个比较安全\n\n获取执行完的SQL语句：\nMYSQL_RES* res=mysql_store_result();//会把结果集保存到本机MYSQL_RES* res=mysql_use_result();//不会把结果保存起来，而是一条一条的从服务器中读取\n\n无论是哪种获取，在用完之后都必须释放掉：\nmysql_free_result();//释放掉的是MYSQL_RES数据类型的//一定会释放成功的，没有返回类型 \n\n获得字段数量（就是列数）和获得每行记录，并输出：\n\n输出后发现汉字编码是错误的，所以在开始还需要配置一下\n\n//配置编码mysql_options()//-&gt;第二个参数是MYSQL_INIT_COMMAND -&gt;第三个参数是&quot;SET NAMES GBK&quot;-&gt;这是因为咱们电脑编码是GBK，也可以设置为其他编码\n\n\n//获得字段数unsigned int fi=mysql_field_count(mysql);//获得每条记录 MYSQL_ROW就是char**MYSQL_ROW row=NULL;while(row=mysql_fetch_row(res))&#123;    //遍历    for(int i=0;i&lt;fi;i++)    &#123;      //cout&lt;&lt;row[i]&lt;&lt;&quot;  &quot;;//当没有数据的时候输出的是（null）      //为了改变，而且也安全所以可以改为：      cout&lt;&lt;row[i]?row[i]:&quot;NULL&quot;&lt;&lt;&quot;  &quot;;    &#125;    cout&lt;&lt;endl;&#125;\n\n获取字段不仅仅可以在MYSQL类型的变量中获取，也可以在MYSQL_RES类型中获取：\nunsigned int fi = 0;fi=mysql_num_fields(res);\n\n获取记录的条数：\nuint64_t rowC=mysql_num_rows(res);\n\n获取每一个字段,并输出方法1：&#x2F;&#x2F;一个字段一个字段的抓取\nMYSQL_FIELD *fie=NULL;while(fie=mysql_fetch_field(res))&#123;   cout&lt;&lt;fie-&gt;name;&#125;\n\n获取每一个字段,并输出方法2：&#x2F;&#x2F;把所有的字段先抓取出来\nMYSQL_FIELD *fie=NULL;fie=mysql_fetch_fields(res);if(fie)&#123;  for(int i=0;i&lt;fi;i++)  &#123;     cout&lt;&lt;fie[i].name;  &#125;&#125;\n\n\n使用这个方法有个好处就是，可以返回所有数据中最长的长度：fie[i].max_length。用printf(“%-*s”,fie[i].max_length+1,fie[i].name);显示就很舒服\n\n获取每一个字段,并输出方法3：&#x2F;&#x2F;使用mysql_fetch_field_direct()\nfor(int i=0;i&lt;fi;i++)&#123;  //如果有需要可以存起来，再输出   cout&lt;&lt;mysql_fetch_field_direct(res,i)-&gt;name;&#125;\n\n当我们需要执行多条SQL语句时，需要把mysql_real_connect()的最后一个参数改写为CLIENT_MULTI_STATEMENTS-&gt;意思是支持客服端多条代码段\n虽然改完了但是输出的时候还是只输出一个字段，这个时候可以使用do while循环语句，循环条件是：mysql_next_result(mysql)-&gt;当没有语句执行后自动跳出\n当执行的语句中不是结果集的语句，比如insert update等，可以输出他影响的行数，用函数：mysql_affected_rows()。\n样例：\n#include&lt;iostream&gt;#include&lt;mysql.h&gt;using namespace std;int main()&#123; //初始化MySQL MYSQL* mysql = mysql_init(NULL); //设置字符集 mysql_options(mysql, MYSQL_INIT_COMMAND, &quot;SET NAMES GBK&quot;); //设置自动重连 bool is = true; mysql_options(mysql, MYSQL_OPT_RECONNECT,&amp;is); //连接服务器 if (!mysql_real_connect(mysql, &quot;localhost&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;ddl&quot;, 3306, 0, CLIENT_MULTI_STATEMENTS)) &#123;   cout &lt;&lt; mysql_error(mysql)&lt;&lt;endl; &#125;  else  &#123;    cout &lt;&lt; &quot;连接成功\\n&quot;;  &#125; //断开连接后重连 while(mysql_ping(mysql)) &#123;   cout &lt;&lt; &quot;连接中&quot; &lt;&lt; endl; &#125; //获得数据  //执行SQL语句  //SQL语句不用加;,但是执行多条代码段的时候，两两语句中间需要;  const char* sql = &quot;SELECT * FROM student;SELECT * FROM teaches&quot;;  //执行数据库  if (0 != mysql_query(mysql, sql))  &#123;    cout &lt;&lt; &quot;mysql_query:&quot; &lt;&lt; mysql_error(mysql);    return -1;  &#125;  do  &#123;    //把结果保存本机    MYSQL_RES* res = mysql_store_result(mysql);    if (!res)    &#123;           cout &lt;&lt; &quot;mysql_store_result:&quot; &lt;&lt; mysql_error(mysql);      return -1;    &#125;    //返回字段有多少    unsigned int fi = 0;    fi = mysql_field_count(mysql);    //cout &lt;&lt; fi &lt;&lt; endl;    //显示要输出多少数据    uint64_t it = mysql_num_rows(res);    cout &lt;&lt; it &lt;&lt; endl;    //显示字段    MYSQL_FIELD* fie = mysql_fetch_fields(res);    if (fie)    &#123;      for (int i = 0; i &lt; fi; i++)      &#123;        printf(&quot;%-*s&quot;, fie[i].max_length + 6, fie[i].name);      &#125;    &#125;    cout &lt;&lt; endl;    //把每一列都传出来    MYSQL_ROW row = NULL;    while (row = mysql_fetch_row(res))    &#123;      for (int i = 0; i &lt; fi; i++)      &#123;      printf(&quot;%-*s&quot;, fie[i].max_length + 6, row[i] ? row[i] : &quot;NULL&quot;);      &#125;      cout &lt;&lt; endl;  &#125;  //释放掉的是MYSQL_RES数据类型的     mysql_free_result(res); &#125; while (mysql_next_result(mysql) == 0); //关闭数据库 mysql_close(mysql); return 0;&#125;\n","tags":["sql"]},{"title":"前端技术","url":"/posts/4cc7bea9.html","content":"前端笔记了解网页一个网页可以存在着图片、文字、音频、视频、超链接等。\n网页是由浏览器的分析和渲染构成用户眼中的网页。\n不同的浏览器内核是不一样的,ie(Trident)、safari(Webkit)、chrome(Blink-&gt;是Webkit的分支)。\n\n由于内核不同一样的代码在解析渲染时速度、性能、效果也不相同。\n\nweb标准web标准中分为三个构造：\n\n\n\n构成\n语言\n说明\n\n\n\n结构\nHTML\n页面元素和内容\n\n\n表现\nCSS\n网页元素的外观和位置等页面样式\n\n\n行为\nJavaScript\n网页模型的定义宇页面交互\n\n\nHTML5(超文本标记语言)vscode快捷键用vscode编写html文件时，使用!(英文的感叹号)会自动填写一个简单的网页格式。\n缩进标签：shift+alt+f\n代码上下移动：alt+up/down\n快速查找：Ctrl+f\n快速替换：Ctrl+h\n注释：Ctrl+/\nH5的简介H5的DOCTYPE声明： 时H5的声明位于文档的前面，处于标签之前，他是页面的必备组成部分，作用是避免浏览器的怪异模式。\n基本骨架：\n\nhtml标签(双标签) ：定义HTML文档，标签限定了文档的开始点和结束点，它包裹了其他元素。\n\nhead标签(双标签) ： head标签用于定义文档的头部，用来描述文档的各种属性和信息，包括文档的标题，在web的位置等…head包含的数据不会作为内容给用户看的。\n\nbody标签(双标签) ： body元素定义文档的主体，包含了文档的所有内容(比如文档、超链接、图像、表格和列表等。)它是在页面中显示出来的(用户可以看见的)。\n\ntitle标签(双标签) ：- 定义文档的标题(显示在浏览器标题栏或者状态栏上)。- title标签是head标签中唯一且必须包含的东西。- title的增加有利于SEO优化。\n\nSEO是搜索引擎优化的英文缩写。通过网站内容调整，满足搜索引擎排名的需求。\n\n\nmeta标签(单标签) ： meta标签是用来描述网页文档的属性，关键字。比如：charset=&quot;utf-8&quot;表示当前网页使用的是utf-8编码。\n\n\n以上这些构成的就是h5的基本骨架。\n&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;  &lt;title&gt;   &lt;/title&gt;  &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt;  &lt;/body&gt;&lt;/html&gt;\n\n在&lt;html lang=&quot;en&quot;&gt;里lang=&quot;en&quot;是表示使用的语言是英语，可以删掉。\n标题标签标题是通过&lt;h1&gt;-&lt;h6&gt;(双标签)进行定义的,要想直接生成&lt;h1&gt;-&lt;h6&gt;vscode里有快捷键h$*6(后面的数字是几个标题，最多6个)。\n标题标签摆放的位置在标签种添加属性：align=&quot;left|center|right默认居左。\n属性是在标签里添加的。\n例：\n&lt;h1 align=&quot;center&quot;&gt;\n\n\nalign变红不是错误，是不推荐，在css里面会有相应的设置。\n\n正确使用标题html的标题标签只限定与标题。\n不能因为要生成较粗的文本而使用标题标签。\n正确的使用有利于提高SEO。\n&lt;h1&gt;为最重要的一次递减与markdown标题相同。\n标签之段落、换行、水平线段落段落是通过&lt;P&gt;(双标签)标签定义的。\n&lt;p&gt;这是一个段落&lt;/p&gt;\n\n\n虽然不用段落标签也可以在页面上显示，但是不利于管理与设置，所以在规范上是禁止的。\n\n换行如果在一个段落里想进行换行(不想产生新的段落)，可以使用&lt;br&gt;|&lt;br /&gt;(单标签)。\n&lt;p&gt;这是一个段落&lt;br /&gt;我和上面合在一起是个段落&lt;/p&gt;。\n\n\n&lt;br&gt;|&lt;br /&gt;是都可以的，加上&#x2F;是表示这个标签结束了从规范上是可以的，但是不加也没事。\n\n水平线想要创建一个水平线可以使用&lt;hr&gt;(单标签)。\n&lt;hr color=&quot;&quot;  width=&quot;&quot; size=&quot;&quot; align=&quot;&quot; /&gt;\n\n\nwidth的参数是以像素为单位，px是自适应。\n\n&lt;hr&gt;有四个属性：\n\ncolor：设置水平线的颜色。\nwidth：设置水平线的宽度。\nsize：设置水平线的高度。\nalign：设置水平线的对齐方式(默认居中)，可取值left|right。\n\n图片标签&lt;img&gt;(单标签)标签定义页面中的图像。\n属性：\n\nsrc：路径(图片地址与名字,可以填写网站地址)。\nalt：规定图像的替代文本,当图片无法加载的时候就会出现alt里填写的文本。\nwidth：规定图像宽度。\nheight：规定图像高度，一般高度与宽度设置一个即可，都设置很有可能会出现照片的失帧。\ntitle：鼠标悬停在图片上给予提示。\n\n超文本链接html使用标签&lt;a&gt;(双标签)来设置超文本链接的。\n超文本链接可以是一个字，一个词，一个图片等，可以通过点击这些内容来跳转到新的文档或者当前文档的一部分。\n&lt;a href=&quot;url&quot;&gt;文本&lt;/a&gt;\n\n\n属性href中写的是需要跳转的链接，可以用css来修改样式。\n\n文本标签当几个字或者一个词单独出现的时候我们不能用标题标签也不适用段落标签(&lt;p&gt;)，所以我们使用的是文本标签。\n常用文本标签(都是双标签)：\n\n\n\n标签\n描述\n\n\n\n&lt;em&gt;\n定义着重文字\n\n\n&lt;b&gt;\n定义粗体文字\n\n\n&lt;i&gt;\n定义斜体字\n\n\n&lt;strong&gt;\n定义加重语气\n\n\n&lt;del&gt;\n定义删除字\n\n\n&lt;span&gt;\n元素没有特定的含义\n\n\n列表标签有序列表有序列表是一列数据用数字标记。有序列表始于&lt;ol&gt;(双标签)标签，每个列表项用&lt;li&gt;(双标签)标签包裹。\n例：\n&lt;ol&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ol&gt;\n\n&lt;ol&gt;标签还有type属性：\n\n1表示列表项用数字标号(1,2,3…)\na表示列表项用小写字母标号(a,b,c…)\nA表示列表项用大写字母标号(A,B,C….)\ni表示列表项用小写罗马数字标号(i,ii,iii….)\nI表示列表项用大写罗马数字标号(I,II,III…)\n\n\n有序列表是可以嵌套的。\n\n无序列表无序列表是一个项目的列表，用粗体圆点进行标记，用&lt;ul&gt;(双标签)标签，每个列表用&lt;li&gt;标签。\n例：\n&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;\n\n&lt;ul&gt;标签还有type属性：\n\ndisc默认实心圆\ncircle空心圆\nsquare小方块\nnone不显示\n\n\n创建无序列表快捷键：ul&gt;li*n(n为li标签的数量)写的时候注意是不能在引号里有多余的空格的。无序列表也是可以嵌套的。\n\n表格表格的组成与特点：\n\n组成：行、列、单元格\n特点：同行等高、同列等宽。\n\n表格标签：\n\n表格：&lt;table&gt;(双标签)\n行格：&lt;tr&gt;(双标签)\n单元格：&lt;td&gt;(双标签)\n\n例：\n&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;长&lt;/td&gt;        &lt;td&gt;宽&lt;/td&gt;        &lt;td&gt;高&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;1&lt;/td&gt;        &lt;td&gt;2&lt;/td&gt;        &lt;td&gt;3&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\n\n快捷键：table&gt;trn(行数)&gt;tdx(单元格数){内容}\n\n属性(常用，后期css替代)：\n\nborder：设置表格的边框\nwidth：设置表格宽度\nheight：设置表格的高度\n\n表格单元格合并使用&lt;td&gt;的属性进行单元格的合并。\n\n水平合并：colspan；规则是保留左边，删除右边。\n垂直合并：rowspan；规则是保留上边，删除下边。\n\nform表单表单在网页中用来给用户填写信息的，从而能采集用户信息，使网页具有交互功能。\n&lt;form&gt;(双标签)表单是由容器和控件组成的，输入框和按钮等叫做控件，表单是容器，容纳各种各样的控件。\n例：\n&lt;form action=&quot;url&quot; method=&quot;get|post&quot; name=&quot;myform&quot;&gt;&lt;/form&gt;\n\n属性说明：\n\naction服务器地址\nname表单名字\nmetod中get和post区别\n数据提交方式，get把提交的数据url可以看见，post看不见。\nget一般用于提交少量数据，post用来提交大量数据。\n\n\n\n表单元素一个完整的表单包含三个基本组成部分：表单标签、表单域、表单按钮\n例：\n&lt;form&gt;  &lt;input&gt;  &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;\n\n\n&lt;input&gt;标签(单标签)是提供一个输入框。\n&lt;input&gt;里加一个属性type&#x3D;”text”是当用户在表单中填入文本内容时，就会用到文本域。\n&lt;input&gt;里加一个属性type&#x3D;”password”是密码字段标签，表单里会出现密码样式文字(黑点代替)。\n&lt;input&gt;里加一个属性type&#x3D;”submit”就是一个提交按钮，按钮的名字叫做提交，如果要换名字需要在后面加上 value&#x3D;””。\n按钮也可以使用&lt;button&gt;(双标签)。\n\n块元素与行内元素(内联元素)在HTML5出现以前，经常把元素按照块级元素和内联元素来区分。在HTML5中，元素不再按照这种方式来区分，而是按照内容模型来区分，分为元数据型、区块型、标题型、文档流型、语句型、内嵌型、交互型。元素不属于任何一个类别被称为穿透的，元素也可能属于不止一种类别，称为混合的。\n但是在初学者而言我们仍然学的是内联元素和块级元素，等到十分熟习了HTML5后可以会过来重新了解学习细致的分类。\n块级元素和内联元素的区别：\n\n\n\n块级元素\n内联元素\n\n\n\n块级元素会在页面中独占一行(自上向下垂直排列)\n内行元素不会独占页面中的一行，只占自身的大小\n\n\n可以设置width，height属性\n内行元素设置width，height属性无效\n\n\n一般块级元素可以包含内行元素和其他块级元素\n一般内联元素包含内联元素不包含块级元素\n\n\n常见块级元素：\ndiv(容器元素)、form(表单)、h1-h6(标题)、p(段)、table(表)、ul(无序排列)等\n\n常见内联元素(行内元素)：\na(超链接)、b(字体变粗)、em(着重文字)、i(斜体字)、span(标记)、strong(加重语气)等\n\n行内块级元素(&#x3D;&#x3D;特点：不换行、能够识别宽高&#x3D;&#x3D;)：\nbutton(按键)、img(图片)、input(输入框)等\n\nHTML5新增标签HTML5是HTML最新的修订版本，0214年10月由万维网联盟(w3c)完成标准制定。\n在HTML5出现之前，我们一般采用DIV+css布局页面，但是这种布局使我们的文档结构不清晰，也不利于爬虫的爬取。为了改变以上缺点，HTML5新增了很多新的语义化表签。\n扩展知识：\n&lt;div&gt;(双标签)是容器元素，也是页面中最多的元素,为后期便于添加css。\n例：\n&lt;div&gt;&lt;!-- 导航--&gt;    &lt;ul&gt;        &lt;li&gt;导航1&lt;/li&gt;        &lt;li&gt;导航2&lt;/li&gt;        &lt;li&gt;导航3&lt;/li&gt;    &lt;ul&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- 内容--&gt;    &lt;img src=&quot;&quot;&gt;    &lt;img src=&quot;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- 广告--&gt;    &lt;img src=&quot;&quot;&gt;    &lt;P&gt;这是个广告&lt;/p&gt;&lt;/div&gt;\n\ndiv实现：\n\n代码样例：\n&lt;!-- 标题 --&gt;&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;&lt;!-- 导航 --&gt;&lt;div id=&quot;nav&quot;&gt;&lt;/div&gt;&lt;!-- 内容模块 --&gt;&lt;div id=&quot;article&quot;&gt;    &lt;div id=&quot;section&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 侧边栏 --&gt;&lt;div id=&quot;silder&quot;&gt;&lt;/div&gt;&lt;!-- 底部 --&gt;&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;\n\n\nid属性是为了标识名字的\n\nH5新标签实现：\n\n代码样例：\n&lt;!-- 标题 --&gt;&lt;header&gt;&lt;/header&gt;&lt;!-- 导航 --&gt;&lt;nav&gt;&lt;/nav&gt;&lt;!-- 内容模块 --&gt;&lt;article&gt;    &lt;section&gt;&lt;/section&gt;&lt;/article&gt;&lt;!-- 侧边栏 --&gt;&lt;aside&gt;&lt;/aside&gt;&lt;!-- 底部 --&gt;&lt;footer&gt;&lt;/footer&gt;\n\nH5新标签：\n\n&lt;header&gt;(双标签)头部\n&lt;nav&gt;(双标签)导航\n&lt;article&gt;(双标签)代表一个独立的、完整的相关内容块、例如一篇完整的论坛帖子，一篇博客文章，一个用户评论等\n&lt;section&gt;(双标签)定义文档中的节，比如章节、页眉、页脚\n&lt;aside&gt;(双标签)侧边栏\n&lt;footer&gt;(双标签)脚部\n\n\n对于新标签只有新浏览器可以识别，老浏览器识别不了。\n\ncsscss概念：\ncss层叠样式表，又叫级联样式表，简称样式表。\ncss文件后缀名为.css\ncss用于HTML文档中元素样式的定义。\n使用css的唯一目的就是让网页具有美观一致的页面。\n语法CSS规则由两个主要的部分组成：选择器，以及一条或多条声明(样式)。\n选择器通常是需要改变样式的HTML元素。\n每条声明由一个属性和一个值组成。\n属性是希望设置的样式属性。每个属性都有一个值。属性和值被冒号分开。\n例：\n&lt;style&gt;    h1&#123;     color:blue;     font-size:12px;      &#125;&lt;/style&gt;\n\n\n在刚了解css时我们可以先把样式写在head里面，等到熟练了以后再单独写入.css文件内。在&lt;style&gt;(双标签)内写。\n\n文字样式：\n\ncolor 字体颜色样式。\nfont-size 字体大小样式。\n\ncss的引入方式&#x3D;&#x3D;内联样式(行内样式)&#x3D;&#x3D;\n要使用内联样式，你需要在相关的标签内使用样式(style)属性。style属性可以包括任何css属性。\n\n这种方式缺乏整体性和规划性，不利于维护，维护成本高。\n\n&lt;p style=&quot;backgroud: orange;font-size: 24px;&quot;&gt;css&lt;/p&gt;\n\n&#x3D;&#x3D;内部样式&#x3D;&#x3D;\n当单个文档需要特殊的样式时，就应该使用内部样式表、你可以使用&lt;style&gt;标签在文档头部定义内部样式表。\n\n单个页面内的css代码具有统一性，便于维护，但是多个页面之间容易混乱。\n\n&lt;head&gt;    &lt;style&gt;        h1&#123;        color:blue;        font-size:12px;        &#125;    &lt;/style&gt;&lt;/head&gt;\n\n&#x3D;&#x3D;外部样式&#x3D;&#x3D;(推荐)\n当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用&lt;link&gt;(单标签)标签链接到样式表。&lt;link&gt;标签在(文档的)头部。\n&lt;link rel=&quot;stylesheep&quot; type=&quot;text/css&quot; href=&quot;xxx.css&quot;&gt;\n\n\n建立一个css文件(不能写HTML)写完样式属性，再用link插入到需要的网页里。rel&#x3D;”stylesheep”是默认的不用改。\n\n选择器css语法规则由两个主要的部分构成：选择器，以及一条或多条的声明(样式)。\n全局选择器\n可以与任何元素匹配，优先级最低，一般做样式初始化。\n例：\n*&#123;    margin:0;    padding:0;&#125;\n\n\n*表示通配符。\n\n元素选择器(p,b,div等都是元素)\n标签选择器，选择的是页面上所有这种类型的标签，所以经常描述”共性”，无法描述某一个元素的”个性”。\n例：\n/* 例一*/p&#123;    font_size:14px;&#125;/* 例二 */&lt;p&gt;学完&lt;span&gt;前端&lt;/span&gt;，学后端&lt;/p&gt;.............&lt;style&gt;    span&#123;        color:red;    &#125;&lt;/stple&gt;\n\n\n所有的标签，都可以是选择器。无论嵌套多少层，一定都生效。选择的是所有，不是一个。\n\n类选择器\n规定用圆点.来定义，针对你想要的所有标签使用。\n&#x3D;&#x3D;优点：灵活&#x3D;&#x3D;\n例：\n&lt;h1 class=&quot;oneclass&quot;&gt;你好&lt;/h1&gt;......&lt;style&gt;   .oneclass&#123;        color:red;    &#125;&lt;/stple&gt;\n\n\nclass起的名字由数字、字母、”-“组成。\n\nclass属性的特点\n\n类选择器可以被多种标签使用。\n类名不能以数字开头。\n同一标签可以使用多个类选择器，在引号内用空格分开。\n\n例：\n&lt;h1 class=&quot;oneclass size&quot;&gt;你好&lt;/h1&gt;/* 正确 */&lt;h1 class=&quot;oneclass&quot; class=&quot;size&quot;&gt;你好&lt;/h1&gt;/* 错误 */\n\nID选择器\n针对某一特定的标签来使用，只能使用一次。css种的ID选择器以#来定义。\n例：\n&lt;h2 id=&quot;mytitle&quot;&gt;你好&lt;/h2&gt;#mytitle&#123;    border:3px dashed green;&#125;\n\n\nID是唯一的，且不能以数字开头。\n\n合并选择器\n语法：选择器1,选择器2,…{}\n作用：提取相同的样式，减少重复代码。\n例：\n.mytitle,.test&#123;    border:3px dashed green;&#125;\n\n选择器的优先级css中权重用数字衡量\n元素选择器的权重为；1\n类选择器的权重为；10\nid选择器的权重为：100\n内联样式的权重为：1000\n优先级从高到低：行内样式&gt;id选择器&gt;类选择器&gt;元素选择器\n当权值相同时，按照代码的执行顺序生效。\n字体属性css字体属性定义字体、颜色、大小、加粗、文字样式。\ncolor - 规定文本颜色都以红色为例：\ndiv&#123;color: red;&#125;div&#123;color: #ff0000;&#125;div&#123;color: rgb(255,0,0);&#125;div&#123;color: rgba(255,0,0,.5);&#125;/* a代表透明度，取值为0-1 */\n\nfont-size - 设置字体大小字体的大侠在页面设计中十分的重要!\n\n例：\np&#123;font-size: 40px;&#125;\n\n\n谷歌浏览器能接受的最小字体是12px。\n\nfont-weight - 设置文本的粗细\n\n\n值\n描述\n\n\n\nbold\n定义粗体字符\n\n\nbolder\n定义更粗字符\n\n\nlighter\n定义更细字符\n\n\n100-900\n定义由细到粗 400等同默认，700等同bold\n\n\n例：\np&#123;font-weight: normal;&#125;p&#123;font-weight: bold;&#125;p&#123;font-weight: 900;&#125;\n\n\n在谷歌浏览器中 bold与bolder是没有区别的。\n\nfont-style - 设置文本的字体样式\n\n\n值\n描述\n\n\n\nnormal\n默认值\n\n\nitalic\n定义斜体字\n\n\nfont-family - 设置元素字体\n每一个值用逗号分开。如果字体名称含空格，必须加上引号。\n\n例：\np&#123;font-family:&quot;Microsoft YaHei&quot;,&quot;Simsun&quot;,&quot;SimHei&quot;;&#125;\n\n背景属性css背景属性主要有以下几个：\n\n\n\n属性\n描述\n\n\n\nbackground-color\n设置背景颜色\n\n\nbackground-image\n设置背景图片\n\n\nbackground-position\n设置背景图片显示位置\n\n\nbackground-repeat\n设置背景图片如何填充\n\n\nbackground-size\n设置背景图片大小属性\n\n\nbackground-color - 设置背景颜色例：\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;.box&#123;    width:300px;    height:300px;    background-color:palevioletred;&#125;\n\n\ndiv是容器会单独占一行的，span是表示不会占一行的当div容器设置宽高的时候，表示他占了一块面积为宽x高的地方。opacity是透明度属性。\n\nbackground-image - 设置元素的背景图片元素的背景是元素的总大小，包括填充和边界(不包括外边距)。默认情况下background-image属性放在元素的左上角，如果图片不够大的化会在水平和垂直方向铺平图像，如果图片大小超过元素大小，从图像的左上角显示元素大小的那部分。\n例：\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;.box&#123;    width:300px;    height:300px;    background-image:ulr(&quot;img.jpg&quot;);&#125;\n\nbackground-repeat - 设置如何平铺背景图像\n\n\n值\n说明\n\n\n\nrepeat\n默认值\n\n\nrepeat-x\n只向水平方向平铺\n\n\nrepeat-y\n只向水平方向平铺\n\n\nno-repeat\n不平铺\n\n\n例：\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;.box&#123;    width:300px;    height:300px;    background-image:ulr(&quot;img.jpg&quot;);    background-repeat: no-repeat;&#125;\n\n\n默认是都平铺\nulr内的路径需要用/或者\\\\\n\nbackground-size - 设置背景图片的大小\n\n\n值\n说明\n\n\n\nlength\n设置背景图片的宽度和高度，第一个值是宽度，第二个值是高度，如果只设置一个，第二个值是auto\n\n\npercentage\n计算相对位置区域的百分比，第一个值是宽度，第二个值是高度，如果只设置一个，第二个值是auto\n\n\ncover\n保持图片纵横比并将图片缩放成完全覆盖背景区域的最小大小\n\n\ncontain\n保持图片纵横比并将图片缩放成适合背景区域的最大大小\n\n\n\ncover使用率最高\n\n例：\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;.box&#123;    width:300px;    height:300px;    background-image:ulr(&quot;img.jpg&quot;);    background-repeat: no-repeat;    background-size；100% 100%;&#125;\n\nbackground-position - 设置背景图片的起始位置，默认是0% 0%\n\n\n值\n说明\n\n\n\nlift top\n左上\n\n\nleft ccenter\n左中\n\n\nleft bottom\n左下\n\n\nright top\n右上\n\n\nright center\n右中\n\n\nright bottom\n右下\n\n\ncenter top\n中上\n\n\ncenter center\n中中\n\n\ncenter bottom\n中下\n\n\nx% y%\n第一值是水平位置，第二值是垂直位置，左上角是0% 0%，右下角是100% 100%。如果只指定了一个值，其他默认是50%。默认是0% 0%\n\n\nxpos ypos\n单位是像素\n\n\n例：\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;.box&#123;    width:300px;    height:300px;    background-image:ulr(&quot;img.jpg&quot;);    background-position；center;&#125;\n\n\nbackground-repeat等是当容器大于图片时的处理，background-position是当图片大于容器时的处理。\n\n文本属性text-align - 指定元素文本的对平对齐方式\n\n\n值\n说明\n\n\n\nleft\n文本居左排列，默认值\n\n\nright\n把文本排列到右边\n\n\ncenter\n把文本排列到中间\n\n\n例：\nh1&#123;text-align:center;&#125;h2&#123;text-align:left;&#125;h3&#123;text-align:right;&#125;\n\ntext-docoration - 规定添加到文本的修饰，下划线，上划线，删除线等\n\n\n值\n说明\n\n\n\nunderline\n定义下划线\n\n\noverline\n定义上划线\n\n\nline-through\n定义删除线\n\n\n例：\nh1&#123;text-docoration:overline;&#125;h2&#123;text-docoration:underline;&#125;h3&#123;text-docoration:line-through;&#125;\n\ntext-transform - 控制文本的大小写\n\n\n值\n说明\n\n\n\ncaptialize\n定义每个单词开头大写\n\n\nuppercase\n定义全部大写字母\n\n\nlowercase\n定义全部小写字母\n\n\n例：\nh1&#123;text-transform:captialize;&#125;h2&#123;text-transform:uppercase;&#125;p&#123;text-transform:lowercase;&#125;\n\ntext-indent - 规定文本块中首行文本缩进例：\np&#123;    text-indent:50px;&#125;\n\n\n负值是允许的。如果是负数，将第一行左缩进。\n\n表格属性使用css使HTML表格更漂亮。\n表格边框指定css表格边框，使用border属性\n例：\ntable,td&#123;    border:1px solid black;&#125;\n\n\nborder表示边框，1px表示线的宽度，solid表示实线，black表示颜色。\n\n折叠边框设置表格的边框是否被折叠成一个单一的边框或隔开\n例：\ntable&#123;    border-collapse:collapse;&#125;table,td&#123;    border:1px solid black;&#125;\n\n\n首先要设计好边框，之后 border-collapse:collapse;才会生效，这个属性与td写在一起也没有发生什么冲突(亲测)。\n\n表格宽度与高度width和height属性定义表格的宽度和高度\n例：\ntable&#123;    width:50px;    height:50px;&#125;\n\n\n当宽度和高度给table设置的时候，表格整体是设计的大小，要是给td设置时，就是一个单元格是设置的大小。\n\n表格文字对齐表格中的文本对齐和垂直对齐属性\ntext-align属性设置水平对齐方式，向左、右、或者中心。\n垂直对齐属性设置垂直对齐\n例：\ntd&#123;    text-align:right;    vertical-align:botton;&#125;\n\n\ntop居上，center居中，botton居下。\n\n表格填充如果在表的内容中控制空格之间的边框，应使用td的填充属性\n例：\ntd&#123;    padding:15px;&#125;\n\n\n当设置padding后就不用再可以的设置宽高了，他默认是居中，上下左右都填充。\n\n表格颜色下例指定边框的颜色，和th元素的文本和背景颜色：\ntable,td&#123;    border:1px solid green;&#125;td&#123;    background-color:green;    color:white;&#125;\n\n关系选择器关系选择器分为：\n\n后代选择器\n子代选择器\n相邻兄弟选择器\n通用兄弟选择器\n\n后代选择器定义：选择所有被E元素包含的F元素，中间用空格隔开\n语法：\nE F&#123;&#125;\n\n例：\n&lt;ul&gt;    &lt;li&gt;你好&lt;/li&gt;    &lt;li&gt;我好&lt;/li&gt;    &lt;li&gt;大家好&lt;/li&gt;    &lt;li&gt;你好吗&lt;/li&gt;&lt;/ul&gt;ul li&#123;    color:blue;&#125;\n\n子代选择器定义：选择所有作为E元素的直接子元素F，中间&gt;表示\n语法：\nE&gt;F&#123;&#125;\n\n例：\n&lt;div&gt;    &lt;p&gt;这是一个段落&lt;a href=&quot;#&quot;&gt;空连接&lt;/a&gt;&lt;/p&gt;    &lt;a href=&quot;#&quot;&gt;也是一个空连接&lt;/a&gt;&lt;/div&gt;div&gt;a&#123;    color:blue;&#125;\n\n相邻兄弟选择器定义：选择紧跟E元素后的F元素，用加号表示，选择相邻的第一个兄弟元素。\n语法：\nE+F&#123;&#125;\n\n例：\n&lt;h1&gt;你好&lt;/h1&gt;&lt;p&gt;我好&lt;/p&gt;&lt;p&gt;我们好&lt;/p&gt;h1+p&#123;    color:blue;&#125;\n\n\n只能向下相邻。\n\n通用兄弟选择器定义：选择E元素之后所有兄弟元素f，作用于多个元素，用~隔开。\n语法：\nE~F&#123;&#125;\n\n例：\n&lt;h1&gt;你好&lt;/h1&gt;&lt;p&gt;我好&lt;/p&gt;&lt;p&gt;我们好&lt;/p&gt;h1~p&#123;    color:blue;&#125;\n\ncss盒子模型(Box Model)概念：\n所有HTML元素可以看作盒子，再css中，”box model”这一术语是用来设计和布局时使用\ncss盒模型本质上是一个盒子，封装周围的HTML元素，他包括：外边距，边框，内边框，和实际内容。\n\n\nMargin(外边距) - 清除边框外的区域，外边距是透明的。\nBorder(边框) - 围绕再内边距和内容外边的边框。\nPadding(内边距) - 清除内容周围的区域。\nContent(内容) - 盒子的内容，显示文本和图像。\n\n\n以上都是属性，都可以设置的。当padding或者margin属性内的值变成了两个，第一个是表示上下的内间距，第二个表示左右的内间距。padding和margin属性都有-left,-right,-top,-bottom四个分开的属性。\n\n弹性盒子模型(flex box)定义：\n弹性盒子是css3的一种新的布局模式。\ncss3弹性盒子模型是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。\n引入弹性盒子布局模型的目的时提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。\ncss3弹性盒子模型内容弹性盒子由弹性容器和弹性子元素组成。\n弹性容器通过设置display属性的值为flex将其定义为弹性容器。\n弹性容器内包含了一个或多个弹性元素。\n\n弹性容器外及弹性子元素时正常渲染。弹性盒子只是定义了弹性子元素如何再弹性容器内布局。\n\n例：\n&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;    .container&#123;        background-color:cadetblue;        width:300px;         height:300px;        display:flex;    &#125;    .box1&#123;       background-color:red;        width:50px;         height:50px;    &#125;    .box2&#123;       background-color:blue;        width:50px;         height:50px;    &#125;    .box3&#123;        background-color:green;        width:50px;        height:50px;    &#125;&lt;/style&gt;\n\n\n正常div是块元素，在排列时，三个div是列摆放的，但是使用弹性盒子模型后就会横着摆放。因为默认弹性盒子里的内容是横向摆放的\n\n父元素上的属性display属性display:flex;开启弹性盒，默认弹性盒子里的内容是横向摆放的\n\n&#x3D;&#x3D;以下属性都是在开启弹性模型后才会生效的(亲测)。&#x3D;&#x3D;\n\nflex-direction属性定义：\n指定了弹性子元素在父容器中的位置。\n语法：\nflex-direction: row|row-reverse|column|column-reverse;\n\n\nrow：横向从左到右排列(左对齐)，默认的排列方式。\nrow-reverse：反转横向排列(右对齐，从后往前排，最后一项排在最前面)。\ncolumn：纵向排列。\ncolumn-reverse：反转纵向排列，从后往前排，最后一项排在最上面。\n\n\n一旦翻转就是反向对齐了。\n\njustify-content属性定义：\n内容对齐属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线对齐。\n语法：\njustify-content:flex-start|flex-end|center;\n\n\nflex-start:弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项一次平齐摆放。\nflex-end:弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被防止在该行的main-end边线，而后续弹性项一次平齐摆放。\ncenter:弹性项目居中紧挨着填充。(如果剩余的自由空间是负的，则弹性项目将在两个放下上同时溢出)。\n\nalign-items属性定义：\n设置或查索弹性盒子与严肃在侧轴(纵轴)方向上的对齐方式。\n语法：\nalign-items:flex-start|flex-end|center;\n\n\nflex-start:弹性盒子元素的侧轴(纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\nflex-end:弹性盒子元素的侧轴(纵轴）起始位置的边界紧靠住该行的侧轴结束边界\ncenter:弹性盒子元素在该行的侧轴(纵轴)上居中放置。(如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度)。\n\n子元素上的属性flex根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间。\n默认为0，即如果存在剩余空间，也不放大。\n如果只有一个子元素设置，那么按扩展因子转化的百分比对其分配剩余空间。0.1即10%，1即100%，超出按100%。\n例：\nflex: 10%;\n\n\n当使用了flex widch就不再生效了，flex优先级高。\n\n文档流文档流是文档中可以显示对象在排列时所占用的位置&#x2F;空间。\n例如：块元素自上而下摆放，内联元素，从左到右摆放。\n标准流里面的限制非常多，导致很多页面效果无法实现。\n比如：\n\n高矮不一，底边对齐。\n空白折叠现象\n无论多少个空格、换行、tab、都会折为一个空格\n如果我们想让img标签之间没有空隙，必须紧密连接\n\n\n\n脱离文档流使一个元素脱离标准文档流有三种方式：\n\n浮动\n绝对位置\n固定位置\n\n浮动增加一个浮层来放置内容\n浮动的定义：\nfloat属性定义元素在哪个方向浮动，任何元素都可以浮动。\n\n\n\n值\n描述\n\n\n\nleft\n元素向左浮动\n\n\nright\n元素向右浮动\n\n\n原理：\n\n浮动以后使元素脱离了文档流。\n浮动只有左右浮动，没有上下浮动。\n\n脱离文档流之后，元素相当于在页面上面增加一个浮层来放置内容，此时可以理解为有两层页面，一层使原页面，一层是脱离文档流的上层页面，所以会出现折叠现象。\n例：\n&lt;div class=&quot;con&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;....con&#123;    background:blue;    width:100px;    heigth:100px;    float:left;&#125;.box&#123;    background:green;    width:200px;    heigth:200px;&#125;\n\n\n使用浮动可以使块元素(列摆放)横着摆放。当容器不足以横向摆放内容的时候，会在下一行摆放。\n\n清除浮动副作用：\n当元素设置float浮动以后，该元素就会脱离文档流并向左&#x2F;右浮动。\n\n浮动元素会造成父元素高度塌陷\n后续元素会受到影响\n\n当大盒子div不写高度时，其高度可以正好包裹里面元素，当内在元素使用浮动后，大盒子面积是宽度x0=0导致父元素塌陷。\n\n当不写宽度时默认是整行都包裹，因为div是块元素。\n\n当重新添加没有浮动的元素后，会相互影响。\n解决方案：\n\n父元素设置高度\n受影响的元素增加clear属性\noverflow清除浮动\n伪对象方式\n\n\n父元素高度塌陷后，设置高度使其撑开\n\n\n在大盒子外的元素不受影响了，但是在大盒子内的不浮动元素仍会和浮动元素产生影响。\n\n\n在大盒子内的不浮动的元素添加clear属性就可以避免与浮动元素产生影响，一般选用both。\n\n当不能确定大盒子高度的时候，我们需要在大盒子的属性里同时添加overflow:hidden;和clear:both;这时盒子就会撑起来，当里面浮动与不浮动的元素还是发生影响时，在不浮动的元素里添加clear:both;即可。\n\n伪对象方式是为父标签添加伪类after并为元素content设置为空，并使用display:block;和clear:both;\n\n\n例：\n.ccs&#123;       width: 500px;       background-color: cyan;       &#125;       .ccs::after&#123;       content:&quot;&quot;;       display: block;       clear: both;       &#125;        &lt;div class=&quot;ccs&quot;&gt;       &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;       &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;       &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;       &lt;div class=&quot;boxw&quot;&gt;&lt;/div&gt;   &lt;/div&gt;\n\n\n当我运行时发现，当父元素塌陷后，里面如果存在一个非浮动元素，且使用了clear属性，父元素会被撑起来。\n\n定位定义：\n使用position属性指定了元素的定位类型。\n\n\n\n值\n描述\n\n\n\nrelative\n相对位置\n\n\nabsolute\n绝对位置\n\n\nfixed\n固定位置\n\n\n其中，绝对定位和固定位会脱离文档流。\n相对定位&#x3D;&#x3D;设置定位之后&#x3D;&#x3D;：可以使用四个方向值进行调整位置：left、top、right、bottom。\n例：\n.nin&#123;    height: 200px;    width: 200px;    margin: 10px;    background-color:lime;    position: relative;    left: 500px;&#125;\n\n\n相对定位还是在标准文件流中还是会出现问题。\n\n绝对定位\n脱离文件流的同时还能调整位置。\n\n例：\n.nin&#123;    height: 200px;    width: 200px;    margin: 10px;    background-color:lime;    position: absolute;    left: 500px;&#125;\n\n\n会出现压盖的现象而且可以无限制的压盖。\n\n固定定位\n当没有滚动的时候，绝对定位与固定定位是相同的效果，但是当出现滚动的时候，固定定位的元素不会因为滚轮的上下滚动而改变位置，但是绝对定位会改变位置。\n\n例：\n.nin&#123;    height: 200px;    width: 200px;    margin: 10px;    background-color:lime;    position:fixed;    left: 500px;&#125;\n\n设置定位之后，相对定位和绝对定位是相对于具有定位的父级元素进行位置调整的，如果父级元素不存在定位，则继续向上逐级寻找，直到顶层文件。\n\n一般父级容器使用的是  position: relative;当父级元素有定位，但是大小，小于子元素距离的位置，子元素会超出父元素面积的。\n\nZ-index设置元素的堆叠顺序。用有更高堆叠顺序的元素总是会处于堆叠顺序较低元素的前面。\n例：\n.yyr &#123;    height: 50px;    width: 50px;    background-color:lightskyblue;    position: absolute;    left: 80px;    top:50px;    z-index: 30;&#125;.uin &#123;    height: 50px;    width: 50px;    background-color:rgb(124, 85, 197);    position: absolute;    left: 60px;    top:70px;    z-index: 20;&#125;\n\n\n同级元素 z-index大的在上面，不同级的父级在下面，子级在上面。\n\ncss3新特性圆角使用css3的border-radius属性，你可以给任何元素制作圆角 border-radius属性，可以使用一下规则：\n\n四个值：第一个值为左上角，第二个右上角，第三个右下角，第四个左下角。\n三个值：第一个左上角，第二个右上角和左下角，第三个值为右下角。\n两个值：第一个值为左上角与右下角，第二个为右上角与左下角。\n一个值：四个角一个值。\n\n\n值为100%就称为一个圆了。\n\n阴影box-shadow向框添加一个或多个阴影。\nbox-shadow:h-shadow v-shadow blur color;\n\n\n\n\n值\n描述\n\n\n\nh-shadow\n必选，水平阴影的位置\n\n\nv-shadow\n必选，垂直阴影的位置\n\n\nblur\n可选，模糊近距离\n\n\ncolor\n可选，阴影的颜色\n\n\n\n水平和垂直为0四个边都有阴影，都为正数影子在右下方，都为负数影子在左上方。\n\n动画\njs实现动画是比较消耗性能的，但是css的话就会好很多。\n\n动画是使元素从一种样式逐渐变化为令一种样式的效果。\n可以改变任意多的样式任意多的次数。\n使用百分比来规定变化发生的时间，或用关键词from(等同于0%)和to(等同于100%)\n0%是动画开始，100%是动画完成。\n@keyframes创建动画使用规则，你可以创建动画\n@keyframes name&#123;    from|0%&#123;        css样式    &#125;    percent&#123;        css样式    &#125;    to|100%&#123;        css样式    &#125;&#125;\n\nname:动画名称，开发人员自己命名。\npercent:为百分比值，可以添加多个百分比值。\nanimation执行动画animation:name duration timing-function delay iteration-count direction;\n\n\n\n\n值\n描述\n\n\n\nname\n设置动画名称\n\n\nduration\n设置动画的持续时间\n\n\ntiming-function\n设置动画效果的速率\n\n\ndelay\n设置动画的开始时间\n\n\niteration-count\n设置动画循环的次数，infinite为无线次数循环\n\n\ndirection\n设置动画播放的方向\n\n\nanimation-play-state\n控制动画的播放状态: running代表播放，paused代表停止播放\n\n\n\n\n\ntiming-function值\n描述\n\n\n\nease\n逐渐变慢(默认)\n\n\nlinear\n匀速\n\n\nease-in\n加速\n\n\nease-out\n减速\n\n\nease-in-out\n先加速再减速\n\n\n\n\n\ndirection值\n描述\n\n\n\nnormal\n默认值为normal表示向前播放\n\n\nalternate\n动画播放再第偶数次向前播放，第基数次向反方向播放\n\n\n&#x3D;&#x3D;div:hover{}表示鼠标放到容器上触发事件&#x3D;&#x3D;&#x3D;&#x3D;opacity是透明的意思 范围：0-1&#x3D;&#x3D;\n\n切记duration和delay是有单位的s。\n\n例：\n.te &#123;           width: auto;           height: 200px;           background-color: rgba(101, 192, 225, 0.582);           display: flex;           justify-content: center;           align-items: center;           border-radius: 10px;           animation: myanim 3s ease-in-out 0s infinite;       &#125;       @keyframes myanim &#123;           0% &#123;               background-color: red;           &#125;           25% &#123;               background-color: yellow;           &#125;           50% &#123;               background-color: blue;           &#125;           75% &#123;               background-color: yellow;           &#125;           100% &#123;               background-color: red;           &#125;       &#125;       .te:hover &#123;           animation-play-state: paused;       &#125;   &lt;div class=&quot;te&quot;&gt;       &lt;ul&gt;           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;导航1&lt;/a&gt;&lt;/li&gt;           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;导航2&lt;/a&gt;&lt;/li&gt;           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;导航3&lt;/a&gt;&lt;/li&gt;           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;导航4&lt;/a&gt;&lt;/li&gt;           &lt;/ol&gt;   &lt;/div&gt;\n\n媒体查询媒体查询能使页面在不同的终端设备下达到不同的效果。\n媒体查询会根据设备的大小自动识别加载不同的样式。\n设置meta标签使用设备的宽度作为视图宽度并禁止初始的缩放。在head标签里加入这个标签meta标签。\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1,maximum-scale=1, user-scalable=no&quot;&gt;\n\n参数解释：\n\nwidth&#x3D;device-width 宽度等于当前设备的宽度\ninitial-scale 初始的缩放比例(默认设置为1.0)\nmaximum-scale 允许用户缩放到的最大比例(默认设置为1.0)\nuser-scalable 用户是否可以动手缩放(默认设置为no)\n\n作用解释：当页面用手机打开后会自适应，当设置meta后就会保持元素原本大小，不会自适应。\n媒体查询语法使用统一的代码在不同设备上实现显示不同的内容\n\ndisplay:none;代表元素不显示 display: block;代表元素显示，把行级元素变为块级元素，display: inline;就是行级元素。\n\n例：\n@media screen and (max-width: 768px) &#123;    /*设备小于768px加载样式,手机*/    body&#123;     background-color: red;    &#125;&#125;@media screen and (max-width: 992px) and (min-width: 768px) &#123;    /*设备小于768px但小于992px加载样式，平板*/    body&#123;        background-color: pink;    &#125;&#125;@media screen and (min-width: 992px) &#123;    /*设备大于992px加载样式，电脑*/    body&#123;        background-coor: green;    &#125;&#125;\n\n雪碧图css sprite也叫精灵图、css雪碧图，是一种网页图片应用处理方式。他允许你将一个页面涉及到的所有零星图片都包含到一张大图中去。\n\n最常见的就是表情包，一次性加载，然后放在哪里再做调整。\n\n优点：\n\n减少图片的字节\n减少网页的hppt请求，从而大大提高页面的性能\n\n原理：\n\n通过backgrount-image引入背景图片\n通过backgrount-postition把背景图片移动到自己需要的位置\n\n通过在浏览器里使用开发者模式不断的调位置，最后确定参数，写到文件内。\n字体图标我们经常会使用到一些图标。但是我们在使用时，往往会遇到失帧的情况，而且图片数量很多的话，页面加载就会越慢。所以，我们可以使用字体图标的方式来显示图标，既解决了失帧问题，也解决了图片占用资源的问题。\n常用字体图标库:阿里字体图标库\n优点：\n\n轻量级：加载速度快，减少http请求\n灵活性：可以利用css设置大小颜色等\n兼容性：网页字体支持所有现代浏览器，包括ie低版本\n\n使用字体图标\n注册账号并登录\n选取图标或搜素图标\n添加购物车\n下载代码\n选用font-class引用\n\n\n下载后有文档教程。当用css设置大小时会被原有的css所覆盖掉，所有我们需要再给他加一个类名，重新声明他的大小。\n\nJavaScript简介js是一种轻量级的脚本语言。所谓脚本语言，指的是它不具备开发操作系统的能力，而是用来编写控制其他大型应用程序的脚本。\njs是一种嵌入式语言，它本身提供的核心语法不算很多。\n优点：\n\n操控浏览器\n广泛的使用领域\n易学习\n\nJavaScript与ECMAScript关系：\nECMAScript和js关系是，前者是后者的规格，后者是前者的实现。日常场合，这两个词是可以互换的\njs语句与标识符语句js程序的单位是行，也就是一行一行地执行。一般情况下，每一行就是一个语句。\n写js可以在HTML文件内的body标签里写一个&lt;script&gt;(双标签)，在此标签内就可以写js代码了\n例：\nvar num = 10;\n\n语句以分号结尾，一个分号就表示一个语句的结束。js中分号可加可不加(建议加)\n标识符标识符指的是用来识别各种值的合法名称。最常见的标识符就是变量名。\n标识符是由：字母、美元符号($)、下划线(_)、和数字组成，其中数字不能开头。\n\n中文是合法的标识符，可以用做变量名(不推荐)\n\njs保留关键字：\n不用强行记忆。\nJavaScript有一些保留字，不能用作标识符: arguments、break、case、catch、class、const、continue、 debugger、default、 delete、 do、 else、 enum、 eval、 export、extends、 false、 finally、for,、function、 if、implements、 import、in、 instanceof、 interface、 let、new、 null、 package、private、 protected、 public、 return、 static、 super、 switch、 this、 throw 、true、 try、 typeof、var、void、while、with、yield。\n\n变量(var)var关键字是声明变量。\n输出变量：\n例子：\nvar num=10;console.log(num);\n\n变量提升js引擎工具的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行的运行。造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升。\n例子：\nconsole.log(num);var num=10;\n\n\n不会报错，而是提示空值。\n\njs引入到文件js常用引入方式：\n\n嵌入到HTML文件中\n引入本地独立js文件\n引入网络来源文件\n\n例：\n// 嵌入HTML&lt;body&gt;    &lt;script&gt;        var num=100;    &lt;/script&gt;&lt;/body&gt;// 引入本地js文件&lt;body&gt;    &lt;script src=&quot;text/javascript&quot; scr=&quot;./itb.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;//引入网络来源文件&lt;body&gt;    &lt;script src=&quot;http://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;\n\njs注释与常见输出方式注释源码中注释是不被引擎解释的，js有两种注释写法：单行注释用&#x2F;&#x2F;，多行注释用&#x2F;**&#x2F;\nHTML中用注释。\njs输出方式js有很多的输出方式，都可以让我们更直观的看到程序运行的结果。\n// 弹出对话框，人后把内容输出，先把内容转化为字符串然后输出alert(&quot;要输入的内容&quot;);//输出到页面document.write(&quot;要输入的内容&quot;);//再控制台输出console.log(要输入的内容);\n\n数据类型js有六种数据类型：\n\n数值\n字符串\n布尔值\nnull\nundefined\n对象\nsymbol(ES6新增)\nbigint(ES6新增)\n\n数据类型分类原始类型(基础类型)\n数值\n字符串\n布尔值\n\n//数值var num=10;//字符串类型，被双引号或者单引号包裹的var age=&#x27;nihao&#x27;;//判断正误的var fi=ture;\n\n合成数据类型(复合类型)对象:因为一个对象往往是多一个原始类型的值的合成，可以看作是存放各种值的容器。\nvar user=&#123;    name:&quot;nihoa&quot;,    age:20,    learn:true&#125;\n\n\nundefined和null，一般将他俩看成特殊值。\n\ntypeof运算符typeof是用来检查数据类型的。\n例：\ntypeof 123 //numbertypeof &#x27;123&#x27; //stringtypeof true //booleantypeof &#123;&#125; //object--&gt;判断不准确\n\nnull与undefined的区别\nnull与undefined都表示没有，含义十分相似。将一个变量赋值为null与undefined，语法上没有任何区别。\nnull一般代表对象为没有，undefined代表数值没有。\n运算符算数运算符\n加法 +\n减法 -\n乘法 *\n除法 &#x2F;\n余数 %\n自增 ++\n自减 –\n\n赋值运算符\n&#x3D; 赋值\n+&#x3D; 加且赋值\n-&#x3D; 减且赋值\n*&#x3D; 乘且赋值\n&#x2F;&#x3D; 除且赋值\n%&#x3D; 取余且赋值\n\n比较运算符\n&lt; 小于\n\n\n大于\n\n\n&lt;&#x3D; 小于等于\n\n\n&#x3D; 大于等于\n\n\n&#x3D;&#x3D; 等于\n\n&#x3D;&#x3D;&#x3D; 严格相等\n\n!&#x3D; 不等于\n\n!&#x3D;&#x3D; 严格不相等\n\n\n\n返回为布尔值严格比较不仅要比较数值，也要比较数据类型与c++不同，js可以不同的数据类型之间比较\n\n布尔运算符\n! 取反运算符\n&amp;&amp; 且运算符\n|| 或运算符\n\n\nnull、undefin、0、””(空字符串)、NaN、false这些取反是true，其他取反为false\n\n条件语句之if语句if结构先判断一个表达式的布尔值，然后根据布尔值为真伪，执行不同的语句。\n语法：\nif(布尔值)&#123;    语句;&#125;\n\n条件语句之if…else例：\nif()&#123;&#125;else&#123;&#125;\n\n多个if…else连用if()&#123;&#125;else if&#123;&#125;else if()&#123;    &#125;else&#123;&#125;\n\nif嵌套if()&#123;    if()    &#123;    &#125;    else&#123;    &#125;&#125;else&#123;&#125;\n\n条件语句之 switch多个if…else连在一起使用的时候，可以转为使用更方便的switch结构。\n例：\nswitch()&#123;    case &quot;&quot;:        break;    case &quot;&quot;:        break;    default:&#125;\n\n\nbreak不能省\n\n三元运算符JavaScript还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。\n(条件) ? 表达式1 : 表达式2\n\n\n简化if else\n\n循环语句之for循环语句用于重复执行某个操作\nfor语句就是循环命令，可以指定循环的起点、终点和终止条件。它的格式如下\nfor(初始条件;条件;迭代因子)&#123;    语句&#125;\n\n\n三个表达式省略会出现死循环，网页卡死。\n\nfor语句后面的括号里面，有三个表达式。\n\n初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。\n布尔表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。\n迭代因子（increment）：每轮循环的最后一个操作，通常用来递增循环变量。\n\n\nconsole.log()内的加号代表输出这两个的值连在一起的字符串\n\n循环语句之whileWhile语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。\nwhile()&#123;    语句&#125;\n\n\n所有for循环，都可以改写成while循环\n\nbreak语句与continue语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行\nbreak用来跳出循环或者代码块\ncontinue用来立即终止本轮循环，开始准备下次循环。\n字符串字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。\n例：\n&#x27;itbaizhan&#x27;&quot;itbaizhan&quot;\n\n单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。\n例：\n&#x27;key = &quot;value&quot;&#x27;&quot;It&#x27;s a long itbaizhan&quot;\n\n如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。\n例：\n&#x27;Did she say \\&#x27;Hello\\&#x27;?&#x27;// &quot;Did she say &#x27;Hello&#x27;?&quot;&quot;Did she say \\&quot;Hello\\&quot;?&quot;// &quot;Did she say &quot;Hello&quot;?&quot;\n\n\n字符串默认是写一行，分多行写也会报错，要是非要换行需要用\\。\n\nlength属性length属性返回字符串的长度，该属性也无法改变。\n例：\n\nlength后面没有括号。\n\nvar s=&quot;nihaoya&quot;;s.length;\n\n字符串操作charAt() - 返回指定字符charAt方法返回指定位置的字符，参数是从0开始编号的。\n例：\nvar s=new String(&quot;nihao&quot;);s.charAt(4);\n\n\n如果参数为负数，或者大于等于字符串长度，charAt返回空字符串。\n\nconcat() - 连接字符串concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。\n例：\nvar n1=&quot;nihao&quot;;var n2=&quot;wangxiangyu&quot;;var n3=n1.concat(n2);\n\n\n后面括号里可以无限添加元素，之间用,分割。\n\n如果参数不是字符串，将会先转为字符串，然后再连接。\n例：\nvar n1=123;var n2=456;var n3=n1.concat(n2);\n\n\n一般用+来连接字符串。但是要是有多个数字连在一起相加，然后再加字符串，是数字先相加，然后再加字符串。\n\nsubstring() - 截取字符串substring方法用于从原字符串取出子字符串并返回，不能改变原字符串。他第一个参数表示子字符串的开始位置，第二个位置表示结束位置(返回结果不含位置)。\n&quot;nihoa&quot;.substring(0,2);//ni&quot;nihoa&quot;.substring(1);//hoa&quot;nihoa&quot;.substring(2,0);//等同于&quot;nihoa&quot;.substring(0,2);\n\n\n当数字为负数，自动转换为0.\n\nsubstr() - 截取字符串substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟substring作用相同。\n第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。\n&#x27;itbaizhan&#x27;.substr(2, 7); // baizhan\n\n\n如果省略第二个参数，则表示子字符串一直到原字符串的结束。\n\n如果省略第二个参数，则表示子字符串一直到原字符串的结束\n&#x27;itbaizhan&#x27;.substr(2) // &quot;baizhan&quot;\n\n如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串\n&#x27;itbaizhan&#x27;.substr(-7) // &quot;baizhan&quot;&#x27;itbaizhan&#x27;.substr(4, -1) // &quot;&quot;\n\nindexOf() - 查找子字符串 -&gt;常用方法indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置，如果返回-1，就表示不匹配。\n&quot;hello world&quot;.indexOf(&#x27;o&#x27;);//4&quot;hello world&quot;.indexOf(&#x27;t&#x27;);//-1&quot;hello world&quot;.indexOf(&#x27;o&#x27;,6);//7\n\n\n第二个参数表示从n位置向后查。\n\ntrim() - 去除字符串两端空格trim方法用来除去字符串两端的空格，返回一个新字符串，不改变原字符串。\n&#x27;  nihoa  &#x27;.trim();\n\n该方法去除的不仅是空格，还包括制表符(\\t、\\v)、换行符（\\n）和回车符(\\r)。\n\n中间空格去不掉。\n\nES6扩展方法：trimEnd()和trimStart()方法 - 单独去前或后空格&#x27;  nihoa  &#x27;.trimEnd();&#x27;  nihoa  &#x27;.trimStart();\n\nsplit() - 分割字符串split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。\n&#x27;it|sxt|baizhan&#x27;.split(&#x27;|&#x27;) // [&quot;it&quot;, &quot;sxt&quot;, &quot;baizhan&quot;]\n\n如果分割规则为空字符串，则返回数组的成员是原字符串的每个字符串。\n&#x27;a|b|c&#x27;.split(&#x27;&#x27;) // [&quot;a&quot;, &quot;|&quot;,  &quot;b&quot;,&quot;|&quot;, &quot;c&quot;]\n\n如果省略参数，则返回数组的为一成员就是原字符串。\n&#x27;it|sxt|bz&#x27;.split() // [it|sxt|bz]\n\nsplit方法还可以接受第二个参数，限定返回数组的最大成员数。\n&#x27;it|sxt|bz&#x27;.split(&#x27;|&#x27;, 0) // []&#x27;it|sxt|bz&#x27;.split(&#x27;|&#x27;, 1) // [&quot;it&quot;]&#x27;it|sxt|bz&#x27;.split(&#x27;|&#x27;, 2) // [&quot;it&quot;, &quot;sxt&quot;]&#x27;it|sxt|bz&#x27;.split(&#x27;|&#x27;, 3) // [&quot;it&quot;, &quot;sxt&quot;, &quot;bz&quot;]&#x27;it|sxt|bz&#x27;.split(&#x27;|&#x27;, 4) // [&quot;it&quot;, &quot;sxt&quot;, &quot;bz&quot;]\n\n数组数组是按次序排列的一组值。每个值的位置都有编号(从0开始)，整个数组用方括号表示。\nvar arr=[&#x27;ni&#x27;,&#x27;hao&#x27;];\n\n两端的方括号是数组的标志。\n在定义数组的时候可以先初始化，也可以后赋值。\nvar arr = [];arr[0]=&#x27;ni&#x27;;arr[1]=&#x27;hao&#x27;;\n\n任何类型的数据，都可以放入数组。\nvar arr = [ 100, [1, 2, 3],false ];\n\n\n称为多维数组。\n\n如果数组的元素还是数组，就形成了多维数组\nvar a = [[1, 2], [3, 4]];a[0][1] // 2a[1][1] // 4\n\n数组length属性数组的length属性，返回数组的成员数量。\n例：\n[&#x27;sxt&#x27;,&#x27;ss&#x27;,&#x27;tt&#x27;].length\n\n\n当数组越界后会出现undefined。\n\n数组的遍历数组的遍历可以考虑使用for循环或while循环\nvar a = [&#x27;sxt&#x27;, &#x27;baizhan&#x27;, &#x27;it&#x27;];// for循环for(var i = 0; i &lt; a.length; i++) &#123;  console.log(a[i]);&#125;// while循环var i = 0;while (i &lt; a.length) &#123;  console.log(a[i]);  i++;&#125;\n\nfor..in遍历数组\nfor(var i in arr)&#123;    console.log(a[i]);&#125;\n\n数组的方法静态方法Array.isArray() - 判断是否是数组Array.isArray方法返回一个布尔值，表示参数是否为数组。可以弥补typeof运算符的不足。\npush()&#x2F;pop() - 添加&#x2F;删除数组元素push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意：该方法会改变原数组。\nvar arr = [];arr.push(&quot;你好&quot;);arr.push(&#x27;hello&#x27;);arr.push(true, &#123;&#125;);\n\n\n可以一次性添加一条也可以添加多条。\n\npop方法用于删除数组的最后一个元素，并返回该元素。注意：该方法会改变原数组。\nvar arr = [&#x27;ni&#x27;,&#x27;hao&#x27;,&#x27;ma&#x27;];arr.pop();\n\nshift()&#x2F;unshift() - 删除&#x2F;添加第一个元素并返回shift方法用于删除数组的第一个元素，并返回该元素。注意：该方法会改变原数组。\nvar arr = [&#x27;ni&#x27;,&#x27;hao&#x27;,&#x27;ma&#x27;];arr.shift();\n\nunshift方法用于数组的第一个元素的位置添加一个元素，并返回该元素。注意：该方法会改变原数组。\nvar arr = [&#x27;ni&#x27;,&#x27;hao&#x27;,&#x27;ma&#x27;];arr.unshift(&#x27;wxy&#x27;);\n\n\n可以添加多个，会按顺序插入数组内。当删除空数组后会返回undefined。\n\njoin - 所有数组连接为一个字符串join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。\n例：\nvar a=[1,2,3];a.join(&#x27; &#x27;)//&#x27;1 2 3&#x27;a.join(&#x27; | &#x27;) // &quot;1 | 2 | 3 | 4&quot;a.join() // &quot;1,2,3,4&quot;\n\n\n当数组里有null或空位，使用join会转化为空字符串。\n\n数组的join配合字符串split可以实现数组于字符串的转换。\n例：\nvar arr=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];var myArr=arr.join(&quot;&quot;);\n\nconcat() - 用于多个数组的合并concat方法用于多个数组的合并。他将新数组的成员，添加到原数组成员的后面，然后返回一个新数组，原数组不变。\n[&#x27;hello&#x27;].concat([&#x27;world&#x27;])\n\n\n可以是多个元素的合并(参数为多个)。用于上拉加载，合并数据。\n\n例：\n[1,2,3].concat(4,5,6,[7,8,9]);//[1,2,3,4,5,6,7,8,9]\n\nreverse() - 用于排列数组元素reverse方法用于颠倒排列数组元素，返回改变后的数组(改变原来数组)。\n例\nvar a=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];a.reverse();//c,b,a\n\nindexOf() - 查找元素indexOf方法返回给定元素在数组中第一次出现的位置，没有出现则返回-1。\n例：\nvar arr=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];arr.indexOf(&#x27;b&#x27;);\n\nindexOf方法还可以接受第二个参数，表示搜索的开始位置\n[&#x27;尚学堂&#x27;, &#x27;百战程序员&#x27;, &#x27;itbaizhan&#x27;].indexOf(&#x27;尚学堂&#x27;, 1) // -1\n\n函数函数是一段可以重复调用的代码块。\n函数的声明(function)function命令：function声明的代码区块，就是一个函数。function命令后面是函数名，函数名的后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。\nfunction print(s)&#123;    console.log(s);&#125;\n\n函数名的提升js引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数都会像变量声明一样，被提到代码开头。\nadd();function add()&#123;&#125;\n\n函数参数函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数\nfunction square(x) &#123;    console.log(x * x);&#125;square(2) // 4square(3) // 9\n\n函数返回值JavaScript函数提供两个接口实现与外界的交互，其中参数作为入口，接收外界信息；返回值作为出口，把运算结果反馈给外界\nfunction getName(name)&#123;    return name;&#125;var myName = getName(&quot;itbaizhan&quot;)console.log(myName); // itbaizhan\n\n\nreturn 后面不能在添加任何代码，因为不会执行\n\n对象对象是js语言的核心概念，也是最重要的数据类型。对象就是一组键值对的集合，是一种无序的复合数据集合。\n对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用\n例：\nvar user=&#123;    name:&quot;sjj&quot;,    age:14,    job:[1,2,3],    flag:ture,    getname:function()&#123;        console.log(&quot;ni&quot;);    &#125;    container:&#123;        frontEnd:[&quot;Web前端&quot;,&quot;Android&quot;,&quot;iOS&quot;],        backEnd:[&quot;Java&quot;,&quot;Python&quot;]    &#125;&#125;\n\n\n使用是 名字.属性容器里面嵌容器就是链式调用\n\nMath对象Math是js的原生对象，提供各种数学功能。\nMath.abs - 绝对值Math.abs()方法返回参数的绝对值\n例：\nMath.abs(-1);\n\nMath.max(),Math.min() - 最大值，最小值Math.max()方法返回参数中最大的那个值，Math.min()返回最小的那个值。如果参数为空，Math.min返回infinity,Math.max返回-infinity。\n例：\nMath.max(4,5);Math.min(-1,4);Math.max();Math.min();\n\nMath.floor()，Math.ceil() - 向上&#x2F;向下取整Math.floor()方法返回小于参数的最大整数\nMath.ceil()方法返回大于参数的最小整数\n例：\nMath.floor(3.2);//3Math.ceil(3.2);//4\n\nMath.random() - 随机数Math.random()返回0-1之间的伪随机数，可以等于0，但一定小于1\n例：\nMath.random();\n\n任意范围的随机数生成：\nfunction rand(min,max)&#123;    return Math.random()*(max-min)+min;&#125;\n\nDate对象date对象是js原生的时间库。他以1970年1月1日00：00：00作为时间的零点，可以表示的时间范围是前后各一亿天(单位ms)。\nDate.now() - 返回当前时间Date.now()方法返回当前时间距离时间零点(1970年1月1日00：00：00 UTC)的毫秒数，相当于Unix时间戳乘以1000\nDate.now();\n\n时间戳时间戳是指1970年1月1日00：00：00起至现在的总秒数。\nDate对象提供了一系列get*方法，用来获取实例对象某个方面的值\n\n实例方法get类getTime()：返回实例距离1970年1月1日00:00:00的毫秒数getDate()：返回实例对象对应每个月的几号（从1开始）getDay()：返回星期几，星期日为0，星期一为1，以此类推getYear()：返回距离1900的年数getFullYear()：返回四位的年份getMonth()：返回月份（0表示1月，11表示12月）getHours()：返回小时（0-23）getMilliseconds()：返回毫秒（0-999）getMinutes()：返回分钟（0-59）getSeconds()：返回秒（0-59）\n\n例：\nnew Date();//Mon Feb 06 2023 15:56:05 GMT+0800 (中国标准时间)Date(1675670226648)//放进去时间戳也可以  var endYear = new Date(today.getFullYear(), 11, 31, 23, 59, 59, 999);//年，月，日，时，分，秒，毫秒 -&gt;误差1毫秒\n\nDOM概述DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如对元素增删内容）。\n浏览器会根据 DOM 模型，将结构化文档HTML解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。\nDOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。\n节点DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。\n节点的类型有七种：\n\nDocument：整个文档树的顶层节点\nDocumentType：doctype标签\nElement：网页的各种HTML标签\nAttribute：网页元素的属性（比如class&#x3D;”right”）\nText：标签之间或标签包含的文本\nComment：注释\nDocumentFragment：文档的片段\n\n节点树一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。\n浏览器原生提供document节点，代表整个文档\nconsole.log(document);// 在控制台中打印整个文档内容。\n\n除了根节点，其他节点都有三种层级关系\n\n父节点关系（parentNode）：直接的那个上级节点\n子节点关系（childNodes）：直接的下级节点\n同级节点关系（sibling）：拥有同一个父节点的节点\n\nNode.nodeType属性不同节点的nodeType属性值和对应的常量如下\n\n文档节点（document）：9，对应常量Node.DOCUMENT_NODE\n元素节点（element）：1，对应常量Node.ELEMENT_NODE\n属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE\n文本节点（text）：3，对应常量Node.TEXT_NODE\n文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE\n\ndocument.nodeType // 9document.nodeType === Node.DOCUMENT_NODE // true\n\ndocument对象 - 方法&#x2F;获取元素document获取元素：\n\ngetElementsByTagName\ngetElementsByClassName\ngetElementsByName\ngetElementsByld\nquerySelector\nquerySelectorAll\n\ndocument.getElementsByTagName() - 搜索HTML标签名document.getElementsByTagName方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（HTMLCollection实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集\nvar paras = document.getElementsByTagName(&#x27;p&#x27;)[0];paras.innerHTML=&quot;ni&quot;;\n\n\ndocument.getElementsByTagName()是获取标签，后面加上数组是显示标签里的内容。paras.innerHTML改变标签里的内容(只能是字符串)。\n\n如果传入*，就可以返回文档中所有 HTML 元素\nvar allElements = document.getElementsByTagName(&#x27;*&#x27;);\n\ndocument.getElementsByClassName() - 搜索HTML标签类名document.getElementsByClassName方法返回一个类似数组的对象（HTMLCollection实例），包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中\nvar elements = document.getElementsByClassName(&#x27;names&#x27;);\n\n由于class是保留字，所以 JavaScript 一律使用className表示 CSS 的class\n参数可以是多个class，它们之间使用空格分隔\nvar elements = document.getElementsByClassName(&#x27;foo bar&#x27;);\n\ndocument.getElementsByName() - 通过name属性查找document.getElementsByName方法用于选择拥有name属性的 HTML 元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;等），返回一个类似数组的的对象（NodeList实例），因为name属性相同的元素可能不止一个\n// 表单为 &lt;form name=&quot;itbaizhan&quot;&gt;&lt;/form&gt;var forms = document.getElementsByName(&#x27;itbaizhan&#x27;);\n\n\n使用率低\n\ndocument.getElementById() - 通过id属性查找document.getElementById方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null\nvar elem = document.getElementById(&#x27;para1&#x27;);\n\n\n最常用的方法。\n\n注意，该方法的参数是大小写敏感的。比如，如果某个节点的id属性是main，那么document.getElementById(&#39;Main&#39;)将返回null\ndocument.querySelector() - 选择器查找，只返回第一个document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null\nvar el1 = document.querySelector(&#x27;.myclass&#x27;);\n\ndocument.querySelectorAll() - 选择器查找，都返回document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点\nvar elementList = document.querySelectorAll(&#x27;.myclass&#x27;);\n\ndocument对象方法&#x2F;创建元素document创建元素：\n\ncreateElement\ncreateTextNode\ncreateAttribute\n\ndocument.createElement() - 生成元素节点document.createElement方法用来生成元素节点，并返回该节点。\n例：\nvar newDiv=document.createElement(&#x27;div&#x27;);\n\ndocument.createTextNode() - 生成节点文本document.createTextNode方法用来生成文本节点，并返回该节点。他的参数是文本节点的内容。\n例：\nvar newDiv=document.createElement(&#x27;div&#x27;);var newContent=document.createTextNode(&#x27;hello&#x27;);newDiv.appendChild(newContent);//将内容或者子元素放到容器中。\n\ndocument.createAttribute() - 生成节点属性document.createAttribute方法生成新的属性节点，并返回它。\n例：\nvar root=document.getElementById(&#x27;root&#x27;);var it=document.createAttributr(&#x27;it&#x27;);it.value=&#x27;its&#x27;;root.setAttributeNode(it);//放置属性内容\n\n\n只有属性的放置用setAttributeNode，其他的放置用appendChild(dom对象)。\n\nElement对象属性Element对象属性有：\n\nid\nclassName\nclassList\ninnerHTML\ninnerText\n\nElement对象对应网页HTML元素。每个HTML元素，在DOM树上都会转化成一个Element节点对象.\nElement.idElement.id属性返回指定元素id属性，该属性可读写。\n例：\nvar p=document.querySelector(&#x27;p&#x27;);p.id\n\nElement.classNameElement.className属性用来读写当前元素节点的class属性。他的值是一个字符串，每一个class之间用空格分割。\n例：\nvar div = document.getElementById(&#x27;myDiv&#x27;);div.className\n\nElement.classList - 对class的集合方法classList对象有以下方法。\n\nadd():增加一个class\nremove():移除一个class\ncontains()：检查当前元素是否包含某个class\ntoggle()：将某个class移入或移出当前元素\n\n例：\nvar div = document.getElementById(&#x27;myDiv&#x27;);......div.classList.add(&#x27;myCssClass&#x27;);div.classList.add(&#x27;foo&#x27;, &#x27;bar&#x27;);div.classList.remove(&#x27;myCssClass&#x27;);div.classList.toggle(&#x27;myCssClass&#x27;); // 如果 myCssClass 不存在就加入，否则移除div.classList.contains(&#x27;myCssClass&#x27;); // 返回 true 或者 false\n\nElement.innerHTML - 设置页面内容Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。\n该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括&lt;HTML&gt;和&lt;body&gt;元素。\nel.innerHTML = &#x27;&#x27;;\n\n\nElement.innerHTML后面加东西了就是改变，不加东西就是读取。\n\nElement.innerText - 设置页面内容innerText和innerHTML类似，不同的是innerText无法识别元素，会直接渲染成字符串\nElement获取元素位置\n\n\n属性\n描述\n\n\n\nclientHeight\n获取元素高度包括padding部分，但是不包括border、margin\n\n\nclientWidth\n获取元素宽度包括padding部分，但是不包括border、margin\n\n\nscrollHeight\n元素总高度，它包括padding，但是不包括border、margin包括溢出的不可见内容\n\n\nscrollWidth\n元素总宽度，它包括padding，但是不包括border、margin包括溢出的不可见内容\n\n\nscrollLeft\n元素的水平滚动条向右滚动的像素数量\n\n\nscrollTop\n元素的垂直滚动条向下滚动的像素数量\n\n\noffsetHeight\n元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border\n\n\noffsetWidth\n元素的 CSS 水平宽度（单位像素），包括元素本身的高度、padding 和 border\n\n\noffsetLeft\n到定位父级左边界的间距\n\n\noffsetTop\n到定位父级上边界的间距\n\n\nElement.clientHeight，Element.clientWidth - 获取元素高度&#x2F;宽度Element.clientHeight属性返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回0。如果块级元素没有设置 CSS 高度，则返回实际高度\n除了元素本身的高度，它还包括padding部分，但是不包括border、margin。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。\nElement.clientWidth属性返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和padding，如果有垂直滚动条，还要减去垂直滚动条的宽度。\ndocument.documentElement的clientHeight属性，返回当前视口的高度（即浏览器窗口的高度）。document.body的高度则是网页的实际高度。\n// 视口高度 -&gt;页面撑起来的总高度document.documentElement.clientHeight// 网页总高度document.body.clientHeight\n\nElement.scrollHeight，Element.scrollWidth - 元素总高&#x2F;宽度Element.scrollHeight属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），它包括padding，但是不包括border、margin以及水平滚动条的高度（如果有水平滚动条的话）\nElement.scrollWidth属性表示当前元素的总宽度（单位像素），其他地方都与scrollHeight属性类似。这两个属性只读\n整张网页的总高度可以从document.documentElement或document.body上读取\n// 返回网页的总高度document.documentElement.scrollHeightdocument.body.scrollHeight\n\nElement.scrollLeft，Element.scrollTop - 元素水平&#x2F;垂直滚动的距离Element.scrollLeft属性表示当前元素的水平滚动条向右侧滚动的像素数量，Element.scrollTop属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0\n如果要查看整张网页的水平的和垂直的滚动距离，要从document.documentElement元素上读取\ndocument.documentElement.scrollLeftdocument.documentElement.scrollTop\n\nElement.offsetHeight，Element.offsetWidth - 元素css垂直&#x2F;水平高度Element.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。\nElement.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。\n这两个属性都是只读属性，只比Element.clientHeight和Element.clientWidth多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如display: none;），则返回0\nElement.offsetLeft，Element.offsetTop - 定位父级左&#x2F;上边界的间距Element.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移，Element.offsetTop返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移\n&lt;div class=&quot;parent&quot;&gt;    &lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.parent&#123;    width: 200px;    height: 200px;    background: red;    position: relative;    left: 50px;    top: 50px;&#125;.box&#123;    width: 100px;    height: 100px;    background: yellow;    position: relative;    left: 50px;    top: 50px;&#125;\n\nvar box = document.getElementById(&quot;box&quot;);console.log(box.offsetLeft);console.log(box.offsetTop);\n\ncss操作HTML元素的style属性操作css样式最简单的方法，就是使用网页元素节点的setAttribute方法直接操作网页元素的style属性\ndiv.setAttribute(&#x27;style&#x27;,&#x27;background-color:red;&#x27;+&#x27;border:1px solid black;&#x27;);\n\n\n两个参数，样式和属性。\n\n元素节点的style属性var divStyle = document.querySelector(&#x27;div&#x27;).style;divStyle.backgroundColor = &#x27;red&#x27;;divStyle.border = &#x27;1px solid black&#x27;;divStyle.width = &#x27;100px&#x27;;divStyle.height = &#x27;100px&#x27;;divStyle.fontSize = &#x27;10em&#x27;;........var divStyle = document.querySelector(&#x27;div&#x27;);divStyle.style.backgroundColor= &#x27;red&#x27;;\n\ncssText属性var divStyle = document.querySelector(&#x27;div&#x27;).style;divStyle.cssText = &#x27;background-color: red;&#x27;  + &#x27;border: 1px solid black;&#x27;  + &#x27;height: 100px;&#x27;  + &#x27;width: 100px;&#x27;;......var divStyle = document.querySelector(&#x27;div&#x27;);divStyle.style.cssText= &#x27;background-color: red;&#x27;  + &#x27;border: 1px solid black;&#x27;  + &#x27;height: 100px;&#x27;  + &#x27;width: 100px;&#x27;;\n\n事件处理程序事件处理程序分为：\n\nHTML事件处理\nDOM0级事件处理\nDOM2级事件处理\n\nHTML事件&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head lang=&quot;en&quot;&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Js事件详解--事件处理&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;div&quot;&gt;            &lt;button id=&quot;btn1&quot; onclick=&quot;demo()&quot;&gt;按钮&lt;/button&gt;        &lt;/div&gt;        &lt;script&gt;            function demo()&#123;                alert(&quot;hello html事件处理&quot;);            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt; \n\n\nonclick代表点击事件。缺点HTML和js没有分开。\n\nDOM0级事件处理&lt;body&gt;    &lt;div id=&quot;div&quot;&gt;        &lt;button id=&quot;btn1&quot;&gt;按钮&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        var btn1=document.getElementById(&quot;btn1&quot;);        btn1.onclick=function()&#123;alert(&quot;Hello DOM0级事件处理程序1&quot;);&#125;//被覆盖掉        btn1.onclick=function()&#123;alert(&quot;Hello DOM0级事件处理程序2&quot;);&#125;    &lt;/script&gt;&lt;/body&gt;\n\n\n优点：HTML与js分开了。缺点：无法同时添加事件。\n\nDOM2级事件处理&lt;body&gt;    &lt;div id=&quot;div&quot;&gt;        &lt;button id=&quot;btn1&quot;&gt;按钮&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        var btn1=document.getElementById(&quot;btn1&quot;);        btn1.addEventListener(&quot;click&quot;,demo1);        btn1.addEventListener(&quot;click&quot;,demo2);        btn1.addEventListener(&quot;click&quot;,demo3);        function demo1()&#123;            alert(&quot;DOM2级事件处理程序1&quot;)        &#125;        function demo2()&#123;            alert(&quot;DOM2级事件处理程序2&quot;)        &#125;        function demo3()&#123;            alert(&quot;DOM2级事件处理程序3&quot;)        &#125;        btn1.removeEventListener(&quot;click&quot;,demo2);    &lt;/script&gt;&lt;/body&gt;\n\n\n优点：不会被覆盖。缺点：写起来麻烦。\n\n事件类型鼠标事件鼠标事件指与鼠标相关的事件，具体的事件主要有以下一些\n\nclick：按下鼠标时触发\ndblclick：在同一个元素上双击鼠标时触发\nmousedown：按下鼠标键时触发\nmouseup：释放按下的鼠标键时触发\nmousemove：当鼠标在节点内部移动时触发。当鼠标持续移动时，该事件会连触发。\nmouseenter：鼠标进入一个节点时触发，进入子节点不会触发这个事件\nmouseleave：鼠标离开一个节点时触发，离开父节点不会触发这个事件\nmouseover：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件\nmouseout：鼠标离开一个节点时触发，离开父节点也会触发这个事件\nwheel：滚动鼠标的滚轮时触发\n\n例：\nvar btn1 = document.getElementById(&quot;btn1&quot;);btn1.onclick = function()&#123;    console.log(&quot;click事件&quot;);&#125;\n\n\n一般事件前都会加一个前缀on除了DOM2级事件。比如onclick(按下鼠标时触发)。\n\nEvent事件对象事件发生以后，会产生一个事件对象，作为参数传给监听函数。\nEvent对象属性：\n\nEvent.Target\nEvent.type\n\nEvent对象方法：\n\nEvent.preventDefault()\nEvent.stopPropagation()\n\nEvent.Target - 获取点击内容Event.Target属性返回事件当前所在的节点。\n例:\n// HTML代码为// &lt;p id=&quot;para&quot;&gt;Hello&lt;/p&gt;function setColor(event) &#123;  console.log(this === event.target);  event.target.style.color = &#x27;red&#x27;;&#125;para.addEventListener(&#x27;click&#x27;, setColor);\n\n\n默认有一个参数。\n\nEvent.type - 获得事件类型Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读\nEvent.preventDefault - 阻止默认行为Event.preventDefault方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了\nbtn.onclick = function(e)&#123;    e.preventDefault(); // 阻止默认事件    console.log(&quot;点击A标签&quot;);&#125;\n\nEvent.stopPropagation() - 阻止事件冒泡stopPropagation方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数\nbtn.onclick = function(e)&#123;    e.stopPropagation(); // 阻止事件冒泡    console.log(&quot;btn&quot;);&#125;\n\n\n事件冒泡是指当子元素触发后向上(父元素)传递，导致父元素也触发。\n\n键盘事件键盘事件主要有：\n\nkeydown：按下键盘时触发。\nkeypress：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发keydown事件，再触发这个事件。\nkeyup：松开键盘时触发该事件。\n\n例：\n&lt;input id=&quot;username&quot;&gt;username.onkeypress = function(e)&#123;    console.log(&quot;keypress事件&quot;);&#125;\n\n\ne.target.value是获取输入框内的内容。当鼠标点击输入框后先读取空，输入后再继续读取数据。获取输入框内文件一般是用keyup属性。\n\nkeyCode - 唯一标识var username = document.getElementById(&quot;username&quot;);username.onkeydown = function(e)&#123;    if(e.keyCode === 13)&#123;        console.log(&quot;回车&quot;);    &#125;&#125;\n\n表单事件表单事件是在使用表单元素及输入框元素可以监听的一系列事件。\n\ninput事件\nselect事件\nChange事件\nreset事件\nsubmit事件\n\ninput事件input事件当&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;的值发生变化时触发。对于复选框（&lt;input type=checkbox&gt;）或单选框（&lt;input type=radio&gt;），用户改变选项时，也会触发这个事件\ninput事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次input事件。\nvar username = document.getElementById(&quot;username&quot;);username.oninput = function(e)&#123;    console.log(e.target.value);&#125;\n\nselect事件select事件当在&lt;input&gt;、&lt;textarea&gt;里面选中文本时触发\n// HTML 代码如下// &lt;input id=&quot;test&quot; type=&quot;text&quot; value=&quot;Select me!&quot; /&gt;var elem = document.getElementById(&#x27;test&#x27;);elem.addEventListener(&#x27;select&#x27;, function (e) &#123;  console.log(e.type); // &quot;select&quot;&#125;, false);\n\nChange事件Change事件当&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;的值发生变化时触发。它与input事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发\nvar email = document.getElementById(&quot;email&quot;);email.onchange = function(e)&#123;    console.log(e.target.value);&#125;\n\n\n失去焦点或者回车后触发。\n\nreset()事件，submit事件这两个事件发生在表单对象&lt;form&gt;上，而不是发生在表单的成员上。\nreset事件当表单重置（所有表单成员变回默认值）时触发。\nsubmit事件当表单数据向服务器提交时触发。注意，submit事件的发生对象是&lt;form&gt;元素，而不是&lt;button&gt;元素，因为提交的是表单，而不是按钮\n&lt;form id=&quot;myForm&quot; onsubmit=&quot;submitHandle&quot;&gt;    &lt;button onclick=&quot;resetHandle&quot;&gt;重置数据&lt;/button&gt;    &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;\n\nvar myForm = document.getElementById(&quot;myForm&quot;)function resetHandle()&#123;    myForm.reset();&#125;function submitHandle()&#123;    console.log(&quot;提交&quot;);&#125;\n\n\nonsubmit写在form属性里。要把表单文件提交给服务器，不仅需要onsubmit还需要input里设置name属性。\n\n事件代理(事件委托)由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。\nvar ul = document.querySelector(&#x27;ul&#x27;);ul.addEventListener(&#x27;click&#x27;, function (event) &#123;  if (event.target.tagName.toLowerCase() === &#x27;li&#x27;) &#123;    // some code  &#125;&#125;);\n\n\ne.target.tagName获取标签名。event.target.tagName.toLowerCase()标签名转化为小写的。\n\n定时器JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。\nsetTimeout - 指定时间执行任务setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。\n语法：\nvar timerId = setTimeout(func|code, delay);\n\nsetTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数\n例：\nsetTimeout(function()&#123;    console.log(&quot;定时器&quot;)&#125;,1000)\n\n\n还有一个需要注意的地方，如果回调函数是对象的方法，那么setTimeout使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象。\n\n定时器可以进行取消的。\n例：\nvar id = setTimeout(f, 1000);clearTimeout(id);\n\n\n在setTimeout第一个参数中函数不用写括号，要是写括号就直接执行了，如果要使用有参数的函数，可以直接在setTimeout里创建(亲测)。\n\nsetInterval() - 无限执行的定时器setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。\nvar timer = setInterval(function() &#123;  console.log(2);&#125;, 1000)\n\n定时器进行取消：\nvar id = setInterval(f, 1000);clearInterval(id);\n\n防抖防抖严格算起来应该属于性能优化的知识，但实际上遇到的频率相当高，处理不当或者放任不管就容易引起浏览器卡死。\n防抖定义：\n对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次\n从滚动条监听的例子：\nfunction showTop  () &#123;    var scrollTop = document.documentElement.scrollTop;    console.log(&#x27;滚动条位置：&#x27; + scrollTop);&#125;//滚动事件- 当页面侧边栏滚动时触发的事件window.onscroll  = showTop\n\n面对触发次数过多的情况，可以在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms，然后\n\n如果在200ms内没有再次触发滚动事件，那么就执行函数\n如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时\n\n效果：如果短时间内大量触发同一事件，只会执行一次函数\n实现：既然前面都提到了计时，那实现的关键就在于setTimeout这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现。\n例：\nfunction debounce(fn,delay)&#123;    var timer = null //借助闭包    return function() &#123;        if(timer)&#123;            clearTimeout(timer)         &#125;        timer = setTimeout(fn,delay) // 简化写法    &#125;&#125;// 然后是旧代码function showTop  () &#123;    var scrollTop = document.documentElement.scrollTop;    console.log(&#x27;滚动条位置：&#x27; + scrollTop);&#125;window.onscroll = debounce(showTop,300)\n\n节流节流严格算起来应该属于性能优化的知识，但实际上遇到的频率很高，处理不当或者放任不管就容易引起浏览器卡死。\n在一直触发事件时，在规定时间内固定触发事件。\n例：\nfunction throttle(fn,delay)&#123;    var valid = true    return function() &#123;       if(!valid)&#123;           //休息时间 暂不接客           return false        &#125;       // 工作时间，执行函数并且在间隔期内把状态位设为无效        valid = false        setTimeout(function()&#123;            fn()            valid = true;        &#125;, delay)    &#125;&#125;function showTop  () &#123;    var scrollTop = document.documentElement.scrollTop;    console.log(&#x27;滚动条位置：&#x27; + scrollTop);&#125;window.onscroll = throttle(showTop,300) \n\n应用场景:\n\n搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求\n页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况）\n\nES6命令行工具CMD命令行\n打开命令行窗口\nwin：左下角开始，找到运行，点击，输入cmd，回车\nwin：win+r 快速打开命令行窗口\nmac：command + 空格，输入terminal\n\n\n选择盘符：盘符名加冒号E:\n查看盘符及目录下文件与文件夹：win:dir   mac:ls\n清空命令行信息：win:cls  mac:clear\n进入文件夹或目录：cd  文件夹名称\n返回到上一级目录：cd ../\n快速补全目录或文件夹名称：tab\n创建文件夹：mkdir 文件夹名称\n查看历史输入过的命令：上下按键\n\nPowerShell\n打开方式\n在开始位置搜索PowerShell打开\n在对应目录按住shift+右键，打开\n\n\n其他保持一致\n\nES6简介ECMAScript 和 JavaScript 的关系ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现，常场合，这两个词是可以互换的。\n名称详解ECMAScript 6（以下简称 ES6）是 JavaScript 语言的标准，在 2015 年 6 月发布。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n\n\n版本\n官方名称\n发布日期\n\n\n\nES1\nECMAScript 1\n1997\n\n\nES2\nECMAScript 2\n1998\n\n\nES3\nECMAScript 3\n1999\n\n\nES4\nECMAScript 4\n从未发布过\n\n\nES5\nECMAScript 5\n2009\n\n\nES5.1\nECMAScript 5.1\n2011\n\n\nES6\nECMAScript 2015（ECMAScript 6）\n2015\n\n\nES7\nECMAScript 2016\n2016\n\n\nES8\nECMAScript 2017\n2017\n\n\n…\n…\n…\n\n\n因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等\n语法提案的批准流程任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。\n一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。\n\nStage 0 - Strawman（展示阶段）\nStage 1 - Proposal（征求意见阶段）\nStage 2 - Draft（草案阶段）\nStage 3 - Candidate（候选人阶段）\nStage 4 - Finished（定案阶段）\n\n一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站GitHub.com&#x2F;tc39&#x2F;ecma262查看。\nES6带来的新特性\nlet 和 const 命令\n变量的解构赋值\n字符串扩展\n函数扩展\n对象扩展\n数组扩展\n运算符扩展\nPromise对象\nClass\nClass 继承\n…\n\nNodejs安装Nodejs官网 https://nodejs.org/en/\nNodejs的安装与一般软件一样\n大量的库在安装Nodejs的同时，会附带一个npm命令，npm 是Node的包管理工具，这样正是接下来我们要用到的\nnpm 的简单结构有助于 Node.js 生态系统的激增，现在 npm 仓库托管了超过 1,000,000 个可以自由使用的开源库包\nnpm镜像由于服务器在国外，所以下载速度比较慢，我们可以用国内的镜像\n阿里镜像地址https://npmmirror.com/\n在命令行运行如下命令即可\nnpm install -g cnpm --registry=https://registry.npmmirror.com\n\nBabel转码器Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持\n浏览器支持性查看https://caniuse.com/\nBabel官网https://babeljs.io/\n转码示例原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了\n// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123;  return item + 1;&#125;);\n\nBabel安装流程第一步：安装 Babelnpm install --save-dev @babel/core\n\n第二步：配置文件.babelrcBabel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。\n该文件用来设置转码规则和插件，基本格式如下\n&#123;  &quot;presets&quot;: [],  &quot;plugins&quot;: []&#125;\n\n第三步：转码规则presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装\nnpm install --save-dev @babel/preset-env\n\n第四步：将规则加入.babelrc&#123;    &quot;presets&quot;: [      &quot;@babel/env&quot;    ],    &quot;plugins&quot;: []&#125;\n\nBabel命令行转码Babel 提供命令行工具@babel/cli，用于命令行转码\nnpm install --save-dev @babel/cli\n\n基本用法如下\n# 转码结果输出到标准输出$ npx babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ npx babel example.js --out-file compiled.js# 或者$ npx babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ npx babel src --out-dir lib# 或者$ npx babel src -d lib\n\nlet命令es6新增命令，用来声明变量。他的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。\nvar与let的不同：\n\nvar关键字是函数级作用域\nlet是块级作用域\nlet不能变量提升\nlet不能重复声明\n\nConst命令const常量：\n\n声明后不允许改变\nconst不允许重新赋值\nconst必须初始化\nconst是块级作用域\nconst不存在变量提升\nconst不能重复声明(类型不同，名字相同)\n\n对象解构赋值解构可以用于对象\n语法：\nconst &#123;name,age&#125; = &#123;name:&quot;iwen&quot;,age:20&#125;;\n\n对象的属性没有次序，变量必须与属性同名，才能取到正确的值\nconst &#123;age,name&#125; = &#123;name:&quot;iwen&quot;,age:20&#125;;age // 20\n\n对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量\nconst &#123; random,floor &#125; = Math;const &#123; log &#125; = console;log(floor());\n\n注意事项，如果要将一个已经声明的变量用于解构赋值，必须非常小心\nconst hello = &quot;Hello&quot;;const &#123; hello &#125; = &#123;hello:&quot;hello&quot;&#125;; // 报错const hello = &quot;Hello&quot;;(&#123; hello &#125; = &#123;hello:&quot;hello&quot;&#125;); // 正确 - 尽量不用\n\n字符串扩展字符串Unicode 表示法ES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。\nUnicode统一码（Unicode），也叫万国码、单一码，是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。\n&quot;\\u0061&quot;// &quot;a&quot;\n\n字符串遍历器接口for...of循环遍历\nfor (let i of &#x27;itbaizhan&#x27;) &#123;  console.log(i);&#125;\n\n模板字符串模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\nlet url = &quot;www.itbaizhan.com&quot;let h1 = &quot;&lt;a href=&#x27;&quot;+ url +&quot;&#x27;&gt;itbaizhan&lt;/a&gt;&quot;let h2 = `&lt;a href=&#x27;$&#123;url&#125;&#x27;&gt;itbaizhan&lt;/a&gt;`\n\n\n${url}表示变量的意思\n\n字符串新增方法includes(), startsWith(), endsWith() - 查找字符串传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。\n\nincludes()：返回布尔值，表示是否找到了参数字符串\nstartsWith()：返回布尔值，表示参数字符串是否在原字符串的头部\nendsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部\n\nlet s = &#x27;Hello world!&#x27;;s.startsWith(&#x27;Hello&#x27;) // trues.endsWith(&#x27;!&#x27;) // trues.includes(&#x27;o&#x27;) // true\n\n这三个方法都支持第二个参数，表示开始搜索的位置\nlet s = &#x27;Hello world!&#x27;;s.startsWith(&#x27;world&#x27;, 6) // trues.endsWith(&#x27;Hello&#x27;, 5) // trues.includes(&#x27;Hello&#x27;, 6) // false\n\nrepeat() - 将原字符串重复n次repeat方法返回一个新字符串，表示将原字符串重复n次。\n&#x27;x&#x27;.repeat(3) // &quot;xxx&quot;&#x27;hello&#x27;.repeat(2) // &quot;hellohello&quot;&#x27;na&#x27;.repeat(0) // &quot;&quot;\n\npadStart()，padEnd() - 长度补全ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。\n&#x27;x&#x27;.padStart(5, &#x27;ab&#x27;) // &#x27;ababx&#x27;&#x27;x&#x27;.padStart(4, &#x27;ab&#x27;) // &#x27;abax&#x27;&#x27;x&#x27;.padEnd(5, &#x27;ab&#x27;) // &#x27;xabab&#x27;&#x27;x&#x27;.padEnd(4, &#x27;ab&#x27;) // &#x27;xaba&#x27;\n\ntrimStart()，trimEnd() - 去掉空格ES2019对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\nconst s = &#x27;  itbaizhan  &#x27;;s.trim() // &quot;itbaizhan&quot;s.trimStart() // &quot;itbaizhan  &quot;s.trimEnd() // &quot;  itbaizhan&quot;\n\nat() - 返回指定位置字符at()方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）。\nconst str = &#x27;hello&#x27;;str.at(1) // &quot;e&quot;str.at(-1) // &quot;o&quot;\n\n\n如果参数位置超出了字符串范围，at()返回undefined\n\n数组扩展扩展运算符扩展运算符（spread）是三个点（...）。将一个数组转为用逗号分隔的参数序列\nconsole.log(...[1, 2, 3])//arr=[1, 2, 3];-&gt;console.log(...arr)// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5\n\n替代函数的 apply 方法\n由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。\n// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77);\n\n合并数组\n扩展运算符提供了数组合并的新写法\nconst arr1 = [&#x27;a&#x27;, &#x27;b&#x27;];const arr2 = [&#x27;c&#x27;];const arr3 = [&#x27;d&#x27;, &#x27;e&#x27;];// ES5 的合并数组arr1.concat(arr2, arr3);// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]\n\n新增方法Array.from() - 将类数组转化为数组Array.from方法用于将类数组转为真正的数组\n常见的类数组有三类：\n\narguments\n元素集合\n类似数组的对象\n\narguments - 类数组function add()&#123;    let collect = Array.from(arguments);    collect.push(40);    console.log(collect);&#125;add(10,20,30)\n\n\n原本add函数是没有参数的，但是传进去参数了可以用argument获得。类数组，伪数组，只能使用数组的读取方式和length属性，不能使用数组方法。\n\n元素集合 - HTML元素集合let divs = document.querySelectorAll(&#x27;div&#x27;);console.log(Array.from(divs));\n\n类似数组的对象 - 看起来像数组，实则是对象let arrayLike = &#123;    &#x27;0&#x27;: &#x27;a&#x27;,    &#x27;1&#x27;: &#x27;b&#x27;,    &#x27;2&#x27;: &#x27;c&#x27;,    length: 3&#125;;let arr = Array.from(arrayLike);console.log(arr);\n\nArray.of() - 将一组值转化为数组Array.of()方法用于将一组值，转换为数组\nArray.of(3, 11, 8) // [3,11,8]\n\n\nArray(3)是开辟了三个数组空间，并非是把三放进数组内。\n\n对象的扩展属性的简洁表示法ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n//属性名与变量名相同，即可省略。let name = &quot;iwen&quot;const user = &#123;    name,    age:20&#125;\n\n除了属性简写，方法也可以简写\nconst o = &#123;  method() &#123;    return &quot;Hello!&quot;;  &#125;&#125;;// 等同于const o = &#123;  method: function() &#123;    return &quot;Hello!&quot;;  &#125;&#125;;\n\n这种写法用于函数的返回值，将会非常方便\nfunction getPoint() &#123;  const x = 1;  const y = 10;  return &#123;x, y&#125;;&#125;getPoint() // &#123;x:1, y:10&#125;\n\n属性名表达式ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内\nlet propKey = &#x27;itbaizhan&#x27;;let obj = &#123;  [propKey]: true,  [&#x27;a&#x27; + &#x27;bc&#x27;]: 123&#125;;\n\n对象的扩展运算符ES2018 将这个运算符引入了对象\nlet z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;console.log(n);&#123;...&#123;&#125;, a: 1&#125;// &#123; a: 1 &#125;\n\n函数的扩展箭头函数ES6 允许使用“箭头”（=&gt;）定义函数\n基本用法：\nvar add = x =&gt; x;// 等同于-&gt;赋值型声明函数var add = function (x) &#123;    return x;&#125;;\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分\nvar add = (x,y) =&gt; x+y;// 等同于var add = function (x,y) &#123;    return x+y;&#125;;var add = () =&gt; 100;// 等同于var add = function () &#123;    return 100;&#125;;\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回\nvar add = (x,y) =&gt; &#123;    var z = 10;    return x+y+z&#125;;// 等同于var add = function (x,y) &#123;    var z = 10    return x+y+z&#125;;\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\nvar add = (x,y) =&gt; (&#123;x:10,y:20&#125;);\n\n箭头函数的一个用处是简化回调函数（匿名函数）\nvar arr = [10,20,30]arr.map(item =&gt;&#123;    console.log(item);&#125;)\n\n对于普通函数来说，内部的this指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的this对象，内部的this就是定义时上层作用域中的this\nvar name = &quot;itbaizhan&quot;var user = &#123;    name:&quot;iwen&quot;,    getName()&#123;        setTimeout(() =&gt;&#123;            console.log(this.name); // iwen        &#125;)    &#125;&#125;user.getName()\n\n\n箭头函数里面根本没有自己的this，而是引用外层的this\n\nSet 数据结构ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成 Set 数据结构。\n基本用法\nconst s = new Set();//要有new[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));//forEach是一种遍历方案for (let i of s) &#123;  console.log(i);&#125;// 2 3 5 4\n\n通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\nSet函数可以接受一个数组作为参数\nconst set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]\n\n数组去除重复成员的方法\n// 去除数组的重复成员[...new Set(array)]\n\n字符串去除重复字符\n[...new Set(&#x27;ababbc&#x27;)].join(&#x27;&#x27;)// &quot;abc&quot;\n\n向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。\nvar mySet = new Set();mySet.add(&quot;5&quot;)mySet.add(5)console.log(mySet); // Set(2) &#123;&#x27;5&#x27;, 5&#125;\n\nsize属性返回Set实例的成员总数\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5\n\nSet数据结构方法add() - 添加set 添加方法\nvar mySet = new Set();mySet.add(&quot;5&quot;)console.log(mySet); \n\ndelete() - 删除删除某个值，返回一个布尔值，表示删除是否\nvar mySet = new Set();mySet.add(&quot;5&quot;)var flag = mySet.delete(&quot;5&quot;);console.log(flag);  // true\n\nhas() - 判断返回一个布尔值，表示该值是否为Set的成员\nvar mySet = new Set();mySet.add(&quot;5&quot;)var flag = mySet.has(&quot;5&quot;);console.log(flag);  // true\n\nclear() - 清空清除所有成员，没有返回值\nvar mySet = new Set();mySet.add(&quot;5&quot;)mySet.clear();console.log(mySet);  // Set(0) &#123;size: 0&#125;\n\nPromise基本概念：\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易\n基本用法：\nES6 规定，Promise对象是一个构造函数，用来生成Promise实例\nconst promise = new Promise(function(resolve, reject) &#123;  // ... some code  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);\n\n\n构造函数是需要用new来构造的。\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署\nPromise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\npromise.then(function(value) &#123;  // success&#125;, function(error) &#123;  // failure&#125;);\n\n加载图片资源例子：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        function loadImageAsync(url) &#123;            var promise = new Promise(function (resolve, reject) &#123;                const image = new Image();//创建image对象                image.src = url;//数据加载                image.onload = function () &#123;//成功                    resolve(image);                &#125;;                image.onerror = function () &#123;//失败                    reject(new Error(&#x27;Could not load image at &#x27; + url));                &#125;;            &#125;);            return promise;        &#125;        loadImageAsync(&quot;http://iwenwiki.com/api/vue-data/vue-data-1.png&quot;)        .then(function(data)&#123;//成功函数            console.log(data);            $(&quot;div&quot;).append(data)        &#125;,function(error)&#123;//失败2函数            $(&quot;div&quot;).html(error)        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nPromise对象_Ajax实操Promise封装Ajax，让网络请求的异步操作变得更简单\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        const getJSON = function (url) &#123;            const promise = new Promise(function (resolve, reject) &#123;                const handler = function () &#123;                    if (this.readyState !== 4) &#123;                        return;                    &#125;                    if (this.status === 200) &#123;                        resolve(this.response);                    &#125; else &#123;                        reject(new Error(this.statusText));                    &#125;                &#125;;                const client = new XMLHttpRequest();                client.open(&quot;GET&quot;, url);                client.onreadystatechange = handler;                client.responseType = &quot;json&quot;;                client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);                client.send();            &#125;);            return promise;        &#125;;            getJSON(&quot;http://iwenwiki.com/api/blueberrypai/getIndexBanner.php&quot;).then(function (json) &#123;            console.log(json);        &#125;, function (error) &#123;            console.error(&#x27;出错了&#x27;, error);        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nAsync函数 - 异步操作变同步async函数可以将异步操作变为同步操作\n例：\n//出现的问题function print()&#123;    setTimeout(() =&gt;&#123;        console.log(&quot;定时器&quot;);    &#125;,1000)    console.log(&quot;Hello&quot;);&#125;print()\n\n基本语法：\n//用async解决的function timeout(ms) &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(resolve, ms);  &#125;);&#125;async function asyncPrint(value, ms) &#123;//async放在函数前  await timeout(ms);//异步操作函数前写await  console.log(value);&#125;asyncPrint(&#x27;hello world&#x27;, 50);\n\n\n在promise中如果函数不调用resolve或者reject是不会结束的。\n\n异步应用function ajax(url)&#123;    return new Promise(function(resolve,reject)&#123;        $.getJSON(url,function(result)&#123;            resolve(result)        &#125;,function(error)&#123;            reject(error)         &#125;)    &#125;)&#125;async function getInfo()&#123;    let ids = await ajax(&quot;http://iwenwiki.com/api/generator/list.php&quot;)    let names = await ajax(&quot;http://iwenwiki.com/api/generator/id.php?id=&quot;+ids[0])    let infos = await ajax(&quot;http://iwenwiki.com/api/generator/name.php?name=&quot; + names.name)    console.log(infos);&#125;getInfo();\n\n\nasync可以直接把promise数据读取出来，不需要.then了。\n\nclass的基本语法JavaScript 语言中，生成实例对象的传统方法是通过构造函数\nfunction Point(x, y) &#123;  this.x = x;  this.y = y;&#125;//在类里面添加函数的Point.prototype.toString = function () &#123;  return &#x27;(&#x27; + this.x + &#x27;, &#x27; + this.y + &#x27;)&#x27;;&#125;;var p = new Point(1, 2);\n\n\nfunction后面加名字，首字母大写就是类，首字母小写就是函数(Es5)。\n\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类\n基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已\nclass Point &#123;    //构造函数  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;  toString() &#123;    return &#x27;(&#x27; + this.x + &#x27;, &#x27; + this.y + &#x27;)&#x27;;  &#125;&#125;\n\nconstructor - 类的默认方法constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加\nclass Point &#123;&#125;// 等同于class Point &#123;  constructor() &#123;&#125;&#125;\n\n类的实例生成类的实例的写法，与 ES5 完全一样，也是使用new命令\nclass Point &#123;  // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3);\n\n\n类不存在变量提升（hoist），这一点与 ES5 完全不同函数(function)是可以提升的\n\nnew Foo(); // ReferenceErrorclass Foo &#123;&#125;\n\nclass属性与方法实例方法通过类的实例对象调用方法\nclass People&#123;    say()&#123;        console.log(&quot;Hello&quot;);    &#125;&#125;var p = new People();p.say()\n\n实例属性实例属性指的是类的实例对象可调用的属性\nclass People&#123;    constructor(name,age)&#123;        this.name = name;        this.age = age;    &#125;    say()&#123;        console.log(this.name,this.age);    &#125;&#125;var p = new People(&quot;iwen&quot;,20);p.say()console.log(p.name,p.age);\n\n静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”\nclass Person &#123;    static classMethod() &#123;        console.log(&quot;Hello&quot;);    &#125;&#125;Person.classMethod() // Hellovar p = new Person();p.classMethod() // p.classMethod is not a function\n\n\n注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。\n\nclass People &#123;    static getSay() &#123;        this.say();    &#125;    static say() &#123;        console.log(&#x27;hello&#x27;);    &#125;    say() &#123;        console.log(&#x27;world&#x27;);    &#125;&#125;People.getSay() // hello\n\n静态属性静态属性指的是 Class 本身的属性，即Class.propName\nclass People&#123;&#125;People.status = &quot;等待&quot;console.log(People.status);\n\nclass继承用法：\nClass 可以通过extends关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多\nclass Point &#123;&#125;class ColorPoint extends Point &#123;&#125;\n\nES6 规定，子类必须在constructor()方法中调用super()，否则就会报错，这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用super()方法，子类就得不到自己的this对象\n\nsuper一定发在第一行。\n\nclass Point &#123;    constructor(x,y)&#123;        this.x = x;        this.y = y;    &#125;    getPoint()&#123;        console.log(this.x,this.y);    &#125;&#125;class ColorPoint extends Point &#123;    constructor(x,y,z)&#123;        super(x,y)        this.z = z;    &#125;&#125;let cp = new ColorPoint(10,20,30)cp.getPoint();\n\nModule 的语法历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍\nES6 模块是通过export命令显式指定输出的代码，再通过import命令输入。\nexport var Hello = &quot;hello&quot; // hello.js文件import &#123; Hello &#125; from &quot;./hello.js&quot; // index.js文件\n\n测试方式我们采用Nodejs方式进行测试Module语法\n但是nodejs采用的是CommonJS的模块化规范，使用require引入模块；而import是ES6的模块化规范关键字。想要使用import，必须引入babel转义支持，通过babel进行编译，使其变成node的模块化代码。\n**疑惑：**为啥不用前端方式测试，前端方式测试会更加麻烦\n第一步：全局安装babel-cli npm install  -g babel-cli\n第二步：安装 babel-preset-env npm install -D babel-preset-env\n第三步：运行代码 babel-node --presets env index.js\nexport - 导出命令export命令导出变量\nexport var firstName = &#x27;sxt&#x27;;export var lastName = &#x27;itbaizhan&#x27;;export var year = 2000;\n\nexport命令导出函数\nexport function add(x, y) &#123;  return x + y;&#125;;\n\nimport - 导出命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块\n// name.jsexport var firstName = &#x27;sxt&#x27;;export var lastName = &#x27;itbaizhan&#x27;;export var year = 2000;// main.jsimport &#123; firstName, lastName, year &#125; from &#x27;./profile.js&#x27;;\n\n如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名\n// value.jsexport var value = 1;// main.jsimport &#123; value as val &#125; from &#x27;./value.js&#x27;;\n\n除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面\n// circle.jsexport function area(radius) &#123;  return Math.PI * radius * radius;&#125;export function circumference(radius) &#123;  return 2 * Math.PI * radius;&#125;// main.jsimport &#123; area, circumference &#125; from &#x27;./circle&#x27;;// 可以修改如下import * as circle from &#x27;./circle&#x27;;//调用是以对象的形式调用的\n\nexport default 命令从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\n// export-default.jsexport default function () &#123;  console.log(&#x27;foo&#x27;);&#125;\n\n\n一个文件中只能有一个export default\n\n其他模块加载该模块时，import命令可以为该匿名函数指定任意名字\n// import-default.jsimport customName from &#x27;./export-default&#x27;;customName(); // &#x27;foo&#x27;\n\nvue框架Vue是前端优秀框架， 是一套用于构建用户界面的渐进式框架\nvue网站\n安装Vue工具 Vue CLIVue CLI Vue.js 开发的标准工具，Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统\nnpm install -g @vue/cli\n\n安装之后，你就可以在命令行中访问 vue 命令。你可以通过简单运行 vue，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。\nvue --version\n\n创建一个项目运行以下命令来创建一个新项目\nvue create vue-demo\n\n\n在控制台中，可以用上下按键调整选择项在控制台中，可以用空格(spacebar)选择是否选中和取消选中名字中不能出现大写字母和空格\n\n可以选择默认项目模板，或者选“手动选择特性”来选取需要的特性。\n我们选择Babel和Progressive Web App (PWA) Support 两个选项即可\n\n在学习期间，不要选中 Linter / Formatter 以避免不必要的错误提示\n\nVue目前有两个主流大版本vue2和vue3，我们本套课程选择vue3最新版本\n配置放在哪里? In dedicated config files 专用配置文件或者 In package.json在package.json文件\n将其保存为未来项目的预置? y代表保存，并添加名字，n不保存\n运行项目第一步：进入项目根目录cd vue-demo\n第二步：运行npm run serve 启动项目\n\ncmd没关前进入网站http://localhost:8080/\n\n安装Vue高亮插件VSCode中安装vetur或者volar都可，前者针对Vue2版本，后者针对Vue3版本\n模板语法文本数据绑定最常见的形式就是使用“Mustache” (双大括号) 语法的文本插值\n&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;\n\n\n写完代码自动刷新，不用再手动刷新。\n\n一般配合js 中的data()设置数据\nexport default &#123;  name: &#x27;HelloWorld&#x27;,  data()&#123;    return&#123;      msg:&quot;消息提示&quot;    &#125;  &#125;&#125;\n\n原始 HTML双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用v-html指令\n&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n\ndata()&#123;    return&#123;        rawHtml:&quot;&lt;a href=&#x27;https://www.itbaizhan.com&#x27;&gt;百战&lt;/a&gt;&quot;    &#125;&#125;\n\n属性 AttributeMustache 语法不能在 HTML 属性中使用，然而，可以使用 v-bind 指令\n&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;\n\ndata()&#123;    return&#123;        dynamicId:1001    &#125;&#125;\n\n\nv-bind: 可以简写成 :\n\n使用 JavaScript 表达式在我们的模板中，我们一直都只绑定简单的 property 键值，Vue.js 都提供了完全的 JavaScript 表达式支持\n&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;\n\n这些表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。\n&lt;!--  这是语句，不是表达式：--&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流程控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;\n\n条件渲染v-if - 条件行选择一块渲染v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true 值的时候被渲染。\n&lt;p v-if=&quot;flag&quot;&gt;我是孙猴子&lt;/p&gt;\n\ndata() &#123;    return &#123;        flag: true    &#125;&#125;\n\nv-else - 是v-if的另一个选项你可以使用 v-else 指令来表示 v-if 的“else 块”\n&lt;p v-if=&quot;flag&quot;&gt;我是孙猴子&lt;/p&gt;&lt;p v-else&gt;你是傻猴子&lt;/p&gt;\n\ndata() &#123;    return &#123;        flag: false    &#125;&#125;\n\nv-show - 控制元素的显示另一个用于条件性展示元素的选项是 v-show 指令\n&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;\n\nv-if vs v-show 的区别v-if 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好\n列表渲染用 v-for 把一个数组映射为一组元素我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。\n&lt;ul&gt;    &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123; item.message &#125;&#125;&lt;/li&gt;&lt;/ul&gt;\n\ndata() &#123;    return &#123;        items: [&#123; message: &#x27;Foo&#x27; &#125;, &#123; message: &#x27;Bar&#x27; &#125;]    &#125;&#125;\n\n维护状态当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。\n为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的 key attribute：\n//index是下标索引，:key一定要有，当有唯一索引就之际填唯一索引，要是没有就填index&lt;div v-for=&quot;(item,index) in items&quot; :key=&quot;item.id|index&quot;&gt;  &lt;!-- 内容 --&gt;&lt;/div&gt;\n\n事件处理监听事件 - 添加事件我们可以使用 v-on 指令 (通常缩写为 @ 符号) 来监听 DOM 事件，并在触发事件时执行一些 JavaScript。用法为 v-on:click=&quot;methodName&quot; 或使用快捷方式 @click=&quot;methodName&quot;\n&lt;button @click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;\n\ndata() &#123;    return &#123;        counter: 0    &#125;&#125;\n\n事件处理方法然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。\n&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;\n\nmethods: &#123;    greet(event) &#123;        // `event` 是原生 DOM event        if (event) &#123;            alert(event.target.tagName)        &#125;    &#125;&#125;\n\n内联处理器中的方法这是官方的翻译称呼，其实我们可以直接叫他 “事件传递参数”\n&lt;button @click=&quot;say(&#x27;hi&#x27;)&quot;&gt;Say hi&lt;/button&gt;&lt;button @click=&quot;say(&#x27;what&#x27;)&quot;&gt;Say what&lt;/button&gt;\n\nmethods: &#123;    say(message) &#123;        alert(message)    &#125;&#125;\n\n表单输入绑定你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理。\n&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot; /&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;\n\ndata() &#123;    return &#123;        message:&quot;&quot;    &#125;&#125;\n\n修饰符.lazy - 与input数据进行同步在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 。你可以添加 lazy 修饰符，从而转为在 change 事件之后进行同步\n&lt;input v-model.lazy=&quot;message&quot; /&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;\n\ndata() &#123;    return &#123;        message:&quot;&quot;    &#125;&#125;\n\n.trim - 过滤首尾空格如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符\n&lt;input v-model.trim=&quot;message&quot; /&gt;\n\ndata() &#123;    return &#123;        message:&quot;&quot;    &#125;&#125;\n\n组件基础单文件组件Vue 单文件组件（又名 *.vue 文件，缩写为 SFC）是一种特殊的文件格式，它允许将 Vue 组件的模板、逻辑与样式封装在单个文件中\n&lt;template&gt;    &lt;h3&gt;单文件组件&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&quot;MyComponent&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;h3&#123;    color: red;&#125;&lt;/style&gt;\n\n加载组件第一步：引入组件 在app.vue中import MyComponentVue from &#39;./components/MyComponent.vue&#39;\n第二步：挂载组件 在下面的export default中components: &#123; MyComponentVue &#125;\n第三步：显示组件  在上面的template中&lt;my-componentVue /&gt;\n\n当在组件样式style中添加属性 scoped，表示当前样式只在当前组件中生效。import在template和script之间\n\n组件的组织通常一个应用会以一棵嵌套的组件树的形式来组织\nProps组件交互组件与组件之间是需要存在交互的，否则完全没关系，组件的意义就很小了\nProp 是你可以在组件上注册的一些自定义 attribute\n&lt;my-componentVue title=&quot;标题&quot;/&gt;\n\n&lt;template&gt;    &lt;h3&gt;单文件组件&lt;/h3&gt;    &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&quot;MyComponent&quot;,    props:&#123;        title:&#123;            type:String,            default:&quot;&quot;        &#125;    &#125;&#125;&lt;/script&gt;\n\n\n传递动态参数用:(vue-bind)\n\nProp 类型Prop传递参数其实是没有类型限制的\nprops: &#123;  title: String,  likes: Number,  isPublished: Boolean,  commentIds: Array,  author: Object,  callback: Function&#125;\n\n\n数据类型为数组或者对象的时候，默认值是需要返回工厂模式(函数)\n\n自定义事件组件交互自定义事件可以在组件中反向传递数据，prop 可以将数据从父组件传递到子组件，那么反向如何操作呢，就可以利用自定义事件实现 $emit\n&lt;template&gt;    &lt;h3&gt;单文件组件&lt;/h3&gt;    &lt;button @click=&quot;sendHandle&quot;&gt;发送数据&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &quot;MyComponent&quot;,    methods:&#123;        sendHandle()&#123;            this.$emit(&quot;onCustom&quot;,&quot;数据&quot;)        &#125;    &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h3 &#123;    color: red;&#125;&lt;/style&gt;\n\n&lt;template&gt;  &lt;my-componentVue @onCustom=&quot;getData&quot; /&gt;&lt;/template&gt;&lt;script&gt;import MyComponentVue from &#x27;./components/MyComponent.vue&#x27;export default &#123;  name: &#x27;App&#x27;,  components: &#123;    MyComponentVue  &#125;,  methods: &#123;    getData(data) &#123;      console.log(data);    &#125;  &#125;&#125;&lt;/script&gt;\n\n组件生命周期每个组件在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会\n为了方便记忆，我们可以将他们分类：\n创建时：beforeCreate、created\n渲染时：beforeMount、mounted\n更新时：beforeUpdate、updated\n卸载时：beforeUnmount、unmounted\n\n一般网络请求是在mounted(组件渲染完成)后进行的\n\nVue引入第三方Swiper 开源、免费、强大的触摸滑动插件\nSwiper 是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端\nSwiper 能实现触屏焦点图、触屏Tab切换、触屏轮播图切换等常用效果\n\n官方文档：https://swiperjs.com/vue安装指定版本: npm instal --save swiper@8.1.6\n\n基础实现&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;swiper class=&quot;mySwiper&quot;&gt;      &lt;swiper-slide&gt;Slide 1&lt;/swiper-slide&gt;      &lt;swiper-slide&gt;Slide 2&lt;/swiper-slide&gt;      &lt;swiper-slide&gt;Slide 3&lt;/swiper-slide&gt;    &lt;/swiper&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/vue&#x27;;import &#x27;swiper/css&#x27;;export default &#123;  name: &#x27;HelloWorld&#x27;,  components: &#123;    Swiper,    SwiperSlide,  &#125;&#125;&lt;/script&gt;\n\n添加指示器&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;swiper class=&quot;mySwiper&quot; :modules=&quot;modules&quot; :pagination=&quot;&#123; clickable: true &#125;&quot;&gt;      &lt;swiper-slide&gt;        &lt;img src=&quot;../assets/logo.png&quot; alt=&quot;&quot;&gt;      &lt;/swiper-slide&gt;      &lt;swiper-slide&gt;        &lt;img src=&quot;../assets/logo.png&quot; alt=&quot;&quot;&gt;      &lt;/swiper-slide&gt;      &lt;swiper-slide&gt;        &lt;img src=&quot;../assets/logo.png&quot; alt=&quot;&quot;&gt;      &lt;/swiper-slide&gt;    &lt;/swiper&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; Pagination &#125; from &#x27;swiper&#x27;;import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/vue&#x27;;import &#x27;swiper/css&#x27;;import &#x27;swiper/css/pagination&#x27;;export default &#123;  name: &#x27;HelloWorld&#x27;,  data()&#123;    return&#123;      modules: [ Pagination ]    &#125;  &#125;,  components: &#123;    Swiper,    SwiperSlide,  &#125;&#125;&lt;/script&gt;\n\nAxios网络请求Axios 是一个基于 promise 的网络请求库\n安装Axios的应用是需要单独安装的 npm install --save axios\n引入组件中引入: import axios from &quot;axios&quot;\n全局引用:\nimport axios from &quot;axios&quot;const app = createApp(App);app.config.globalProperties.$axios = axios//把axios挂载到全局后起个名字叫$axios，所以在组件中使用$axios即可app.mount(&#x27;#app&#x27;)// 在组件中调用this.$axios\n\n\n放在main.js文件中\n\n网络请求基本示例get请求axios(&#123;    method: &quot;get&quot;,    url: &quot;http://iwenwiki.com/api/blueberrypai/getChengpinDetails.php&quot;&#125;).then(res =&gt; &#123;    console.log(res.data);&#125;)\n\npost请求\npost请求参数是需要额外处理的\n\n安装依赖: npm install --save querystring\n转换参数格式: qs.stringify(&#123;&#125;)\n\n\naxios(&#123;    method:&quot;post&quot;,    url:&quot;http://iwenwiki.com/api/blueberrypai/login.php&quot;,    data:qs.stringify(&#123;        user_id:&quot;iwen@qq.com&quot;,        password:&quot;iwen123&quot;,        verification_code:&quot;crfvw&quot;    &#125;)&#125;).then(res =&gt;&#123;    console.log(res.data);&#125;)\n\n快捷方案get请求&gt;axios.get(&quot;http://iwenwiki.com/api/blueberrypai/getChengpinDetails.php&quot;)    .then(res =&gt;&#123;      console.log(res.data);    &#125;)\n\npost请求&gt;axios.post(&quot;http://iwenwiki.com/api/blueberrypai/login.php&quot;, qs.stringify(&#123;      user_id: &quot;iwen@qq.com&quot;,      password: &quot;iwen123&quot;,      verification_code: &quot;crfvw&quot;    &#125;))      .then(res =&gt; &#123;        console.log(res.data);      &#125;)\n\nAxios网络请求封装在日常应用过程中，一个项目中的网络请求会很多，此时一般采取的方案是将网络请求封装起来\n在src目录下创建文件夹utils，并创建文件request，用来存储网络请求对象 axios\nimport axios from &quot;axios&quot;import qs from &quot;querystring&quot;const errorHandle = (status,info) =&gt; &#123;    switch(status)&#123;        case 400:            console.log(&quot;语义有误&quot;);            break;        case 401:            console.log(&quot;服务器认证失败&quot;);            break;        case 403:            console.log(&quot;服务器拒绝访问&quot;);            break;        case 404:            console.log(&quot;地址错误&quot;);            break;        case 500:            console.log(&quot;服务器遇到意外&quot;);            break;        case 502:            console.log(&quot;服务器无响应&quot;);            break;        default:            console.log(info);            break;    &#125;&#125;const instance = axios.create(&#123;    //网络请求公用配置 - 访问超过5秒就不再访问了    timeout:5000&#125;)//拦截器//发送数据之前instance.interceptors.request.use(    config =&gt;&#123;//成功函数        if(config.method === &quot;post&quot;)&#123;            config.data = qs.stringify(config.data)        &#125;        return config;//config包含网络请求的所有信息    &#125;,    error =&gt; Promise.reject(error)//失败函数)//获取数据之前的另一个拦截器instance.interceptors.response.use(//相应对象    //判断是否成功接收数据并返回数据。    response =&gt; response.status === 200 ? Promise.resolve(response) : Promise.reject(response),    error =&gt;&#123;        const &#123; response &#125; = error;        errorHandle(response.status,response.info)//错误处理方案    &#125;)export default instance;\n\n在src目录下创建文件夹api，并创建文件index和path分别用来存放网络请求方法和请求路径\n// path.jsconst base = &#123;    baseUrl:&quot;http://iwenwiki.com&quot;,    chengpin:&quot;/api/blueberrypai/getChengpinDetails.php&quot;&#125;export default base\n\n// index.jsimport path from &quot;./path&quot;import axios from &quot;../utils/request&quot;export default &#123;    getChengpin()&#123;        return axios.get(path.baseUrl + path.chengpin)    &#125;&#125;\n\n在组件中直接调用网络请求\nimport api from &quot;../api/index&quot;api.getChengpin().then(res =&gt;&#123;    console.log(res.data);&#125;)\n\n\n可以借阅axios看云文档。\n\n网络请求跨域解决方案JS采取的是同源策略\n同源策略是浏览器的一项安全策略，浏览器只允许js 代码请求和当前所在服务器域名,端口,协议相同的数据接口上的数据,这就是同源策略.\n也就是说，当协议、域名、端口任意一个不相同时，都会产生跨域问题，所以又应该如何解决跨域问题呢\n跨域错误提示信息目前主流的跨域解决方案有两种\n后台解决：cors\n前台解决：proxy\n\ndevServer: &#123;    proxy: &#123;      &#x27;/api&#x27;: &#123;        target: &#x27;&lt;url&gt;&#x27;,//把产生跨域的地址放进去        changeOrigin: true      &#125;    &#125;&#125;\n\n\n解决完跨域配置之后，要记得重启服务器才行哦！\n\nVue引入路由配置在Vue中，我们可以通过vue-router路由管理页面之间的关系\nVue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举\n在Vue中引入路由 - router第一步：安装路由 npm install --save vue-router\n第二步：配置独立的路由文件\n// index.jsimport &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;import HomeView from &#x27;../views/HomeView.vue&#x27;const routes = [  &#123;    //path是必须有的属性    path: &#x27;/&#x27;,//第一个页面    name: &#x27;home&#x27;,    component: HomeView//要写出对应关系  &#125;,  &#123;    path: &#x27;/about&#x27;,//第二个页面    name: &#x27;about&#x27;,    component: () =&gt; import(&#x27;../views/AboutView.vue&#x27;)  &#125;]const router = createRouter(&#123;/** *  createWebHashHistory()跳转地址中有/# * 原理是a标签锚点 *  *  createWebHistory()跳转地址中没有/# * //这个方式需要在后台做重定向设置，否则会存在404问题 * 原理是h5的pushState */  history: createWebHashHistory(),  routes&#125;)export default router\n\n第三步：引入路由到项目\n// 在main.jsimport router from &#x27;./router&#x27;createApp(App).use(router)\n\n第四步：指定路由显示入口 &lt;router-view/&gt;&#x2F;&#x2F;在app.vue的template中添加\n第五步：指定路由跳转\n&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; |&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;\n\n路由传递参数页面跳转过程中，是可以携带参数的，这也是很常见的业务\n例如：在一个列表项，点击进入查看每个列表项的详情\n第一步：在路由配置中指定参数的key\n&#123;    path:&quot;/list/:name&quot;,// /:name代表key    name:&quot;list&quot;,    //这是异步显示流程，在没有加载的时候不会占用内存    component:() =&gt; import(&quot;../views/ListView.vue&quot;)&#125;\n\n第二步：在跳转过程中携带参数\n&lt;li&gt;&lt;router-link to=&quot;/list/内蒙&quot;&gt;内蒙旅游十大景区&lt;/router-link&gt;&lt;/li&gt;&lt;li&gt;&lt;router-link to=&quot;/list/北京&quot;&gt;北京旅游十大景区&lt;/router-link&gt;&lt;/li&gt;&lt;li&gt;&lt;router-link to=&quot;/list/四川&quot;&gt;四川旅游十大景区&lt;/router-link&gt;&lt;/li&gt;\n\n第三步：在详情页面读取路由携带的参数\n&lt;p&gt;&#123;&#123; $route.params.name &#125;&#125;城市旅游景区详情&lt;/p&gt;\n\n嵌套路由配置路由嵌套是非常常见的需求\n第一步：创建子路由要加载显示的页面\n第二步：在路由配置文件中添加子路由配置\n&#123;    path:&quot;/news&quot;,    name:&quot;news&quot;,    redirect:&quot;/news/baidu&quot;,    component:() =&gt; import(&quot;../views/NewsView.vue&quot;),    children:[//children代表配置二导航       &#123;        //二级导航的路径不要加 /            path:&quot;baidu&quot;,            component:() =&gt; import(&quot;../views/NewsList/BaiduNews.vue&quot;),       &#125;,       &#123;            path:&quot;wangyi&quot;,            component:() =&gt; import(&quot;../views/NewsList/WangyiNews.vue&quot;),       &#125;    ]&#125;\n\n第三步：指定子路由显示位置&lt;router-view&gt;&lt;/router-view&gt;\n第四步：添加子路由跳转链接\n&lt;router-link to=&quot;/news/baidu&quot;&gt;百度新闻&lt;/router-link&gt; //写全路径&lt;router-link to=&quot;/news/wangyi&quot;&gt;网易新闻&lt;/router-link&gt;\n\n第五步：重定向配置 redirect:&quot;/news/baidu&quot;&#x2F;&#x2F;在children父级上添加属性\nVue状态管理(Vuex)Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n简单来说，状态管理可以理解成为了更方便的管理组件之间的数据交互，提供了一个集中式的管理方案，任何组件都可以按照指定的方式进行读取和改变数据\n引入Vuex的步骤第一步：安装Vuex npm install --save vuex\n第二步：配置Vuex文件\nimport &#123; createStore &#125; from &#x27;vuex&#x27;export default createStore(&#123;//vuex核心作用就是帮助我们管理组件之间的状态  state: &#123;//所有状态都放在这里      counter:0  &#125;&#125;)\n\n第三步：在主文件中引入Vuex\nimport store from &#x27;./store&#x27; //在main.jscreateApp(App).use(store)\n\n第四步：在组件中读取状态\n&lt;p&gt;counter:&#123;&#123; $store.state.counter &#125;&#125;&lt;/p&gt;// 或者import &#123; mapState &#125; from &#x27;vuex&#x27;;computed:&#123;//专门用来读取vuex数据    ...mapState([&quot;counter&quot;])&#125;\n\nVue状态管理核心(Vuex)最常用的核心概念包含: State、Getter、Mutation、Action\ngetter - 对vuex中的数据进行过滤对Vuex中的数据进行过滤\nimport &#123; createStore &#125; from &#x27;vuex&#x27;export default createStore(&#123;  state: &#123;    counter: 0  &#125;,  getters: &#123;    getCount(state)&#123;      return state.counter &gt; 0 ? state.counter : &quot;counter小于0，不符合要求&quot;    &#125;  &#125;&#125;)\n\nimport &#123; mapState,mapGetters &#125; from &#x27;vuex&#x27;;computed:&#123;    ...mapGetters([&quot;getCount&quot;])&#125;\n\n\n放在vuex文件里面\n\nMutation - 更该vuex里的数据更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type)和一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数\nimport &#123; createStore &#125; from &#x27;vuex&#x27;export default createStore(&#123;  state: &#123;    counter: 0  &#125;,  getters: &#123;  &#125;,  mutations: &#123;    setCounter(state, num) &#123;      state.counter += num    &#125;  &#125;&#125;)\n\n//放在相应的组件里import &#123; mapState,mapMutations &#125; from &#x27;vuex&#x27;;methods:&#123;    ...mapMutations([&quot;setCounter&quot;]),    clickHandler()&#123;      // this.$store.commit(&quot;setCounter&quot;,20)-&gt;import &#123; mapState &#125; from &#x27;vuex&#x27;;      // 或者      // this.setCounter(10)-&gt;调用方式    &#125;&#125;\n\n\nmutations是需要通过事件调用的\n\nAction - 调用mutation更改vuex里的数据(异步)Action 类似于 mutation，不同在于：\n\nAction 提交的是 mutation，而不是直接变更状态\nAction 可以包含任意异步操作\n\nimport &#123; createStore &#125; from &#x27;vuex&#x27;import axios from &quot;axios&quot;export default createStore(&#123;  state: &#123;    counter: 0  &#125;,  getters: &#123;    getCount(state)&#123;      return state.counter &gt; 0 ? state.counter : &quot;counter小于0，不符合要求&quot;    &#125;  &#125;,  mutations: &#123;    setCounter(state, num) &#123;      state.counter += num    &#125;  &#125;,  actions: &#123;    asyncSetCount(&#123; commit &#125;)&#123;      axios.get(&quot;http://iwenwiki.com/api/generator/list.php&quot;)      .then(res =&gt;&#123;        commit(&quot;setCounter&quot;,res.data[0])      &#125;)    &#125;  &#125;&#125;)\n\nimport &#123; mapState,mapMutations,mapGetters,mapActions &#125; from &#x27;vuex&#x27;;methods:&#123;    ...mapActions([&quot;asyncSetCount&quot;]),    clickAsyncHandler()&#123;        // this.$store.dispatch(&quot;asyncSetCount&quot;)        // 或者        // this.asyncSetCount()    &#125;&#125;\n\nVue3新特性Vue3是目前Vue的最新版本，自然也是新增了很多新特性\n六大亮点\nPerformance：性能更比Vue 2.0强。\nTree shaking support：可以将无用模块“剪辑”，仅打包需要的。\nComposition API：组合API\nFragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念”\nBetter TypeScript support：更优秀的Ts支持\nCustom Renderer API：暴露了自定义渲染API\n\nref或者reactive在2.x中通过组件data的方法来定义一些当前组件的数据\ndata() &#123;  return &#123;    name: &#x27;iwen&#x27;,    list: [],  &#125;&#125;\n\n在3.x中通过ref或者reactive创建响应式对象\nimport &#123; ref,reactive &#125; from &quot;vue&quot;export default &#123;  name: &#x27;HelloWorld&#x27;,  setup()&#123;//在setup中声明的东西必须return  //代替data       const name = ref(&quot;iwen&quot;)//(基本类型使用)      const state = reactive(&#123;//(复杂类型使用)          list:[]      &#125;)    return&#123;        name,        state    &#125;  &#125;&#125;\n\nmethods中定义的方法写在setup()在2.x中methods来定义一些当前组件内部方法\nmethods:&#123;    http()&#123;&#125;&#125;\n\n在3.x中直接在setup方法中定义并return\nsetup() &#123;    const http = ()=&gt;&#123;        // do something    &#125;    return &#123;      http    &#125;;&#125;\n\n\n组合式api在setup中实现\n\nsetup()中使用props和context在2.x中，组件的方法中可以通过this获取到当前组件的实例，并执行data变量的修改，方法的调用，组件的通信等等，但是在3.x中，setup()在beforeCreate和created时机就已调用，无法使用和2.x一样的this，但是可以通过接收setup(props,ctx)的方法，获取到当前组件的实例和props\nexport default &#123;  props: &#123;//虽然setup中有参数porpos但是还是需要来申明类型的    name: String,  &#125;,  setup(props,ctx) &#123;    console.log(props.name)    ctx.emit(&#x27;event&#x27;)  &#125;,&#125;\n\n\nsetup中没有this\n\n在setup中使生命周期函你可以通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。\n下表包含如何在 setup () 内部调用生命周期钩子\n\n\n\nOptions API\nHook inside setup\n\n\n\nbeforeCreate\nNot needed*\n\n\ncreated\nNot needed*\n\n\nbeforeMount\nonBeforeMount\n\n\nmounted\nonMounted\n\n\nbeforeUpdate\nonBeforeUpdate\n\n\nupdated\nonUpdated\n\n\nbeforeUnmount\nonBeforeUnmount\n\n\nunmounted\nonUnmounted\n\n\nexport default &#123;  setup() &#123;    // mounted    //相比较之前的生命周期函数更有优势，之前是只能同样的生命周期函数存在一个，现在可以有多个    onMounted(() =&gt; &#123;      console.log(&#x27;Component is mounted!&#x27;)    &#125;)  &#125;&#125;\n\nProvide &#x2F; Inject - 实现嵌套数据传递\nprovide() 和 inject() 可以实现嵌套组件之间的数据传递。\n这两个函数只能在 setup() 函数中使用。\n父级组件中使用 provide() 函数向下传递数据。\n子级组件中使用 inject() 获取上层传递过来的数据。\n不限层级-&gt;只能从父组件往子组件中传递。\n\n// 父组件import &#123; provide &#125; from &quot;vue&quot;setup() &#123;    provide(&quot;customVal&quot;, &quot;我是父组件向子组件传递的值&quot;);&#125;\n\n// 子组件import &#123; inject &#125; from &quot;vue&quot;setup() &#123;    const customVal = inject(&quot;customVal&quot;);    return &#123;      customVal    &#125;&#125;\n\nFragmentFragment翻译为：“碎片”\n在vue2的时候在template中只允许存在一个根节点，在vue3中支持多个了\n\n不再限于模板中的单个根节点\n\n&lt;template&gt;  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;  &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot; /&gt;&lt;/template&gt;\n\nVue3加载Element-plusElement，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库\nElement Plus 基于 Vue 3，面向设计师和开发者的组件库\n安装Element-Plusnpm install element-plus --save\n\n完整引用如果你对打包后的文件大小不是很在乎，那么使用完整导入会更方便\nimport &#123; createApp &#125; from &#x27;vue&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)app.use(ElementPlus)app.mount(&#x27;#app&#x27;)\n\n按需导入按需导入才是我们的最爱，毕竟在真实的应用场景中并不是每个组件都会用到，这会造成不小的浪费\n首先你需要安装unplugin-vue-components 和 unplugin-auto-import这两款插件\nnpm install -D unplugin-vue-components unplugin-auto-import\n\n然后修改vue.config.js配置文件-覆盖掉\nconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)const AutoImport = require(&#x27;unplugin-auto-import/webpack&#x27;)const Components = require(&#x27;unplugin-vue-components/webpack&#x27;)const &#123; ElementPlusResolver &#125; = require(&#x27;unplugin-vue-components/resolvers&#x27;)module.exports = defineConfig(&#123;  transpileDependencies: true,  configureWebpack: &#123;    plugins: [      AutoImport(&#123;        resolvers: [ElementPlusResolver()]      &#125;),      Components(&#123;        resolvers: [ElementPlusResolver()]      &#125;)    ]  &#125;&#125;)\n\n最后，可以直接在组件中使用\n&lt;template&gt;    &lt;el-button&gt;Default&lt;/el-button&gt;    &lt;el-button type=&quot;primary&quot;&gt;Primary&lt;/el-button&gt;&lt;/template&gt;\n\nVue3加载Element-plus的字体图标Element-plus不仅仅是提供了各种组件，同时还提供了一整套的字体图标方便开发者使用\n安装icons字体图标npm install @element-plus/icons-vue\n\n全局注册在项目根目录下，创建plugins文件夹，在文件夹下创建文件icons.js文件\nimport * as components from &quot;@element-plus/icons-vue&quot;;export default &#123;    install: (app) =&gt; &#123;        for (const key in components) &#123;            const componentConfig = components[key];            app.component(componentConfig.name, componentConfig);        &#125;    &#125;,&#125;;\n\n引入文件在main.js中引入icons.js文件\nimport elementIcon from &quot;./plugins/icons&quot;;app.use(elementIcon)\n\n使用方式接下来就可以直接在组件中引入使用了\n&lt;el-icon class=&quot;expand&quot; color=&quot;#409EFC&quot; :size=&quot;30&quot;&gt;    &lt;expand /&gt;&lt;/el-icon&gt;\n","tags":["前端开发"]},{"title":"扣子使用教程","url":"/posts/c34b1b12.html","content":"扣子使用教程扣子(coze)是字节开发的智能智能体开发平台，用户可以在扣子上基于大模型搭建各种ai应用。\n相比于传统的大语言模型，扣子是希望将大语言模型与MCP相结合，或者定制专属的大语言模型，提供定制化服务。这是传统大语言模型所不具备的。\n扣子项目种类\n智能体：智能体是基于对话的 AI 项目，它通过对话方式接收用户的输入，由大模型自动调用插件或工作流等方式执行用户指定的业务流程，并生成最终的回复。智能客服、虚拟伴侣、个人助理、英语外教都是智能体的典型应用场景。\n应用：应用是指利用大模型技术开发的应用程序。扣子中搭建的 AI 应用具备完整业务逻辑和可视化用户界面，是一个独立的 AI 项目。通过扣子开发的 AI 应用有明确的输入和输出，可以根据既定的业务逻辑和流程完成一系列简单或复杂的任务，例如 AI 搜索、翻译工具、饮食记录等。\n\n平台架构进入扣子主页后，会显示下图：\n\n我们找到对应的开发空间(默认是个人空间)，开发空间架构如下：\n\n项目开发：项目分为智能体和 AI 应用两种类型，AI 应用内可以创建多种应用专属资源，也可以和智能体共享空间资源库中的资源。\n智能体:智能体（Agent）通常指的是一个能够独立执行任务、做出决策并进行学习的一种自动化程序。智能体可以根据用户输入的指令，自主调用模型、知识库、插件等技能并完成编排，最终完成用户的指令。\nAI 应用:AI 应用是指利用大模型技术开发的应用程序，这些应用程序能够使用大模型，执行复杂任务，分析数据，并作出决策。\n\n\n资源库：你可以在资源库内创建、发布、管理共享资源例如插件、知识库、数据库、提示词等。这些资源可以被同一空间内的智能体和应用使用。\n工作流\n对话流\n插件\n知识库\n卡片\n提示词\n数据库\n音色(会员)\n\n\n\n资源可以存在于两个实体内，一个是空间的资源库，一个是 AI 应用项目中的项目资源库。\n\n空间资源库：在空间资源库内创建的资源可以被空间内的 AI 应用项目和智能体项目使用，属于空间内的共享资源。\nAI 应用项目：在 AI 应用项目中也可以创建资源，但这些资源是项目自有的资源，默认不可以被其他项目使用也不会展示在空间资源库内。\n\n\n当需要将 AI 应用项目中的资源转换成公共资源给其他 AI 应用或智能体使用时，可以将这些资源转移或复制到空间资源库内。空间是资源组织的基础单元，不同空间内的资源和数据相互隔离。一个空间内可创建多个智能体和 AI 应用，并包含一个资源库。在资源库中创建的资源可以被相同空间内的智能体和 AI 应用使用。\n\n1\n","tags":["教程"]}]