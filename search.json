[{"url":"/2025/04/01/c++14%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/","content":"c++14版本特性变量模板变量模板可以认为是一种不确定的变量，就是泛型变量。\n语法：\ntemplate &lt; 形参列表 &gt; 变量声明// 举例template&lt;typename T&gt;const T pi = T(3.1415926535897932385L);\n\n在c++14之前只有模板函数和模板类，没有变量模板。\n变量声明：变量的声明。声明的变量名成为模板名。形参列表：非空的模板形参的逗号分隔列表，每项是非类型形参、类型形参、模板形参，或任何上述的形参包之一。\n\n介绍一下非类型形参、类型形参、模板形参是什么？非类型形参：就是普通的形参，比如 template 在写变量的时候就可以在&lt;&gt;中写一个int类型的变量。(T纯右值不可改，在编译期间就确定了，除非T是左值引用类型)类型形参：就是模板形参，比如 template 在写变量的时候就可以在&lt;&gt;中写一个类型变量。模板形参：就是模板形参，比如 template&lt;template class T&gt; 在写变量的时候就可以在&lt;&gt;中写一个模板变量。模板实参：就是模板实参，比如 template 在写变量的时候就可以在&lt;&gt;中写一个具体的类型，可以是类等自定义的类型。\n\n官方文档提供的几种案例：\n// 1. 基础使用template&lt;class T&gt;constexpr T pi = T(3.1415926535897932385L); // 变量模板 template&lt;class T&gt;T circular_area(T r) // 函数模板&#123;    return pi&lt;T&gt; * r * r; // pi&lt;T&gt; 是变量模板实例化&#125;//2.在类作用域中使用时，变量模板声明一个静态数据成员模板。using namespace std::literals;struct matrix_constants&#123;    template&lt;class T&gt;    using pauli = hermitian_matrix&lt;T, 2&gt;; // 别名模版     template&lt;class T&gt; // 静态数据成员模板    static constexpr pauli&lt;T&gt; sigmaX = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;&#125;;     template&lt;class T&gt;    static constexpr pauli&lt;T&gt; sigmaY = &#123;&#123;0, -1i&#125;, &#123;1i, 0&#125;&#125;;     template&lt;class T&gt;    static constexpr pauli&lt;T&gt; sigmaZ = &#123;&#123;1, 0&#125;, &#123;0, -1&#125;&#125;;&#125;;// 3.与其他静态成员一样，静态数据成员模板的需要一个定义。这种定义可以在类定义外提供。处于命名空间作用域的静态数据成员的模板声明也可以是类模板的非模板数据成员的定义：struct limits&#123;    template&lt;typename T&gt;    static const T min; // 静态数据成员模板的声明&#125;; template&lt;typename T&gt;const T limits::min = &#123;&#125;; // 静态数据成员模板的定义 template&lt;class T&gt;class X&#123;    static T s; // 类模板的非模板静态数据成员的声明&#125;; template&lt;class T&gt;T X&lt;T&gt;::s = 0; // 类模板的非模板静态数据成员的定义\n\n泛型 lambda泛型lambda表达式可以在其形参列表中使用 auto 或 decltype(auto) 来表示其形参的类型。 拓展了c++11的lambda表达式的使用范围。\n语法样例：\nauto genericLambda = [](auto a, auto b) &#123;    return a + b;&#125;;int intResult = genericLambda(5, 10); // OK: int + intdouble doubleResult = genericLambda(5.5, 10.2); // OK: double + double// 实际上编译器眼中的泛型lambda表达式是这样的：class SomeCompilerGeneratedClassName &#123;public:    template&lt;typename T, typename U&gt;    auto operator()(T t, U u) const &#123;        return t + u;    &#125;&#125;;// 官方提供的样例// 泛型 lambda，operator() 是有两个形参的模板auto glambda = [](auto a, auto&amp;&amp; b) &#123; return a &lt; b; &#125;;bool b = glambda(3, 3.14); // ok // 泛型 lambda，operator() 是有一个形参的模板auto vglambda = [](auto printer)&#123;    return [=](auto&amp;&amp;... ts) // 泛型 lambda，ts 是形参包    &#123;         printer(std::forward&lt;decltype(ts)&gt;(ts)...);        // 零元 lambda （不接受形参）        return [=] &#123; printer(ts...); &#125;;    &#125;;&#125;; auto p = vglambda([](auto v1, auto v2, auto v3)&#123;    std::cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3;&#125;); auto q = p(1, &#x27;a&#x27;, 3.14); // 输出 1a3.14q();                      // 输出 1a3.14\n\n\n注意：泛型lambda表达式允许在捕获列表中初始化新变量，支持移动捕获和表达式初始化。\n\nlambda 初始化捕获lambda表达式允许在捕获列表中初始化新变量。这个特性允许你在lambda表达式内部通过任意的表达式来初始化被捕获的变量。\n语法：\n[captured_var = init_expression] (parameters) -&gt; return_type &#123;    // lambda body&#125;\n\n使用样例：\n// 基本用法int x = 5;auto lambda = [val = x + 10]() &#123;     std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; val &lt;&lt; std::endl; &#125;;lambda(); // 输出: Value: 15// 智能指针的捕获int* p = new int(10);auto lambda = [ptr = std::unique_ptr&lt;int&gt;(p)]() &#123;     if(ptr) std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; &#125;;lambda(); // 输出: Value: 10// 改变捕获变量的类型int x = 5;auto lambda = [num = static_cast&lt;double&gt;(x)]() mutable &#123;     std::cout &lt;&lt; &quot;Double value: &quot; &lt;&lt; num &lt;&lt; std::endl; &#125;;lambda(); // 输出: Double value: 5.0\n\nnew&#x2F;delete 消除这个特性英文是：new&#x2F;delete elision。\n这个特性的意思是：在某些情况下，编译器可以在不调用 new 或 delete 运算符的情况下分配和释放内存。\n因为对这个描述比较少，我们可以理解为，编译器对于new和delete的调用进行了优化。\n在以下情况下，编译器可以体现new&#x2F;delete的省略：\n\nNRVO (Named Return Value Optimization) 和 RVO (Return Value Optimization)：这些优化允许编译器在函数返回局部对象时省略拷贝或移动操作。如果编译器能够确定对象的生命期并进行优化，则可能避免额外的构造、拷贝和析构操作，这间接减少了潜在的new&#x2F;delete调用。\n移动语义：C++11引入了移动语义，允许资源从临时对象高效转移而不是复制。当一个对象被移动而不是被复制时，通常不需要分配新的内存，这减少了new操作的需求，并且通过释放旧的对象来减少delete操作。\n自动存储持续时间 vs 动态存储持续时间：尽量使用栈上的变量（具有自动存储持续时间），而不是堆上的动态分配（具有动态存储持续时间）。栈分配更快，且不需要手动管理内存（即显式的new和delete）。\n智能指针：使用如std::unique_ptr和std::shared_ptr等智能指针代替裸指针，可以帮助自动管理内存，减少手动调用new和delete的机会，并允许编译器更好地优化代码。\n\nconstexpr 函数上放松的限制在C++14中，constexpr函数得到了显著的放松和增强，使其更加灵活和实用。根据你提供的来源，以下是C++14对constexpr函数放松的主要限制：\n\n允许更多的复杂操作：在C++11中，constexpr函数被严格限制为只能包含一个返回语句。C++14放宽了这一限制，允许constexpr函数包含更复杂的控制流，包括循环（如while、for）和局部变量的声明。\n非const成员函数可以是constexpr：C++14允许非const成员函数也可以声明为constexpr。这意味着你可以定义修改对象状态的constexpr成员函数，只要这些修改可以在编译期完成。\n支持局部变量：constexpr函数现在可以包含局部变量的声明和使用，这增加了函数内部逻辑组织的灵活性。\n不再强制所有声明都必须有constexpr说明符：对于constexpr变量模板的所有声明来说，在C++14之前需要在每个声明处都加上constexpr说明符。C++14之后，不再要求这样做，提高了代码的可维护性。\n\n示例代码：\n// C++14 constexpr 函数可以包含局部变量和循环constexpr int factorial_cxx14(int n) &#123;    int res = 1; // 局部变量    while (n &gt; 1) &#123; // 循环        res *= n--;    &#125;    return res;&#125;class MyClass &#123;public:    // 非 const 成员函数可以是 constexpr    constexpr void multiplyByTwo() &#123;        value *= 2;    &#125;private:    int value;&#125;;int main() &#123;    constexpr int result = factorial_cxx14(5); // 可以在编译期计算    static_assert(result == 120, &quot;factorial calculation failed&quot;);&#125;\n\n二进制字面量与数位分隔符在c++14之前，整数字面量只有十进制、八进制和十六进制。14之后，增加了二进制字面量。\n二进制字面量的语法：要定义一个二进制字面量，你需要以0b或0B开头，后面跟随一个或多个二进制数字（0或1）。\nint binNumber = 0b101010; // 等价于十进制的42int binNumberUpper = 0B101010; // 同样等价于十进制的42\n\n其他相关特性:除了直接支持二进制字面量外，C++14还允许在长整型字面量中使用二进制格式，并可以添加整数后缀来指定类型。\n例如：\n0b101u //表示无符号整数。0b101L //表示长整数。0b101LL //表示长长整数。int largeBinNumber = 0b1&#x27;0101&#x27;0101; // 分隔符的使用\n\n此外，C++14还引入了单引号作为分隔符的功能，可以在较长的字面量中使用，以提高可读性。不过，这一功能主要针对视觉上的改善，并不影响字面量的实际值。\n函数的返回类型推导在c++11中auto作为函数的返回类型是一个占位符，必须要有尾随返回类型，但是在c++14中，auto可以作为函数的返回类型可以不写尾随返回类型，使代码变得更加简洁。\n\n使用auto进行返回类型推导C++14允许使用auto作为函数的返回类型，编译器会根据函数体内的返回语句自动推导出实际的返回类型。这使得编写模板和泛型代码变得更加简洁。\ndecltype(auto)除了直接使用auto，C++14还引入了decltype(auto)，它允许根据返回表达式的精确类型来推导返回类型，而不是根据值类别进行调整。这对于返回引用或指针时特别有用。\n\n//使用auto时，返回类型基于值类别被调整：auto f() &#123; return 3.14f; &#125; // 返回类型是 float//使用decltype(auto)时，返回类型基于表达式的声明类型：const int a = 10;decltype(auto) g() &#123; return a; &#125; // 返回类型是 const int&amp;\n\n\n尾随返回类型的改进虽然尾随返回类型（trailing return type）在C++11中就已经存在，但在C++14中与auto结合使用变得更加灵活和强大。例如，可以轻松地定义复杂的返回类型：\n\ntemplate&lt;typename T, typename U&gt;auto add(T t, U u) -&gt; decltype(t + u); // C++11风格// 在C++14中可以直接写成：template&lt;typename T, typename U&gt;auto add(T t, U u) &#123; return t + u; &#125;\n\n\n单返回语句的简单推导如果一个函数只有一条返回语句，并且这条语句的表达式类型可以明确推导出来，那么编译器可以根据这个表达式直接推导出函数的返回类型。这种情况下不需要显式指定返回类型。\n\nauto square(int x) &#123; return x * x; &#125; // 返回类型自动推导为 int\n\n带默认成员初始化器的聚合类。在C++标准中聚合类的定义，聚合类是指满足以下条件的类：\n\n没有私有或受保护的非静态数据成员。\n没有用户声明的构造函数（即没有自定义的构造函数）。\n没有虚函数。\n没有基类。\n没有虚基类。\n\n在C++14之前，聚合类不允许为成员变量提供默认初始化器。例如，下面的代码在C++11中是非法的：\nstruct Point &#123;    int x = 0; // 默认成员初始化器，在C++11中非法    int y = 0; // 默认成员初始化器，在C++11中非法&#125;;\n\nC++14放松了这个限制，允许聚合类拥有默认成员初始化器。这意味着你可以为聚合类的成员变量指定默认值，这些默认值会在对象被默认初始化时使用。例如：\nstruct Point &#123;    int x = 0; // 默认成员初始化器    int y = 0; // 默认成员初始化器&#125;;\n\n\n这个特性看编译器是否支持，比如clion用cmake构建项目，声明的是c++11版本也支持这个特性。\n\n注意事项\n\n初始化顺序：如果使用列表初始化，成员变量会按照它们在类中声明的顺序进行初始化，而不是按照初始化列表中的顺序。\n兼容性：虽然可以为聚合类的成员提供默认初始化器，但这并不意味着聚合类的行为完全等同于带有构造函数的类。聚合类仍然不能有用户定义的构造函数、虚函数或基类。\n混合初始化：如果你部分提供了初始化值，未提供的成员将会使用默认初始化器。例如：\n\n"}]