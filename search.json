[{"title":"c++14版本更新","url":"/posts/c2e95af0.html","content":"c++14版本特性变量模板变量模板可以认为是一种不确定的变量，就是泛型变量。\n语法：\ntemplate &lt; 形参列表 &gt; 变量声明// 举例template&lt;typename T&gt;const T pi = T(3.1415926535897932385L);\n\n在c++14之前只有模板函数和模板类，没有变量模板。\n变量声明：变量的声明。声明的变量名成为模板名。形参列表：非空的模板形参的逗号分隔列表，每项是非类型形参、类型形参、模板形参，或任何上述的形参包之一。\n\n介绍一下非类型形参、类型形参、模板形参是什么？非类型形参：就是普通的形参，比如 template 在写变量的时候就可以在&lt;&gt;中写一个int类型的变量。(T纯右值不可改，在编译期间就确定了，除非T是左值引用类型)类型形参：就是模板形参，比如 template 在写变量的时候就可以在&lt;&gt;中写一个类型变量。模板形参：就是模板形参，比如 template&lt;template class T&gt; 在写变量的时候就可以在&lt;&gt;中写一个模板变量。模板实参：就是模板实参，比如 template 在写变量的时候就可以在&lt;&gt;中写一个具体的类型，可以是类等自定义的类型。\n\n官方文档提供的几种案例：\n// 1. 基础使用template&lt;class T&gt;constexpr T pi = T(3.1415926535897932385L); // 变量模板 template&lt;class T&gt;T circular_area(T r) // 函数模板&#123;    return pi&lt;T&gt; * r * r; // pi&lt;T&gt; 是变量模板实例化&#125;//2.在类作用域中使用时，变量模板声明一个静态数据成员模板。using namespace std::literals;struct matrix_constants&#123;    template&lt;class T&gt;    using pauli = hermitian_matrix&lt;T, 2&gt;; // 别名模版     template&lt;class T&gt; // 静态数据成员模板    static constexpr pauli&lt;T&gt; sigmaX = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;&#125;;     template&lt;class T&gt;    static constexpr pauli&lt;T&gt; sigmaY = &#123;&#123;0, -1i&#125;, &#123;1i, 0&#125;&#125;;     template&lt;class T&gt;    static constexpr pauli&lt;T&gt; sigmaZ = &#123;&#123;1, 0&#125;, &#123;0, -1&#125;&#125;;&#125;;// 3.与其他静态成员一样，静态数据成员模板的需要一个定义。这种定义可以在类定义外提供。处于命名空间作用域的静态数据成员的模板声明也可以是类模板的非模板数据成员的定义：struct limits&#123;    template&lt;typename T&gt;    static const T min; // 静态数据成员模板的声明&#125;; template&lt;typename T&gt;const T limits::min = &#123;&#125;; // 静态数据成员模板的定义 template&lt;class T&gt;class X&#123;    static T s; // 类模板的非模板静态数据成员的声明&#125;; template&lt;class T&gt;T X&lt;T&gt;::s = 0; // 类模板的非模板静态数据成员的定义\n\n泛型 lambda泛型lambda表达式可以在其形参列表中使用 auto 或 decltype(auto) 来表示其形参的类型。 拓展了c++11的lambda表达式的使用范围。\n语法样例：\nauto genericLambda = [](auto a, auto b) &#123;    return a + b;&#125;;int intResult = genericLambda(5, 10); // OK: int + intdouble doubleResult = genericLambda(5.5, 10.2); // OK: double + double// 实际上编译器眼中的泛型lambda表达式是这样的：class SomeCompilerGeneratedClassName &#123;public:    template&lt;typename T, typename U&gt;    auto operator()(T t, U u) const &#123;        return t + u;    &#125;&#125;;// 官方提供的样例// 泛型 lambda，operator() 是有两个形参的模板auto glambda = [](auto a, auto&amp;&amp; b) &#123; return a &lt; b; &#125;;bool b = glambda(3, 3.14); // ok // 泛型 lambda，operator() 是有一个形参的模板auto vglambda = [](auto printer)&#123;    return [=](auto&amp;&amp;... ts) // 泛型 lambda，ts 是形参包    &#123;         printer(std::forward&lt;decltype(ts)&gt;(ts)...);        // 零元 lambda （不接受形参）        return [=] &#123; printer(ts...); &#125;;    &#125;;&#125;; auto p = vglambda([](auto v1, auto v2, auto v3)&#123;    std::cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3;&#125;); auto q = p(1, &#x27;a&#x27;, 3.14); // 输出 1a3.14q();                      // 输出 1a3.14\n\n\n注意：泛型lambda表达式允许在捕获列表中初始化新变量，支持移动捕获和表达式初始化。\n\nlambda 初始化捕获lambda表达式允许在捕获列表中初始化新变量。这个特性允许你在lambda表达式内部通过任意的表达式来初始化被捕获的变量。\n语法：\n[captured_var = init_expression] (parameters) -&gt; return_type &#123;    // lambda body&#125;\n\n使用样例：\n// 基本用法int x = 5;auto lambda = [val = x + 10]() &#123;     std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; val &lt;&lt; std::endl; &#125;;lambda(); // 输出: Value: 15// 智能指针的捕获int* p = new int(10);auto lambda = [ptr = std::unique_ptr&lt;int&gt;(p)]() &#123;     if(ptr) std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; &#125;;lambda(); // 输出: Value: 10// 改变捕获变量的类型int x = 5;auto lambda = [num = static_cast&lt;double&gt;(x)]() mutable &#123;     std::cout &lt;&lt; &quot;Double value: &quot; &lt;&lt; num &lt;&lt; std::endl; &#125;;lambda(); // 输出: Double value: 5.0\n\nnew&#x2F;delete 消除这个特性英文是：new&#x2F;delete elision。\n这个特性的意思是：在某些情况下，编译器可以在不调用 new 或 delete 运算符的情况下分配和释放内存。\n因为对这个描述比较少，我们可以理解为，编译器对于new和delete的调用进行了优化。\n在以下情况下，编译器可以体现new&#x2F;delete的省略：\n\nNRVO (Named Return Value Optimization) 和 RVO (Return Value Optimization)：这些优化允许编译器在函数返回局部对象时省略拷贝或移动操作。如果编译器能够确定对象的生命期并进行优化，则可能避免额外的构造、拷贝和析构操作，这间接减少了潜在的new&#x2F;delete调用。\n移动语义：C++11引入了移动语义，允许资源从临时对象高效转移而不是复制。当一个对象被移动而不是被复制时，通常不需要分配新的内存，这减少了new操作的需求，并且通过释放旧的对象来减少delete操作。\n自动存储持续时间 vs 动态存储持续时间：尽量使用栈上的变量（具有自动存储持续时间），而不是堆上的动态分配（具有动态存储持续时间）。栈分配更快，且不需要手动管理内存（即显式的new和delete）。\n智能指针：使用如std::unique_ptr和std::shared_ptr等智能指针代替裸指针，可以帮助自动管理内存，减少手动调用new和delete的机会，并允许编译器更好地优化代码。\n\nconstexpr 函数上放松的限制在C++14中，constexpr函数得到了显著的放松和增强，使其更加灵活和实用。根据你提供的来源，以下是C++14对constexpr函数放松的主要限制：\n\n允许更多的复杂操作：在C++11中，constexpr函数被严格限制为只能包含一个返回语句。C++14放宽了这一限制，允许constexpr函数包含更复杂的控制流，包括循环（如while、for）和局部变量的声明。\n非const成员函数可以是constexpr：C++14允许非const成员函数也可以声明为constexpr。这意味着你可以定义修改对象状态的constexpr成员函数，只要这些修改可以在编译期完成。\n支持局部变量：constexpr函数现在可以包含局部变量的声明和使用，这增加了函数内部逻辑组织的灵活性。\n不再强制所有声明都必须有constexpr说明符：对于constexpr变量模板的所有声明来说，在C++14之前需要在每个声明处都加上constexpr说明符。C++14之后，不再要求这样做，提高了代码的可维护性。\n\n示例代码：\n// C++14 constexpr 函数可以包含局部变量和循环constexpr int factorial_cxx14(int n) &#123;    int res = 1; // 局部变量    while (n &gt; 1) &#123; // 循环        res *= n--;    &#125;    return res;&#125;class MyClass &#123;public:    // 非 const 成员函数可以是 constexpr    constexpr void multiplyByTwo() &#123;        value *= 2;    &#125;private:    int value;&#125;;int main() &#123;    constexpr int result = factorial_cxx14(5); // 可以在编译期计算    static_assert(result == 120, &quot;factorial calculation failed&quot;);&#125;\n\n二进制字面量与数位分隔符在c++14之前，整数字面量只有十进制、八进制和十六进制。14之后，增加了二进制字面量。\n二进制字面量的语法：要定义一个二进制字面量，你需要以0b或0B开头，后面跟随一个或多个二进制数字（0或1）。\nint binNumber = 0b101010; // 等价于十进制的42int binNumberUpper = 0B101010; // 同样等价于十进制的42\n\n其他相关特性:除了直接支持二进制字面量外，C++14还允许在长整型字面量中使用二进制格式，并可以添加整数后缀来指定类型。\n例如：\n0b101u //表示无符号整数。0b101L //表示长整数。0b101LL //表示长长整数。int largeBinNumber = 0b1&#x27;0101&#x27;0101; // 分隔符的使用\n\n此外，C++14还引入了单引号作为分隔符的功能，可以在较长的字面量中使用，以提高可读性。不过，这一功能主要针对视觉上的改善，并不影响字面量的实际值。\n函数的返回类型推导在c++11中auto作为函数的返回类型是一个占位符，必须要有尾随返回类型，但是在c++14中，auto可以作为函数的返回类型可以不写尾随返回类型，使代码变得更加简洁。\n\n使用auto进行返回类型推导C++14允许使用auto作为函数的返回类型，编译器会根据函数体内的返回语句自动推导出实际的返回类型。这使得编写模板和泛型代码变得更加简洁。\ndecltype(auto)除了直接使用auto，C++14还引入了decltype(auto)，它允许根据返回表达式的精确类型来推导返回类型，而不是根据值类别进行调整。这对于返回引用或指针时特别有用。\n\n//使用auto时，返回类型基于值类别被调整：auto f() &#123; return 3.14f; &#125; // 返回类型是 float//使用decltype(auto)时，返回类型基于表达式的声明类型：const int a = 10;decltype(auto) g() &#123; return a; &#125; // 返回类型是 const int&amp;\n\n\n尾随返回类型的改进虽然尾随返回类型（trailing return type）在C++11中就已经存在，但在C++14中与auto结合使用变得更加灵活和强大。例如，可以轻松地定义复杂的返回类型：\n\ntemplate&lt;typename T, typename U&gt;auto add(T t, U u) -&gt; decltype(t + u); // C++11风格// 在C++14中可以直接写成：template&lt;typename T, typename U&gt;auto add(T t, U u) &#123; return t + u; &#125;\n\n\n单返回语句的简单推导如果一个函数只有一条返回语句，并且这条语句的表达式类型可以明确推导出来，那么编译器可以根据这个表达式直接推导出函数的返回类型。这种情况下不需要显式指定返回类型。\n\nauto square(int x) &#123; return x * x; &#125; // 返回类型自动推导为 int\n\n带默认成员初始化器的聚合类。在C++标准中聚合类的定义，聚合类是指满足以下条件的类：\n\n没有私有或受保护的非静态数据成员。\n没有用户声明的构造函数（即没有自定义的构造函数）。\n没有虚函数。\n没有基类。\n没有虚基类。\n\n在C++14之前，聚合类不允许为成员变量提供默认初始化器。例如，下面的代码在C++11中是非法的：\nstruct Point &#123;    int x = 0; // 默认成员初始化器，在C++11中非法    int y = 0; // 默认成员初始化器，在C++11中非法&#125;;\n\nC++14放松了这个限制，允许聚合类拥有默认成员初始化器。这意味着你可以为聚合类的成员变量指定默认值，这些默认值会在对象被默认初始化时使用。例如：\nstruct Point &#123;    int x = 0; // 默认成员初始化器    int y = 0; // 默认成员初始化器&#125;;\n\n\n这个特性看编译器是否支持，比如clion用cmake构建项目，声明的是c++11版本也支持这个特性。\n\n注意事项\n\n初始化顺序：如果使用列表初始化，成员变量会按照它们在类中声明的顺序进行初始化，而不是按照初始化列表中的顺序。\n兼容性：虽然可以为聚合类的成员提供默认初始化器，但这并不意味着聚合类的行为完全等同于带有构造函数的类。聚合类仍然不能有用户定义的构造函数、虚函数或基类。\n混合初始化：如果你部分提供了初始化值，未提供的成员将会使用默认初始化器。例如：\n\n","tags":["cpp"]},{"title":"c++17版本更新","url":"/posts/7f23363e.html","content":"c++17新特性C++17 是小版本 C++14 之后的一个大版本，它提供了新的语言和库功能特性。该标准于 2017 年 12 月发布。\n移除或弃用的特性已移除特性\nstd::auto_ptr\n已弃用的函数对象\nstd::random_shuffle\nstd::unexpected\n过时的 iostream 别名\n三标符\nregister 关键字\nbool 类型的自增操作\n动态异常说明\n\n弃用特性\nstd::iterator\nstd::raw_storage_iterator\nstd::get_temporary_buffer\nstd::is_literal_type\nstd::result_of\n整个 &lt;codecvt&gt; 头文件\n\n\n因为这些特性之前并没有被广泛使用，所以对此没有太多了解。只讲链接进行保存，有需要的可以去查看。\n\n新的语言特性u8 字符字面量语法：u8&#39;c字符 &#39;\nUTF-8 字符字面量，例如 u8’a’。这种字面量具有 char(C++20 前)char8_t(C++20 起) 类型，且它的值等于c字符的 ISO&#x2F;IEC 10646 码位值，只要码位值能以单个 UTF-8 代码单元表示（即c字符 处于范围 0x0-0x7F（含边界）内）。\nu8 字符字面量的类型为 char8_t，它是一个新的字符类型，它的大小和 char 相同，但是它的字符集是 UTF-8 字符集。\n将 noexcept 作为类型系统的一部分这个字面量在c++11标准加入，在c++7标准正式成为标准的一部分。作用是在函数声明和定义中使用，用于指定函数是否可以抛出异常。\n新的求值顺序规则在C++中，除非有明确的规则定义，否则表达式的任何部分（包括函数参数）的求值顺序是未指定的。这意味着编译器可以自由选择求值顺序，并且可以在不同时间点以不同的顺序进行求值。\n在C++17之前，C++标准使用的是序列点的概念来描述何时副作用必须完成以及何时可以安全地访问一个对象的值而不导致未定义行为。例如，在同一内存位置上的两次副作用之间如果没有适当的序列点，则会导致未定义行为。典型例子包括对同一个变量进行前置或后置自增&#x2F;自减操作而没有正确地分隔这些操作的情况。\nC++17引入了一些重要的变化和新增规则来改进求值顺序的规定，主要包括：\n明确了某些情况下的求值顺序：C++17明确规定了一些过去求值顺序不明确的情况。例如，在调用函数时，所有实参表达式的求值顺序现在是未指明的而非未定义的。这允许编译器优化代码但避免了完全未定义的行为。避免未定义行为：对于一些特定的表达式，如i &#x3D; ++i + i++;，在C++17之前会导致未定义行为，因为它们在同一内存位置上进行了无序的读写操作。虽然这种表达式仍然被认为是不好的编程实践，但在C++17中，其行为被更清晰地定义为未定义行为，而不是依赖于编译器实现的具体细节。具体的表达式示例：\ni = ++i + 2; //在C++17下具有良好的定义。i = i++ + 2; //在C++17前行为是未定义的，但C++17并没有改变这一点。f(i = -2, i = -2); 和 f(++i, ++i); //在C++17之前是未定义行为，但在C++17中，这些表达式的求值顺序变为未指明，即允许任意顺序执行，但不会造成未定义行为。\n\nlambda 表达式捕获 *this在[]可以捕获*this，表示：当前对象的简单的按复制捕获\n\n与this的区别：\n\n捕获this时，this的类型是指针类型，而捕获*this时，this的类型是引用类型。\n捕获this时，this指向的是当前对象，而捕获*this时，this指向的是当前对象的副本。\n\n\n例子：\nstruct S2 &#123; void f(int i); &#125;;void S2::f(int i)&#123;    [=] &#123;&#125;;        // OK：默认按复制捕获    [=, &amp;i] &#123;&#125;;    // OK：按复制捕获，但 i 按引用捕获    [=, *this] &#123;&#125;; // C++17 前：错误：无效语法                   // C++17 起：OK：按复制捕获外围的 S2    [=, this] &#123;&#125;;  // C++20 前：错误：= 为默认时的 this                   // C++20 起：OK：同 [=]    [i, i] &#123;&#125;;        // 错误：i 重复    [this, *this] &#123;&#125;; // 错误：&quot;this&quot; 重复（C++17）    [i] (int i) &#123;&#125;;   // 错误：形参和捕获的名字相同&#125;\n\nconstexpr编译期的 constexpr if 语句if语句：属性 (可选) if constexpr(可选) ( 初始化语句 (可选) 条件 ) true分支语句 else false分支语句\n参数介绍：属性-(C++11 起) 任意数量的属性constexpr-(C++17 起) 出现时，该语句是 constexpr if 语句初始化语句-(C++17 起) 下列之一：\n\n表达式语句（可以是空语句 ;）\n简单声明，典型的是带初始化器的变量声明，但它可以声明任意多个变量，或是一条结构化绑定声明\n别名声明(C++23 起)\n\n\n注意，任何初始化语句都应以分号 ; 结束。这是它常被非正式地描述成后随分号的表达式或声明的原因。\n\n条件-条件true分支语句-任意当条件求值为 true 时会执行的语句false分支语句-当条件求值为 false 时会执行的语句复合语句-当此 if 语句在明显常量求值语境下求值时会执行的复合语句（consteval 前附 ! 的情况下条件变成“不在这种语境下求值”）语句-当此 if 语句不在明显常量求值语境下求值时会执行的语句（consteval 未前附 ! 的情况下条件变成“在这种语境下求值”）\n以 if constexpr 开始的语句被称为 constexpr if 语句。constexpr if 语句的所有子语句都是有控制流限制的语句。\n在 constexpr if 语句中，条件的值必须是可按语境转换到 bool 类型的经转换常量表达式(C++23 前)按语境转换到 bool 的表达式，其中转换为常量表达式(C++23 起)。\n如果条件的值是 true，那么舍弃 false分支语句（如果存在），否则舍弃 true分支语句。\n简单来说：constexpr if（自C++17起）：这种形式的 if 语句允许编译时分支选择，对于模板编程特别有用。在 constexpr if 中，根据条件表达式的值，编译器可以选择编译或忽略特定的分支。\n\n但是if constexpr 不是 #if 预处理指令的替代品。\n\nconstexpr 的 lambda 表达式constexpr lambda：从C++17开始，lambda表达式可以被声明为constexpr，这意味着如果lambda满足成为constexpr函数的所有要求，它就可以在编译时常量表达式中使用。这使得lambda表达式可以在更多的上下文中使用，比如作为非类型的模板参数。 示例：\nauto getId = [](auto x) constexpr &#123; return x.id; &#125;;\n\n其他有关lambda的特性：\nLambda捕获表达式中的初始化捕获列表中的初始化器：C++17允许在lambda表达式的捕获列表中直接初始化变量。这对于复制或移动捕获特别有用，并且可以简化代码逻辑。 示例：\nint x = 4;auto f = [x = std::move(x)]() &#123; return x; &#125;; // 使用std::move来捕获x\n\n变量inline 变量在此之前，inline主要用于函数和成员函数，允许在多个翻译单元中提供函数定义而不导致链接错误。自C++17起，标准引入了对inline变量的支持，这是C++17相对于之前版本的一个重要更新。\ninline变量（C++17）定义：从C++17开始，变量可以被声明为inline。这使得可以在多个翻译单元（每个源文件为一个翻译单元）中提供相同变量的定义，而不会导致链接时的重复定义错误。这一特性特别适用于常量，因为它允许常量在头文件中定义，并且该头文件可以被多个源文件包含而不会引起冲突。使用场景：当你需要在多个源文件之间共享一个常量或变量时，inline变量是一个理想的解决方案。对于模板编程也非常有用，因为现在你可以定义内联静态数据成员而不需要在每个翻译单元中都提供单独的定义。语法示例：\nstruct MyStruct &#123;    static inline const int MAX_LIMIT = 100; // C++17 及之后&#125;;\n\n在这个例子中，MAX_LIMIT被声明为一个inline静态成员变量。这意味着你可以在多个源文件中包含这个头文件而不会遇到重复定义的问题。\n但是这个特性也有一些问题，比如编译器是否支持。\n结构化绑定结构化绑定允许更方便地将复合类型的成员解包到独立的变量中。这项功能特别适用于处理tuple、pair、数组以及具有多个成员的结构体或类实例的情况。\n语法与参数：\n属性 (可选) 声明说明符序列 引用限定符 (可选) [ 绑定标识符列表 ] 初始化器 ;属性-任意数量的属性的序列decl-specifier-seq-包含以下说明符的序列（遵循简单声明的规则）：    constexpr    constinit    (C++26 起)    static    thread_local    const    volatile    auto引用限定符-&amp; 或 &amp;&amp; 之一绑定标识符列表-此声明所引入的各标识符的逗号分隔的列表，每个标识符可以后随一个属性说明符序列(C++26 起)初始化器-初始化器（见下文）\n初始化器 必须是下列之一：&#x3D; 表达式{ 表达式 }( 表达式 )表达式-（无括号的逗号表达式以外的）任意表达式\n例子：\nauto [name1, name2, ..., nameN] = expression;//解绑std::tuple    auto tupleExample = std::make_tuple(10, &quot;Hello&quot;, 3.14);    auto [num, str, pi] = tupleExample;    std::cout &lt;&lt; num &lt;&lt; &quot;, &quot; &lt;&lt; str &lt;&lt; &quot;, &quot; &lt;&lt; pi &lt;&lt; std::endl;//解绑数组    int arr[] = &#123;1, 2, 3&#125;;    auto [a, b, c] = arr;    std::cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; std::endl;//解绑结构体struct Point &#123;    int x;    int y;&#125;;    Point p = &#123;10, 20&#125;;    auto [x, y] = p;    std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; std::endl;        //指针绑定：虽然不常见，但你也可以将结果绑定到指针上。    auto&amp; [refX, refY] = p; // 绑定为引用    auto* [ptrX, ptrY] = &amp;p; // 绑定为指针    //捕获列表中的使用：结构化绑定也可用于lambda表达式的捕获列表中，这使得在lambda内部可以更容易地访问复杂数据结构的成员。    auto lambda = [&amp;r = data] &#123; /* 使用 r */ &#125;;\n\n\n注意事项引用绑定：你可以通过在声明时添加&amp;或&amp;&amp;来创建对原对象的引用，而不是进行值复制。\n\nif 和 switch 语句中的初始化器在C++17中，if和switch语句得到了增强，允许在其条件表达式中包含初始化器。这项改进使得可以在控制流语句的上下文中声明并初始化变量，同时该变量的作用域被限制在对应的if或switch语句块内。这不仅提升了代码的安全性和可读性，还减少了潜在的错误，比如忘记在不同分支中正确地初始化变量。\nif语句中的初始化器在C++17之前，如果需要在条件判断之前初始化一个变量，通常需要在if语句外部进行，这样可能会导致这个变量的作用域超出预期，增加了出错的可能性。例如：\nstd::string s = &quot;Hello, world!&quot;;std::string::iterator it = s.begin();if (it != s.end()) &#123;    // 使用 it&#125;\n\n而在C++17中，可以直接在if语句中进行初始化，并且初始化的变量仅在if及其对应的else块（如果有）中可见：\nstd::string s = &quot;Hello, world!&quot;;if (auto it = s.begin(); it != s.end()) &#123;    // 使用 it&#125; else &#123;    // it 在这里不可见&#125;// it 在这里也不可见\n\nswitch语句中的初始化器类似地，switch语句也可以包含初始化器，这使得可以在进入不同的case标签前先安全地初始化一些局部变量。这对于需要根据某个值来初始化另一个值的情况特别有用。\n例如：\nint value = getValue();int divisor = 10; // 假设默认除数是10switch (value) &#123;    case 1:        divisor = 5;        // ...        break;    case 2:        divisor = 3;        // ...        break;    default:        // 使用 divisor&#125;\n\n使用C++17的新特性，可以将divisor的初始化直接放在switch语句内部：\nint value = getValue();switch (int divisor = 10; value) &#123; // 初始化divisor为10    case 1:        divisor = 5;        // ...        break;    case 2:        divisor = 3;        // ...        break;    default:        // 使用divisor&#125;// divisor 在这里不可见\n\n强制的复制消除复制消除：当满足特定条件时，可以省略从某个源对象创建具有相同类类型（忽略 cv 限定）的对象的操作，即使选择的构造函数和&#x2F;或析构函数具有副作用。这种对象创建操作的消除被称为复制消除 。\n“强制的复制消除”改进了编译器如何处理某些情况下对象的拷贝或移动构造函数的调用。这项特性特别针对的是返回值优化（Return Value Optimization, RVO）和具名返回值优化（Named Return Value Optimization, NRVO），但与之前的版本不同，C++17标准要求编译器必须执行这种优化，而不是像之前那样作为可选的优化。\n在C++17之前，RVO和NRVO是编译器可以进行的一种优化，目的是避免不必要的临时对象创建、拷贝或移动操作。例如，在以下情况：\nclass C &#123;public:    C() = default;    C(const C&amp;) &#123; std::cout &lt;&lt; &quot;Copy constructor\\n&quot;; &#125;    C(C&amp;&amp;) &#123; std::cout &lt;&lt; &quot;Move constructor\\n&quot;; &#125;&#125;;C f() &#123;    return C(); // 希望通过RVO避免调用拷贝/移动构造函数&#125;int main() &#123;    C obj = f();&#125;\n\n在早期的C++标准中，虽然很多现代编译器会尝试进行RVO来优化上述代码，使得obj直接在最终位置构造，而不需要额外的拷贝或移动，但这并不是强制性的。因此，是否实际发生拷贝或移动依赖于编译器实现。\nC++17引入了一个关键改变：当一个对象被从一个函数返回，并且该对象的类型与返回类型完全匹配时（包括cv限定符），编译器不再需要生成拷贝或移动构造函数的调用。这意味着即使类的拷贝或移动构造函数有副作用（如打印消息），这些副作用也不会发生。这不仅提高了性能，也减少了潜在的错误来源。\n考虑上面的例子，在C++17下，即使C类的拷贝和移动构造函数有副作用，编译器也会忽略它们，不会产生任何输出，因为没有实际的拷贝或移动操作被执行。\n示例说明\nstruct Large &#123;    Large() &#123;&#125;    Large(const Large&amp;) &#123; std::cout &lt;&lt; &quot;Copy\\n&quot;; &#125;    Large(Large&amp;&amp;) &#123; std::cout &lt;&lt; &quot;Move\\n&quot;; &#125;&#125;;Large create() &#123;    return Large(); // 在C++17前可能调用移动构造，在C++17及之后不会有任何构造函数被调用&#125;int main() &#123;    Large l = create(); // 在C++17下，l将直接在最终位置构造，无需拷贝或移动    // 在C++17中，由于强制的复制消除，create()函数中的Large对象将直接在main函数中变量l的位置上构造，而不经过任何形式的拷贝或移动。&#125;\n\n优点：\n强制的复制消除显著提升了C++程序的效率，减少了不必要的构造函数调用，同时保持了语义的一致性。这对于资源密集型的对象尤其重要，因为它允许更高效地管理资源，减少内存分配和释放的开销。此外，这也意味着程序员可以编写更加直观的返回局部对象的代码，而不用担心性能上的损失。\n临时量实质化临时量实质化（Temporary Materialization）定义了纯右值（prvalue）在什么情况下会被转换为亡值（xvalue），即创建一个临时对象的过程。\n临时量实质化的条件:\n\n绑定引用到纯右值时：当尝试将一个引用绑定到一个纯右值时，需要先将该纯右值实质化为一个临时对象。\n访问类纯右值的数据成员时：例如，S().m，其中S()是一个纯右值，访问其成员变量m会促使该纯右值被实质化为一个临时对象。\n调用类纯右值的隐式对象成员函数时：如果对一个纯右值调用了某个成员函数，那么该纯右值首先会被实质化为一个临时对象。\n进行数组到指针转换或在数组纯右值上使用下标时：处理数组类型的纯右值时，如需转换为指针或使用下标操作，也会导致临时量实质化。\n以花括号初始化器列表初始化 std::initializer_list&lt;T&gt; 类型的对象时：这涉及到使用初始化列表来构造对象的情况。\n纯右值作为弃值表达式时：当纯右值被用作不关心结果的表达式时，可能需要实质化。\n\n官方案例：\nstruct S &#123; int m; &#125;;int k = S().m; // C++17 起成员访问期待泛左值；               // S() 纯右值被转换成亡值\n\n在这个例子中，S() 创建了一个类型为 S 的纯右值。由于我们试图访问它的成员变量 m，这要求该纯右值必须首先被实质化为一个临时对象，之后才能对其成员进行访问。因此，在C++17中，S() 会被实质化为一个临时对象，然后通过这个临时对象访问成员 m。\n从纯右值直接初始化同类型对象（无论是通过直接初始化还是复制初始化）并不会触发临时量实质化。这是因为C++17引入了“受保证的复制消除”机制，这意味着编译器可以直接使用源纯右值来初始化目标对象，而不需要创建中间的临时对象。这一特性不仅提高了性能，也简化了程序逻辑。\n\n可以理解为隐式转化的规则之一\n\n模板折叠表达式 ( … )C++17引入了一个称为折叠表达式的新特性，它极大地简化了对参数包（…）的操作。这个特性主要用于模板编程中，使得对不定数量的模板参数进行操作变得更加简单和直观。\n在c++17之前，对参数包进行操作通常需要使用递归或辅助函数或者是使用初始化列表。既麻烦还难看。\nc++17之前：\n// 递归template&lt;typename T&gt;T sum(T n) &#123;    return n;&#125;template&lt;typename T, typename... Args&gt;T sum(T first, Args... rest) &#123;    return first + sum(rest...);&#125;// 初始化列表template&lt;typename... Args&gt;auto sum(Args... args) -&gt; decltype((args + ...)) &#123;    decltype((args + ...)) result&#123;&#125;; // 初始化结果变量为0    (void)std::initializer_list&lt;int&gt;&#123;([&amp;] &#123; result += args; &#125;(), 0)...&#125;;    return result;&#125;// 折叠表达式template&lt;typename... Args&gt;auto sum(Args... args) -&gt; decltype((args + ...)) &#123;    return (args + ...);&#125;\n\n折叠表达式的语法与规则：\n语法折叠表达式主要分为四种形式：\n一元右折叠 (E 运算符 …)：从左至右依次应用运算符。一元左折叠 (… 运算符 E)：从右至左依次应用运算符。二元右折叠 (E 运算符 … 运算符 I)：从左至右依次应用运算符，并以I作为初始值。二元左折叠 (I 运算符 … 运算符 E)：从右至左依次应用运算符，并以I作为初始值。\n其中，运算符可以是C++中的32个二元运算符之一，如+, -, *, &#x2F;, %, ^, &amp;, |, &#x3D;, &lt;, &gt;, &lt;&lt;, &gt;&gt;, +&#x3D;, -&#x3D;, &#x3D;, &#x2F;&#x3D;, %&#x3D;, ^&#x3D;, &amp;&#x3D;, |&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&#x3D;, &#x3D;&#x3D;, !&#x3D;, &lt;&#x3D;, &gt;&#x3D;, &amp;&amp;, ||, ,, ., -&gt;*等。\n特殊情况当一元折叠应用于长度为零的参数包时，仅允许使用特定的运算符：逻辑与（&amp;&amp;），其值为true；逻辑或（||），其值为false；以及逗号运算符（,），其值为void()。\n例：\ntemplate&lt;typename... Args&gt;bool all(Args... args) &#123;    return (... &amp;&amp; args); // 使用一元左折叠&#125;// 如果调用all(true, true, true, false)，那么折叠表达式会展开为((true &amp;&amp; true) &amp;&amp; true) &amp;&amp; false，结果为false。// 1template&lt;typename... Args&gt;void printer(Args&amp;&amp;... args) &#123;    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; &#x27;\\n&#x27;; // 使用折叠表达式&#125;int main() &#123;    printer(1, 2, 3, &quot;abc&quot;); // 输出: 123abc&#125;// 2template&lt;typename T, typename... Args&gt;void push_back_vec(std::vector&lt;T&gt;&amp; v, Args&amp;&amp;... args) &#123;    static_assert((std::is_constructible_v&lt;T, Args&amp;&amp;&gt; &amp;&amp; ...));    (v.push_back(std::forward&lt;Args&gt;(args)), ...);&#125;int main() &#123;    std::vector&lt;int&gt; v;    push_back_vec(v, 6, 2, 45, 12);    for(int i : v) std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; // 输出: 6 2 45 12&#125;\n\n类模板实参推导 tuple t(4, 3, 2.5)C++17引入了类模板实参推导（Class Template Argument Deduction，简称CTAD），这是一项允许编译器自动推断出类模板实例化时所需的模板参数值的功能。这项特性简化了许多情况下需要手动指定模板参数的需求，从而减少了代码的冗余和复杂性。\nc++17之前：\nstd::pair&lt;int, double&gt; p(2, 4.5);\n\nc++17后：\nstd::pair p(2, 4.5); // 编译器可以自动推断出模板参数\n\n为了支持CTAD，C++17允许定义推导指引。\n推导指引是特殊的声明，用于指导编译器如何从构造函数参数推导出模板参数。它们可以是隐式生成的，也可以由用户显式定义。\n\n隐式生成的推导指引：编译器会为每个构造函数自动生成相应的推导指引。\n用户定义的推导指引：用户可以定义自己的推导指引来覆盖默认行为或处理特殊情况。\n\n用户自定义推导指引的语法：\ntemplate&lt;class T&gt; struct A &#123;    A(T, int*);&#125;;template&lt;class T&gt;A(T*, int*) -&gt; A&lt;T&gt;; // 用户定义的推导指引int i, *ip;A a&#123;i, ip&#125;; // 自动推导为 A&lt;int&gt;\n\n\n没有完全搞懂，先放案例吧。。。\n\n注意：\nCTAD仅在未提供模板实参列表的情况下发生。如果提供了模板实参列表，则不会触发推导。在某些情况下，如存在多个可能的推导指引时，编译器会根据一定的优先级规则选择最合适的推导指引。复制推导候选通常比包装构造函数更受偏好，以避免不必要的嵌套。\nauto 占位的非类型模板形参在C++17之前，非类型模板参数（non-type template parameters, NTTPs）必须显式地指定其类型。例如：\ntemplate&lt;int N&gt; //这里，N是一个整数类型的非类型模板参数。struct S &#123;    void foo() &#123; /* ... */ &#125;&#125;;\n\nC++17的新方式通过C++17的增强，我们可以使用auto关键字来代替具体的类型，这为模板提供了更大的灵活性和通用性。例如：\ntemplate&lt;auto N&gt;struct S &#123;    void foo() &#123; /* ... */ &#125;&#125;;\n\n在这个例子中，N可以是任何能作为非类型模板参数的值，无论它是int, long, double还是指针等。这意味着您不再需要为每种可能的类型分别编写模板特化或重载。\n注意事项:\n\n虽然auto使得模板更加通用，但它不能用于所有类型的非类型模板参数。例如，类类型的对象（除非它们是字面量类型且有适当的转换构造函数）不能作为非类型模板参数。\n此外，使用auto作为非类型模板形参时，不能与占位类型（placeholder types）如T结合使用于同一个模板形参列表内，这是为了避免歧义和复杂性。\n\n命名空间简化的嵌套命名空间c++11中嵌套命名空间的语法：\nnamespace A &#123;    namespace B &#123;        namespace C &#123;            // 在这里定义 C 命名空间的内容        &#125;    &#125;&#125;\n\nc++17中简化的嵌套命名空间的语法：\nnamespace A::B::C &#123;    // 在这里定义 C 命名空间的内容&#125;\n\nusing 声明语句可以声明多个名称using声明语句得到了增强，允许一次导入多个名称（如类型、函数或模板）从一个命名空间到另一个命名空间。这项改进简化了代码，减少了重复的using声明需求。\nc++14中：\nnamespace foo &#123;    void f() &#123;&#125;    void g() &#123;&#125;    void h() &#123;&#125;&#125;using foo::f;using foo::g;using foo::h;\n\nc++17后：\nnamespace foo &#123;    void f() &#123;&#125;    void g() &#123;&#125;    void h() &#123;&#125;&#125;using foo::&#123;f, g, h&#125;;\n\n属性命名空间不必重复在C++17中，对于属性的使用有了改进，使得当多个属性属于同一个命名空间时，不必为每个属性都重复指定命名空间。具体来说，如果一组属性都位于同一个命名空间内（例如std::literals），您可以一次性指定这个命名空间，然后列出所有需要使用的属性，而不需要对每个属性名都加上完整的命名空间前缀。\n在C++17之前，如果您想要使用来自特定命名空间的多个属性，您可能需要这样写：\nvoid function() [[std::literals::fast_math]] [[std::literals::ivdep]] [[std::literals::align_value(16)]];\n\n但在C++17中，通过使用[[using namespace_name: …]]语法，可以简化为：\nvoid function() [[using std::literals: fast_math, ivdep, align_value(16)]]; \n\n属性说明符序列 (C++11 起)为类型、对象、代码等引入由实现定义的属性。\n语法[[ 属性列表 ]]  (C++11 起)[[ using 属性命名空间 : 属性列表 ]]  (C++17 起)其中属性列表 是由逗号分隔的零或更多个属性 的序列（可以以指示包展开的省略号 … 结束）\n标识符属性命名空间 :: 标识符标识符 ( 实参列表 (可选) )属性命名空间 :: 标识符 ( 实参列表 (可选) )其中属性命名空间为一个标识符，而实参列表为其中圆括号、方括号和花括号平衡出现的记号序列（平衡记号序列）。\n\n简单属性，例如 [[noreturn]]。\n有命名空间的属性，例如 [[gnu::unused]]。\n有实参的属性，例如 [[deprecated(“原因”)]]。\n既有命名空间又有实参列表的属性。\n\n\n\n除了以下所列出的标准属性之外，实现还可能支持拥有由实现定义的行为的任意非标准属性。所有实现所未知的属性均被忽略，且不产生错误。\n\n新属性[fallthrough]指示从前一标号直落是有意的，而在发生直落时给出警告的编译器不应诊断它。\n直落语句只能用在 switch 语句中，其中待执行的下个语句是该 switch 语句的带 case 或 default 标号的语句。如果直落语句在循环中，那么下个（带标号）语句必须是该循环的同一迭代的一部分。\n实例：\nvoid f(int n)&#123;    void g(), h(), i();     switch (n)    &#123;        case 1:        case 2:            g();            [[fallthrough]];        case 3: // 直落时不警告            h();        case 4: // 编译器可在发生直落时警告            if (n &lt; 3)            &#123;                i();                [[fallthrough]]; // OK            &#125;            else            &#123;                return;            &#125;        case 5:            while (false)            &#123;                [[fallthrough]]; // 非良构：下一语句不是同一迭代的一部分            &#125;        case 6:            [[fallthrough]]; // 非良构：没有后继的 case 或 default 标号    &#125;&#125;\n\n[maybe_unused]抑制针对未使用实体的警告。\n此属性可出现在下列实体的声明中：class/struct/union：struct [[maybe_unused]] S;typedef，包括别名声明：[[maybe_unused]] typedef S* PS;，using PS [[maybe_unused]] = S*;变量，包括静态数据成员：[[maybe_unused]] int x;非静态数据成员：union U &#123; [[maybe_unused]] int n; &#125;;函数：[[maybe_unused]] void f();枚举：enum [[maybe_unused]] E &#123;&#125;;枚举项：enum &#123; A [[maybe_unused]], B [[maybe_unused]] = 42 &#125;;结构化绑定：[[maybe_unused]] auto [a, b] = std::make_pair(42, 0.23);对于声明为 [[maybe_unused]] 的实体，如果没有使用这些实体或它们的结构化绑定，那么编译器针对未使用实体发布的警告会被抑制。\n\n[nodiscard]在转换到 void 之外的弃值表达式中调用声明为 nodiscard 的函数，或调用按值返回声明为 nodiscard 的枚举或类的函数时，鼓励编译器发布警告。\n\n在C++中，“弃值表达式”是指那些计算结果被有意忽略、不用于任何后续操作的表达式。通常情况下，这意味着表达式的值没有被存储到变量中，也没有作为参数传递给函数等。例如：调用函数仅为了其副作用：有时我们调用一个函数主要是为了它的副作用（如打印输出、修改全局状态等），而不是关心它的返回值。在这种情况下，函数的返回值就被忽略了。std::puts(&quot;Hello, world!&quot;);// 例如，std::puts 返回写入的字符数，但我们通常只关心它是否成功执行了打印操作\n\n__has_include语法：#include &lt; h字符序列 &gt; 换行 (1)#include “ q字符序列 “ 换行 (2)#include 记号序列 换行 (3)__has_include ( “ q字符序列 “ )__has_include ( &lt; h字符序列 &gt; ) (4) (C++17 起)__has_include ( 字符串字面量 )__has_include ( &lt; h记号序列 &gt; ) (5) (C++17 起)\n\n搜索由 h字符序列 唯一识别的标头，并将该指令替换为这个标头的全部内容。\n搜索由 q字符序列 识别的源文件，并将该指令替换为这个源文件的全部内容。可能退回至语法 (1) 并将 q字符序列 视为标头标识符。\n如果 (1) 和 (2) 都不匹配，记号序列 会经历宏替换。该指令在替换后会再次尝试匹配 (1) 和 (2)。\n检查是否可以包含一个标头或源文件。\n如果 (4) 不匹配，h记号序列 会经历宏替换。该指令在替换后会再次尝试匹配 (4)。换行 - 换行字符h字符序列 - 一个或多个 h字符 的序列，并且其中以下内容的出现受条件性支持：\n\n\n字符 ‘\n字符 “\n字符 \\\n字符序列 &#x2F;&#x2F;\n字符序列 &#x2F;*\n\nh字符 - 源字符集(C++23 前)翻译字符集(C++23 起) 除了换行符和 &gt; 以外的任何成员q字符序列 - 一个或多个 q字符 的序列，并且其中以下内容的出现受条件性支持：\n\n字符 ‘\n字符 \\\n字符序列 &#x2F;&#x2F;\n字符序列 &#x2F;*\n\nq字符 - 源字符集(C++23 前)翻译字符集(C++23 起) 除了换行符和 “ 以外的任何成员记号序列 - 一个或多个预处理记号的序列字符串字面量 - 一个字符串字面量h记号序列 - 一个或多个除了 &gt; 以外的预处理记号的序列\n这个特性是因为社区对头文件有了更深的理解才诞生的。实例：\n#if __has_include(&lt;optional&gt;)    #include &lt;optional&gt;    #define has_optional 1    template&lt;class T&gt;    using optional_t = std::optional&lt;T&gt;;#elif __has_include(&lt;experimental/optional&gt;)    #include &lt;experimental/optional&gt;    #define has_optional -1    template&lt;class T&gt;    using optional_t = std::experimental::optional&lt;T&gt;;#else    #define has_optional 0    template&lt;class V&gt;    class optional_t    &#123;        V v&#123;&#125;;        bool has&#123;&#125;;     public:        optional_t() = default;        optional_t(V&amp;&amp; v) : v(v), has&#123;true&#125; &#123;&#125;        V value_or(V&amp;&amp; alt) const&amp;        &#123;            return has ? v : alt;        &#125;        // etc.    &#125;;#endif #include &lt;iostream&gt; int main()&#123;    if (has_optional &gt; 0)        std::cout &lt;&lt; &quot;&lt;optional&gt; 存在\\n&quot;;    else if (has_optional &lt; 0)        std::cout &lt;&lt; &quot;&lt;experimental/optional&gt; 存在\\n&quot;;    else        std::cout &lt;&lt; &quot;&lt;optional&gt; 不存在\\n&quot;;     optional_t&lt;int&gt; op;    std::cout &lt;&lt; &quot;op = &quot; &lt;&lt; op.value_or(-1) &lt;&lt; &#x27;\\n&#x27;;    op = 42;    std::cout &lt;&lt; &quot;op = &quot; &lt;&lt; op.value_or(-1) &lt;&lt; &#x27;\\n&#x27;;&#125;\n\n新的头文件&lt;any&gt;&lt;charconv&gt;&lt;execution&gt;&lt;filesystem&gt;&lt;memory_resource&gt;&lt;optional&gt;&lt;string_view&gt;&lt;variant&gt;\n","tags":["cpp"]}]