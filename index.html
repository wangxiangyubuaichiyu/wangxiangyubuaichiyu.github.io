<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="故事开始于2025&#x2F;2&#x2F;24 15：47">
<meta property="og:type" content="website">
<meta property="og:title" content="blogWxy">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="blogWxy">
<meta property="og:description" content="故事开始于2025&#x2F;2&#x2F;24 15：47">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wxy">
<meta property="article:tag" content="cpp python QT 算法 编程技术">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blogWxy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blogWxy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Wxy">
      <meta itemprop="description" content="故事开始于2025/2/24 15：47">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blogWxy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/undefined/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-01 11:37:08" itemprop="dateCreated datePublished" datetime="2025-04-01T11:37:08+08:00">2025-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-25 13:14:29" itemprop="dateModified" datetime="2025-02-25T13:14:29+08:00">2025-02-25</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c-17新特性"><a href="#c-17新特性" class="headerlink" title="c++17新特性"></a>c++17新特性</h1><p>C++17 是小版本 C++14 之后的一个大版本，它提供了新的语言和库功能特性。该标准于 2017 年 12 月发布。</p>
<h2 id="移除或弃用的特性"><a href="#移除或弃用的特性" class="headerlink" title="移除或弃用的特性"></a>移除或弃用的特性</h2><h3 id="已移除特性"><a href="#已移除特性" class="headerlink" title="已移除特性"></a>已移除特性</h3><ol>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/memory/auto_ptr">std::auto_ptr</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/utility/functional#.E6.97.A7.E5.BC.8F.E7.BB.91.E5.AE.9A.E5.99.A8.E4.B8.8E.E9.80.82.E9.85.8D.E5.99.A8">已弃用的函数对象</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/random_shuffle">std::random_shuffle</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/error/unexpected">std::unexpected</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/io/ios_base#.E5.BC.83.E7.94.A8.E7.9A.84.E6.88.90.E5.91.98.E7.B1.BB.E5.9E.8B">过时的 iostream 别名</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/operator_alternative#.E4.B8.89.E6.A0.87.E7.AC.A6_.28C.2B.2B17_.E4.B8.AD.E7.A7.BB.E9.99.A4.29">三标符</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/keyword/register">register 关键字</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/operator_incdec">bool 类型的自增操作</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/except_spec">动态异常说明</a></li>
</ol>
<h3 id="弃用特性"><a href="#弃用特性" class="headerlink" title="弃用特性"></a>弃用特性</h3><ol>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/iterator/iterator">std::iterator</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/memory/raw_storage_iterator">std::raw_storage_iterator</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/memory/get_temporary_buffer">std::get_temporary_buffer</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/types/is_literal_type">std::is_literal_type</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/types/result_of">std::result_of</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/codecvt">整个 &lt;codecvt&gt; 头文件</a></li>
</ol>
<blockquote>
<p>因为这些特性之前并没有被广泛使用，所以对此没有太多了解。只讲链接进行保存，有需要的可以去查看。</p>
</blockquote>
<h2 id="新的语言特性"><a href="#新的语言特性" class="headerlink" title="新的语言特性"></a>新的语言特性</h2><h3 id="u8-字符字面量"><a href="#u8-字符字面量" class="headerlink" title="u8 字符字面量"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/character_literal">u8 字符字面量</a></h3><p>语法：<code>u8&#39;c字符 &#39;</code></p>
<p>UTF-8 字符字面量，例如 u8’a’。这种字面量具有 char(C++20 前)char8_t(C++20 起) 类型，且它的值等于c字符的 ISO&#x2F;IEC 10646 码位值，只要码位值能以单个 UTF-8 代码单元表示（即c字符 处于范围 0x0-0x7F（含边界）内）。</p>
<p>u8 字符字面量的类型为 char8_t，它是一个新的字符类型，它的大小和 char 相同，但是它的字符集是 UTF-8 字符集。</p>
<h3 id="将-noexcept-作为类型系统的一部分"><a href="#将-noexcept-作为类型系统的一部分" class="headerlink" title="将 noexcept 作为类型系统的一部分"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/noexcept_spec">将 noexcept 作为类型系统的一部分</a></h3><p>这个字面量在c++11标准加入，在c++7标准正式成为标准的一部分。作用是在函数声明和定义中使用，用于指定函数是否可以抛出异常。</p>
<h3 id="新的求值顺序规则"><a href="#新的求值顺序规则" class="headerlink" title="新的求值顺序规则"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/eval_order">新的求值顺序规则</a></h3><p>在C++中，除非有明确的规则定义，否则表达式的任何部分（包括函数参数）的求值顺序是未指定的。这意味着编译器可以自由选择求值顺序，并且可以在不同时间点以不同的顺序进行求值。</p>
<p>在C++17之前，C++标准使用的是序列点的概念来描述何时副作用必须完成以及何时可以安全地访问一个对象的值而不导致未定义行为。例如，在同一内存位置上的两次副作用之间如果没有适当的序列点，则会导致未定义行为。典型例子包括对同一个变量进行前置或后置自增&#x2F;自减操作而没有正确地分隔这些操作的情况。</p>
<p>C++17引入了一些重要的变化和新增规则来改进求值顺序的规定，主要包括：</p>
<p>明确了某些情况下的求值顺序：C++17明确规定了一些过去求值顺序不明确的情况。例如，在调用函数时，所有实参表达式的求值顺序现在是未指明的而非未定义的。这允许编译器优化代码但避免了完全未定义的行为。<br>避免未定义行为：对于一些特定的表达式，如i &#x3D; ++i + i++;，在C++17之前会导致未定义行为，因为它们在同一内存位置上进行了无序的读写操作。虽然这种表达式仍然被认为是不好的编程实践，但在C++17中，其行为被更清晰地定义为未定义行为，而不是依赖于编译器实现的具体细节。<br>具体的表达式示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = ++i + <span class="number">2</span>; <span class="comment">//在C++17下具有良好的定义。</span></span><br><span class="line">i = i++ + <span class="number">2</span>; <span class="comment">//在C++17前行为是未定义的，但C++17并没有改变这一点。</span></span><br><span class="line"><span class="built_in">f</span>(i = <span class="number">-2</span>, i = <span class="number">-2</span>); 和 <span class="built_in">f</span>(++i, ++i); <span class="comment">//在C++17之前是未定义行为，但在C++17中，这些表达式的求值顺序变为未指明，即允许任意顺序执行，但不会造成未定义行为。</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda-表达式捕获-this"><a href="#lambda-表达式捕获-this" class="headerlink" title="lambda 表达式捕获 *this"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/lambda#Lambda_.E6.8D.95.E8.8E.B7">lambda 表达式捕获 *this</a></h3><p>在[]可以捕获*this，表示：当前对象的简单的按复制捕获</p>
<blockquote>
<p>与this的区别：</p>
<ol>
<li>捕获this时，this的类型是指针类型，而捕获*this时，this的类型是引用类型。</li>
<li>捕获this时，this指向的是当前对象，而捕获*this时，this指向的是当前对象的副本。</li>
</ol>
</blockquote>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">S2::f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [=] &#123;&#125;;        <span class="comment">// OK：默认按复制捕获</span></span><br><span class="line">    [=, &amp;i] &#123;&#125;;    <span class="comment">// OK：按复制捕获，但 i 按引用捕获</span></span><br><span class="line">    [=, *<span class="keyword">this</span>] &#123;&#125;; <span class="comment">// C++17 前：错误：无效语法</span></span><br><span class="line">                   <span class="comment">// C++17 起：OK：按复制捕获外围的 S2</span></span><br><span class="line">    [=, <span class="keyword">this</span>] &#123;&#125;;  <span class="comment">// C++20 前：错误：= 为默认时的 this</span></span><br><span class="line">                   <span class="comment">// C++20 起：OK：同 [=]</span></span><br><span class="line">    [i, i] &#123;&#125;;        <span class="comment">// 错误：i 重复</span></span><br><span class="line">    [<span class="keyword">this</span>, *<span class="keyword">this</span>] &#123;&#125;; <span class="comment">// 错误：&quot;this&quot; 重复（C++17）</span></span><br><span class="line">    [i] (<span class="type">int</span> i) &#123;&#125;;   <span class="comment">// 错误：形参和捕获的名字相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><h4 id="编译期的-constexpr-if-语句"><a href="#编译期的-constexpr-if-语句" class="headerlink" title="编译期的 constexpr if 语句"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/if">编译期的 constexpr if 语句</a></h4><p>if语句：<br>属性 (可选) if constexpr(可选) ( 初始化语句 (可选) 条件 ) true分支语句 else false分支语句</p>
<p>参数介绍：<br>属性-(C++11 起) 任意数量的属性<br>constexpr-(C++17 起) 出现时，该语句是 constexpr if 语句<br>初始化语句-(C++17 起) 下列之一：</p>
<ul>
<li>表达式语句（可以是空语句 ;）</li>
<li>简单声明，典型的是带初始化器的变量声明，但它可以声明任意多个变量，或是一条结构化绑定声明</li>
<li>别名声明(C++23 起)</li>
</ul>
<blockquote>
<p>注意，任何初始化语句都应以分号 ; 结束。这是它常被非正式地描述成后随分号的表达式或声明的原因。</p>
</blockquote>
<p>条件-条件<br>true分支语句-任意当条件求值为 true 时会执行的语句<br>false分支语句-当条件求值为 false 时会执行的语句<br>复合语句-当此 if 语句在明显常量求值语境下求值时会执行的复合语句（consteval 前附 ! 的情况下条件变成“不在这种语境下求值”）<br>语句-当此 if 语句不在明显常量求值语境下求值时会执行的语句（consteval 未前附 ! 的情况下条件变成“在这种语境下求值”）</p>
<p>以 if constexpr 开始的语句被称为 constexpr if 语句。constexpr if 语句的所有子语句都是有控制流限制的语句。</p>
<p>在 constexpr if 语句中，条件的值必须是可按语境转换到 bool 类型的经转换常量表达式(C++23 前)按语境转换到 bool 的表达式，其中转换为常量表达式(C++23 起)。</p>
<p>如果条件的值是 true，那么舍弃 false分支语句（如果存在），否则舍弃 true分支语句。</p>
<p><strong>简单来说：<br>constexpr if（自C++17起）：这种形式的 if 语句允许编译时分支选择，对于模板编程特别有用。在 constexpr if 中，根据条件表达式的值，编译器可以选择编译或忽略特定的分支。</strong></p>
<blockquote>
<p>但是if constexpr 不是 #if 预处理指令的替代品。</p>
</blockquote>
<h4 id="constexpr-的-lambda-表达式"><a href="#constexpr-的-lambda-表达式" class="headerlink" title="constexpr 的 lambda 表达式"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/lambda">constexpr 的 lambda 表达式</a></h4><p>constexpr lambda：从C++17开始，lambda表达式可以被声明为constexpr，这意味着如果lambda满足成为constexpr函数的所有要求，它就可以在编译时常量表达式中使用。这使得lambda表达式可以在更多的上下文中使用，比如作为非类型的模板参数。 示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getId = [](<span class="keyword">auto</span> x) <span class="keyword">constexpr</span> &#123; <span class="keyword">return</span> x.id; &#125;;</span><br></pre></td></tr></table></figure>

<p>其他有关lambda的特性：</p>
<p>Lambda捕获表达式中的初始化<br>捕获列表中的初始化器：C++17允许在lambda表达式的捕获列表中直接初始化变量。这对于复制或移动捕获特别有用，并且可以简化代码逻辑。 示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [x = std::<span class="built_in">move</span>(x)]() &#123; <span class="keyword">return</span> x; &#125;; <span class="comment">// 使用std::move来捕获x</span></span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="inline-变量"><a href="#inline-变量" class="headerlink" title="inline 变量"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/inline">inline 变量</a></h4><p>在此之前，inline主要用于函数和成员函数，允许在多个翻译单元中提供函数定义而不导致链接错误。自C++17起，标准引入了对inline变量的支持，这是C++17相对于之前版本的一个重要更新。</p>
<p>inline变量（C++17）<br>定义：从C++17开始，变量可以被声明为inline。这使得可以在多个翻译单元（每个源文件为一个翻译单元）中提供相同变量的定义，而不会导致链接时的重复定义错误。这一特性特别适用于常量，因为它允许常量在头文件中定义，并且该头文件可以被多个源文件包含而不会引起冲突。<br>使用场景：<br>当你需要在多个源文件之间共享一个常量或变量时，inline变量是一个理想的解决方案。<br>对于模板编程也非常有用，因为现在你可以定义内联静态数据成员而不需要在每个翻译单元中都提供单独的定义。<br>语法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> MAX_LIMIT = <span class="number">100</span>; <span class="comment">// C++17 及之后</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，MAX_LIMIT被声明为一个inline静态成员变量。这意味着你可以在多个源文件中包含这个头文件而不会遇到重复定义的问题。</p>
<p>但是这个特性也有一些问题，比如编译器是否支持。<br><img src="/image.png" alt="alt text"></p>
<h4 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/structured_binding">结构化绑定</a></h4><p>结构化绑定允许更方便地将复合类型的成员解包到独立的变量中。这项功能特别适用于处理tuple、pair、数组以及具有多个成员的结构体或类实例的情况。</p>
<p>语法与参数：</p>
<p>属性 (可选) 声明说明符序列 引用限定符 (可选) [ 绑定标识符列表 ] 初始化器 ;<br>属性-任意数量的属性的序列<br>decl-specifier-seq-包含以下说明符的序列（遵循简单声明的规则）：<br>    constexpr<br>    constinit<br>    (C++26 起)<br>    static<br>    thread_local<br>    const<br>    volatile<br>    auto<br>引用限定符-&amp; 或 &amp;&amp; 之一<br>绑定标识符列表-此声明所引入的各标识符的逗号分隔的列表，每个标识符可以后随一个属性说明符序列(C++26 起)<br>初始化器-初始化器（见下文）</p>
<p>初始化器 必须是下列之一：<br>&#x3D; 表达式<br>{ 表达式 }<br>( 表达式 )<br>表达式-（无括号的逗号表达式以外的）任意表达式</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [name1, name2, ..., nameN] = expression;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解绑std::tuple</span></span><br><span class="line">    <span class="keyword">auto</span> tupleExample = std::<span class="built_in">make_tuple</span>(<span class="number">10</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> [num, str, pi] = tupleExample;</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解绑数组</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [a, b, c] = arr;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解绑结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = p;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指针绑定：虽然不常见，但你也可以将结果绑定到指针上。</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; [refX, refY] = p; <span class="comment">// 绑定为引用</span></span><br><span class="line">    <span class="keyword">auto</span>* [ptrX, ptrY] = &amp;p; <span class="comment">// 绑定为指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕获列表中的使用：结构化绑定也可用于lambda表达式的捕获列表中，这使得在lambda内部可以更容易地访问复杂数据结构的成员。</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = [&amp;r = data] &#123; <span class="comment">/* 使用 r */</span> &#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项<br>引用绑定：你可以通过在声明时添加&amp;或&amp;&amp;来创建对原对象的引用，而不是进行值复制。</p>
</blockquote>
<h4 id="if-和-switch-语句中的初始化器"><a href="#if-和-switch-语句中的初始化器" class="headerlink" title="if 和 switch 语句中的初始化器"></a>if 和 switch 语句中的初始化器</h4><p>在C++17中，if和switch语句得到了增强，允许在其条件表达式中包含初始化器。这项改进使得可以在控制流语句的上下文中声明并初始化变量，同时该变量的作用域被限制在对应的if或switch语句块内。这不仅提升了代码的安全性和可读性，还减少了潜在的错误，比如忘记在不同分支中正确地初始化变量。</p>
<h5 id="if语句中的初始化器"><a href="#if语句中的初始化器" class="headerlink" title="if语句中的初始化器"></a>if语句中的初始化器</h5><p>在C++17之前，如果需要在条件判断之前初始化一个变量，通常需要在if语句外部进行，这样可能会导致这个变量的作用域超出预期，增加了出错的可能性。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">std::string::iterator it = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span> (it != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 使用 it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在C++17中，可以直接在if语句中进行初始化，并且初始化的变量仅在if及其对应的else块（如果有）中可见：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::string s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 使用 it</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// it 在这里不可见</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it 在这里也不可见</span></span><br></pre></td></tr></table></figure>

<h5 id="switch语句中的初始化器"><a href="#switch语句中的初始化器" class="headerlink" title="switch语句中的初始化器"></a>switch语句中的初始化器</h5><p>类似地，switch语句也可以包含初始化器，这使得可以在进入不同的case标签前先安全地初始化一些局部变量。这对于需要根据某个值来初始化另一个值的情况特别有用。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="built_in">getValue</span>();</span><br><span class="line"><span class="type">int</span> divisor = <span class="number">10</span>; <span class="comment">// 假设默认除数是10</span></span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        divisor = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        divisor = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 使用 divisor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用C++17的新特性，可以将divisor的初始化直接放在switch语句内部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> value = <span class="built_in">getValue</span>();</span><br><span class="line"><span class="keyword">switch</span> (<span class="type">int</span> divisor = <span class="number">10</span>; value) &#123; <span class="comment">// 初始化divisor为10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        divisor = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        divisor = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 使用divisor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// divisor 在这里不可见</span></span><br></pre></td></tr></table></figure>

<h4 id="强制的复制消除"><a href="#强制的复制消除" class="headerlink" title="强制的复制消除"></a>强制的复制消除</h4><p>复制消除：当满足特定条件时，可以省略从某个源对象创建具有相同类类型（忽略 cv 限定）的对象的操作，即使选择的构造函数和&#x2F;或析构函数具有副作用。这种对象创建操作的消除被称为复制消除 。</p>
<p>“强制的复制消除”改进了编译器如何处理某些情况下对象的拷贝或移动构造函数的调用。这项特性特别针对的是返回值优化（Return Value Optimization, RVO）和具名返回值优化（Named Return Value Optimization, NRVO），但与之前的版本不同，C++17标准要求编译器必须执行这种优化，而不是像之前那样作为可选的优化。</p>
<p>在C++17之前，RVO和NRVO是编译器可以进行的一种优化，目的是避免不必要的临时对象创建、拷贝或移动操作。例如，在以下情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">const</span> C&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">C</span>(C&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Move constructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">C <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(); <span class="comment">// 希望通过RVO避免调用拷贝/移动构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C obj = <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在早期的C++标准中，虽然很多现代编译器会尝试进行RVO来优化上述代码，使得obj直接在最终位置构造，而不需要额外的拷贝或移动，但这并不是强制性的。因此，是否实际发生拷贝或移动依赖于编译器实现。</p>
<p>C++17引入了一个关键改变：当一个对象被从一个函数返回，并且该对象的类型与返回类型完全匹配时（包括cv限定符），编译器不再需要生成拷贝或移动构造函数的调用。这意味着即使类的拷贝或移动构造函数有副作用（如打印消息），这些副作用也不会发生。这不仅提高了性能，也减少了潜在的错误来源。</p>
<p>考虑上面的例子，在C++17下，即使C类的拷贝和移动构造函数有副作用，编译器也会忽略它们，不会产生任何输出，因为没有实际的拷贝或移动操作被执行。</p>
<p>示例说明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Large</span> &#123;</span><br><span class="line">    <span class="built_in">Large</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Large</span>(<span class="type">const</span> Large&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">Large</span>(Large&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Move\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Large <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Large</span>(); <span class="comment">// 在C++17前可能调用移动构造，在C++17及之后不会有任何构造函数被调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Large l = <span class="built_in">create</span>(); <span class="comment">// 在C++17下，l将直接在最终位置构造，无需拷贝或移动</span></span><br><span class="line">    <span class="comment">// 在C++17中，由于强制的复制消除，create()函数中的Large对象将直接在main函数中变量l的位置上构造，而不经过任何形式的拷贝或移动。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>强制的复制消除显著提升了C++程序的效率，减少了不必要的构造函数调用，同时保持了语义的一致性。这对于资源密集型的对象尤其重要，因为它允许更高效地管理资源，减少内存分配和释放的开销。此外，这也意味着程序员可以编写更加直观的返回局部对象的代码，而不用担心性能上的损失。</p>
<h4 id="临时量实质化"><a href="#临时量实质化" class="headerlink" title="临时量实质化"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/implicit_conversion#.E4.B8.B4.E6.97.B6.E9.87.8F.E5.AE.9E.E8.B4.A8.E5.8C.96">临时量实质化</a></h4><p>临时量实质化（Temporary Materialization）定义了纯右值（prvalue）在什么情况下会被转换为亡值（xvalue），即创建一个临时对象的过程。</p>
<p>临时量实质化的条件:</p>
<ol>
<li>绑定引用到纯右值时：当尝试将一个引用绑定到一个纯右值时，需要先将该纯右值实质化为一个临时对象。</li>
<li>访问类纯右值的数据成员时：例如，S().m，其中S()是一个纯右值，访问其成员变量m会促使该纯右值被实质化为一个临时对象。</li>
<li>调用类纯右值的隐式对象成员函数时：如果对一个纯右值调用了某个成员函数，那么该纯右值首先会被实质化为一个临时对象。</li>
<li>进行数组到指针转换或在数组纯右值上使用下标时：处理数组类型的纯右值时，如需转换为指针或使用下标操作，也会导致临时量实质化。</li>
<li>以花括号初始化器列表初始化 std::initializer_list&lt;T&gt; 类型的对象时：这涉及到使用初始化列表来构造对象的情况。</li>
<li>纯右值作为弃值表达式时：当纯右值被用作不关心结果的表达式时，可能需要实质化。</li>
</ol>
<p>官方案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; <span class="type">int</span> m; &#125;;</span><br><span class="line"><span class="type">int</span> k = <span class="built_in">S</span>().m; <span class="comment">// C++17 起成员访问期待泛左值；</span></span><br><span class="line">               <span class="comment">// S() 纯右值被转换成亡值</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，S() 创建了一个类型为 S 的纯右值。由于我们试图访问它的成员变量 m，这要求该纯右值必须首先被实质化为一个临时对象，之后才能对其成员进行访问。因此，在C++17中，S() 会被实质化为一个临时对象，然后通过这个临时对象访问成员 m。</p>
<p>从纯右值直接初始化同类型对象（无论是通过直接初始化还是复制初始化）并不会触发临时量实质化。这是因为C++17引入了“受保证的复制消除”机制，这意味着编译器可以直接使用源纯右值来初始化目标对象，而不需要创建中间的临时对象。这一特性不仅提高了性能，也简化了程序逻辑。</p>
<blockquote>
<p>可以理解为隐式转化的规则之一</p>
</blockquote>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="折叠表达式-…"><a href="#折叠表达式-…" class="headerlink" title="折叠表达式 ( … )"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/fold">折叠表达式 ( … )</a></h4><p>C++17引入了一个称为折叠表达式的新特性，它极大地简化了对参数包（…）的操作。这个特性主要用于模板编程中，使得对不定数量的模板参数进行操作变得更加简单和直观。</p>
<p>在c++17之前，对参数包进行操作通常需要使用递归或辅助函数或者是使用初始化列表。既麻烦还难看。</p>
<p>c++17之前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T first, Args... rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + <span class="built_in">sum</span>(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> -&gt; <span class="title">decltype</span><span class="params">((args + ...))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>((args + ...)) result&#123;&#125;; <span class="comment">// 初始化结果变量为0</span></span><br><span class="line">    (<span class="type">void</span>)std::initializer_list&lt;<span class="type">int</span>&gt;&#123;([&amp;] &#123; result += args; &#125;(), <span class="number">0</span>)...&#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折叠表达式</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> -&gt; <span class="title">decltype</span><span class="params">((args + ...))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>折叠表达式的语法与规则：</p>
<p>语法<br>折叠表达式主要分为四种形式：</p>
<p>一元右折叠 (E 运算符 …)：从左至右依次应用运算符。<br>一元左折叠 (… 运算符 E)：从右至左依次应用运算符。<br>二元右折叠 (E 运算符 … 运算符 I)：从左至右依次应用运算符，并以I作为初始值。<br>二元左折叠 (I 运算符 … 运算符 E)：从右至左依次应用运算符，并以I作为初始值。</p>
<p>其中，运算符可以是C++中的32个二元运算符之一，如+, -, *, &#x2F;, %, ^, &amp;, |, &#x3D;, &lt;, &gt;, &lt;&lt;, &gt;&gt;, +&#x3D;, -&#x3D;, <em>&#x3D;, &#x2F;&#x3D;, %&#x3D;, ^&#x3D;, &amp;&#x3D;, |&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&#x3D;, &#x3D;&#x3D;, !&#x3D;, &lt;&#x3D;, &gt;&#x3D;, &amp;&amp;, ||, ,, .</em>, -&gt;*等。</p>
<p>特殊情况<br>当一元折叠应用于长度为零的参数包时，仅允许使用特定的运算符：逻辑与（&amp;&amp;），其值为true；逻辑或（||），其值为false；以及逗号运算符（,），其值为void()。</p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">all</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... &amp;&amp; args); <span class="comment">// 使用一元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果调用all(true, true, true, false)，那么折叠表达式会展开为((true &amp;&amp; true) &amp;&amp; true) &amp;&amp; false，结果为false。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printer</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 使用折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;abc&quot;</span>); <span class="comment">// 输出: 123abc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back_vec</span><span class="params">(std::vector&lt;T&gt;&amp; v, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>((std::is_constructible_v&lt;T, Args&amp;&amp;&gt; &amp;&amp; ...));</span><br><span class="line">    (v.<span class="built_in">push_back</span>(std::forward&lt;Args&gt;(args)), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">push_back_vec</span>(v, <span class="number">6</span>, <span class="number">2</span>, <span class="number">45</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : v) std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 输出: 6 2 45 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模板实参推导-tuple-t-4-3-2-5"><a href="#类模板实参推导-tuple-t-4-3-2-5" class="headerlink" title="类模板实参推导 tuple t(4, 3, 2.5)"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/class_template_argument_deduction">类模板实参推导 tuple t(4, 3, 2.5)</a></h4><p>C++17引入了类模板实参推导（Class Template Argument Deduction，简称CTAD），这是一项允许编译器自动推断出类模板实例化时所需的模板参数值的功能。这项特性简化了许多情况下需要手动指定模板参数的需求，从而减少了代码的冗余和复杂性。</p>
<p>c++17之前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p</span><span class="params">(<span class="number">2</span>, <span class="number">4.5</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>c++17后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair <span class="title">p</span><span class="params">(<span class="number">2</span>, <span class="number">4.5</span>)</span></span>; <span class="comment">// 编译器可以自动推断出模板参数</span></span><br></pre></td></tr></table></figure>

<p>为了支持CTAD，C++17允许定义推导指引。</p>
<p>推导指引是特殊的声明，用于指导编译器如何从构造函数参数推导出模板参数。它们可以是隐式生成的，也可以由用户显式定义。</p>
<ul>
<li>隐式生成的推导指引：编译器会为每个构造函数自动生成相应的推导指引。</li>
<li>用户定义的推导指引：用户可以定义自己的推导指引来覆盖默认行为或处理特殊情况。</li>
</ul>
<p>用户自定义推导指引的语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(T, <span class="type">int</span>*);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">(T*, <span class="type">int</span>*)</span> -&gt; A&lt;T&gt;</span>; <span class="comment">// 用户定义的推导指引</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, *ip;</span><br><span class="line">A a&#123;i, ip&#125;; <span class="comment">// 自动推导为 A&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有完全搞懂，先放案例吧。。。</p>
</blockquote>
<p>注意：</p>
<p>CTAD仅在未提供模板实参列表的情况下发生。如果提供了模板实参列表，则不会触发推导。<br>在某些情况下，如存在多个可能的推导指引时，编译器会根据一定的优先级规则选择最合适的推导指引。<br>复制推导候选通常比包装构造函数更受偏好，以避免不必要的嵌套。</p>
<h4 id="auto-占位的非类型模板形参"><a href="#auto-占位的非类型模板形参" class="headerlink" title="auto 占位的非类型模板形参"></a>auto 占位的非类型模板形参</h4><p>在C++17之前，非类型模板参数（non-type template parameters, NTTPs）必须显式地指定其类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt; <span class="comment">//这里，N是一个整数类型的非类型模板参数。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++17的新方式<br>通过C++17的增强，我们可以使用auto关键字来代替具体的类型，这为模板提供了更大的灵活性和通用性。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，N可以是任何能作为非类型模板参数的值，无论它是int, long, double还是指针等。这意味着您不再需要为每种可能的类型分别编写模板特化或重载。</p>
<p>注意事项:</p>
<ul>
<li>虽然auto使得模板更加通用，但它不能用于所有类型的非类型模板参数。例如，类类型的对象（除非它们是字面量类型且有适当的转换构造函数）不能作为非类型模板参数。</li>
<li>此外，使用auto作为非类型模板形参时，不能与占位类型（placeholder types）如T结合使用于同一个模板形参列表内，这是为了避免歧义和复杂性。</li>
</ul>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><h4 id="简化的嵌套命名空间"><a href="#简化的嵌套命名空间" class="headerlink" title="简化的嵌套命名空间"></a>简化的嵌套命名空间</h4><p>c++11中嵌套命名空间的语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">namespace</span> B &#123;</span><br><span class="line">        <span class="keyword">namespace</span> C &#123;</span><br><span class="line">            <span class="comment">// 在这里定义 C 命名空间的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++17中简化的嵌套命名空间的语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">    <span class="comment">// 在这里定义 C 命名空间的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="using-声明语句可以声明多个名称"><a href="#using-声明语句可以声明多个名称" class="headerlink" title="using 声明语句可以声明多个名称"></a>using 声明语句可以声明多个名称</h4><p>using声明语句得到了增强，允许一次导入多个名称（如类型、函数或模板）从一个命名空间到另一个命名空间。这项改进简化了代码，减少了重复的using声明需求。</p>
<p>c++14中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo::f;</span><br><span class="line"><span class="keyword">using</span> foo::g;</span><br><span class="line"><span class="keyword">using</span> foo::h;</span><br></pre></td></tr></table></figure>

<p>c++17后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo::&#123;f, g, h&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="属性命名空间不必重复"><a href="#属性命名空间不必重复" class="headerlink" title="属性命名空间不必重复"></a>属性命名空间不必重复</h4><p>在C++17中，对于属性的使用有了改进，使得当多个属性属于同一个命名空间时，不必为每个属性都重复指定命名空间。具体来说，如果一组属性都位于同一个命名空间内（例如std::literals），您可以一次性指定这个命名空间，然后列出所有需要使用的属性，而不需要对每个属性名都加上完整的命名空间前缀。</p>
<p>在C++17之前，如果您想要使用来自特定命名空间的多个属性，您可能需要这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> [[std::literals::fast_math]] [[std::literals::ivdep]] [[std::<span class="title">literals::align_value</span><span class="params">(<span class="number">16</span>)</span>]]</span>;</span><br></pre></td></tr></table></figure>

<p>但在C++17中，通过使用[[using namespace_name: …]]语法，可以简化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> [[<span class="keyword">using</span> std::literals: fast_math, ivdep, align_value(<span class="number">16</span>)]];</span> </span><br></pre></td></tr></table></figure>

<h5 id="属性说明符序列-C-11-起"><a href="#属性说明符序列-C-11-起" class="headerlink" title="属性说明符序列 (C++11 起)"></a>属性说明符序列 (C++11 起)</h5><p>为类型、对象、代码等引入由实现定义的属性。</p>
<p>语法<br>[[ 属性列表 ]]  (C++11 起)<br>[[ using 属性命名空间 : 属性列表 ]]  (C++17 起)<br>其中属性列表 是由逗号分隔的零或更多个属性 的序列（可以以指示包展开的省略号 … 结束）</p>
<p>标识符<br>属性命名空间 :: 标识符<br>标识符 ( 实参列表 (可选) )<br>属性命名空间 :: 标识符 ( 实参列表 (可选) )<br>其中属性命名空间为一个标识符，而实参列表为其中圆括号、方括号和花括号平衡出现的记号序列（平衡记号序列）。</p>
<ol>
<li>简单属性，例如 [[noreturn]]。</li>
<li>有命名空间的属性，例如 [[gnu::unused]]。</li>
<li>有实参的属性，例如 [[deprecated(“原因”)]]。</li>
<li>既有命名空间又有实参列表的属性。</li>
</ol>
<p><img src="/image-1.png" alt="alt text"></p>
<blockquote>
<p>除了以下所列出的标准属性之外，实现还可能支持拥有由实现定义的行为的任意非标准属性。所有实现所未知的属性均被忽略，且不产生错误。</p>
</blockquote>
<h3 id="新属性"><a href="#新属性" class="headerlink" title="新属性"></a>新属性</h3><h4 id="fallthrough"><a href="#fallthrough" class="headerlink" title="[fallthrough]"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/attributes/fallthrough">[fallthrough]</a></h4><p>指示从前一标号直落是有意的，而在发生直落时给出警告的编译器不应诊断它。</p>
<p>直落语句只能用在 switch 语句中，其中待执行的下个语句是该 switch 语句的带 case 或 default 标号的语句。如果直落语句在循环中，那么下个（带标号）语句必须是该循环的同一迭代的一部分。</p>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span>, <span class="title">h</span><span class="params">()</span>, <span class="title">i</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">g</span>();</span><br><span class="line">            [[fallthrough]];</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 直落时不警告</span></span><br><span class="line">            <span class="built_in">h</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 编译器可在发生直落时警告</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">i</span>();</span><br><span class="line">                [[fallthrough]]; <span class="comment">// OK</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                [[fallthrough]]; <span class="comment">// 非良构：下一语句不是同一迭代的一部分</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            [[fallthrough]]; <span class="comment">// 非良构：没有后继的 case 或 default 标号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="maybe-unused"><a href="#maybe-unused" class="headerlink" title="[maybe_unused]"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/attributes/maybe_unused">[maybe_unused]</a></h4><p>抑制针对未使用实体的警告。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">此属性可出现在下列实体的声明中：</span><br><span class="line"></span><br><span class="line">class/struct/union：struct [[maybe<span class="emphasis">_unused]] S;</span></span><br><span class="line"><span class="emphasis">typedef，包括别名声明：[[maybe_</span>unused]] typedef S* PS;，using PS [[maybe<span class="emphasis">_unused]] = S*;</span></span><br><span class="line"><span class="emphasis">变量，包括静态数据成员：[[maybe_</span>unused]] int x;</span><br><span class="line">非静态数据成员：union U &#123; [[maybe<span class="emphasis">_unused]] int n; &#125;;</span></span><br><span class="line"><span class="emphasis">函数：[[maybe_</span>unused]] void f();</span><br><span class="line">枚举：enum [[maybe<span class="emphasis">_unused]] E &#123;&#125;;</span></span><br><span class="line"><span class="emphasis">枚举项：enum &#123; A [[maybe_</span>unused]], B [[maybe<span class="emphasis">_unused]] = 42 &#125;;</span></span><br><span class="line"><span class="emphasis">结构化绑定：[[maybe_</span>unused]] auto [a, b] = std::make<span class="emphasis">_pair(42, 0.23);</span></span><br><span class="line"><span class="emphasis">对于声明为 [[maybe_</span>unused]] 的实体，如果没有使用这些实体或它们的结构化绑定，那么编译器针对未使用实体发布的警告会被抑制。</span><br></pre></td></tr></table></figure>

<h4 id="nodiscard"><a href="#nodiscard" class="headerlink" title="[nodiscard]"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/attributes/nodiscard">[nodiscard]</a></h4><p>在转换到 void 之外的弃值表达式中调用声明为 nodiscard 的函数，或调用按值返回声明为 nodiscard 的枚举或类的函数时，鼓励编译器发布警告。</p>
<blockquote>
<p>在C++中，“弃值表达式”是指那些计算结果被有意忽略、不用于任何后续操作的表达式。通常情况下，这意味着表达式的值没有被存储到变量中，也没有作为参数传递给函数等。例如：<br>调用函数仅为了其副作用：有时我们调用一个函数主要是为了它的副作用（如打印输出、修改全局状态等），而不是关心它的返回值。在这种情况下，函数的返回值就被忽略了。<code>std::puts(&quot;Hello, world!&quot;);// 例如，std::puts 返回写入的字符数，但我们通常只关心它是否成功执行了打印操作</code></p>
</blockquote>
<h3 id="has-include"><a href="#has-include" class="headerlink" title="__has_include"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/preprocessor/include">__has_include</a></h3><p>语法：<br>#include &lt; h字符序列 &gt; 换行 (1)<br>#include “ q字符序列 “ 换行 (2)<br>#include 记号序列 换行 (3)<br>__has_include ( “ q字符序列 “ )<br>__has_include ( &lt; h字符序列 &gt; ) (4) (C++17 起)<br>__has_include ( 字符串字面量 )<br>__has_include ( &lt; h记号序列 &gt; ) (5) (C++17 起)</p>
<ol>
<li>搜索由 h字符序列 唯一识别的标头，并将该指令替换为这个标头的全部内容。</li>
<li>搜索由 q字符序列 识别的源文件，并将该指令替换为这个源文件的全部内容。可能退回至语法 (1) 并将 q字符序列 视为标头标识符。</li>
<li>如果 (1) 和 (2) 都不匹配，记号序列 会经历宏替换。该指令在替换后会再次尝试匹配 (1) 和 (2)。</li>
<li>检查是否可以包含一个标头或源文件。</li>
<li>如果 (4) 不匹配，h记号序列 会经历宏替换。该指令在替换后会再次尝试匹配 (4)。<br>换行 - 换行字符<br>h字符序列 - 一个或多个 h字符 的序列，并且其中以下内容的出现受条件性支持：</li>
</ol>
<ul>
<li>字符 ‘</li>
<li>字符 “</li>
<li>字符 \</li>
<li>字符序列 &#x2F;&#x2F;</li>
<li>字符序列 &#x2F;*</li>
</ul>
<p>h字符 - 源字符集(C++23 前)翻译字符集(C++23 起) 除了换行符和 &gt; 以外的任何成员<br>q字符序列 - 一个或多个 q字符 的序列，并且其中以下内容的出现受条件性支持：</p>
<ul>
<li>字符 ‘</li>
<li>字符 \</li>
<li>字符序列 &#x2F;&#x2F;</li>
<li>字符序列 &#x2F;*</li>
</ul>
<p>q字符 - 源字符集(C++23 前)翻译字符集(C++23 起) 除了换行符和 “ 以外的任何成员<br>记号序列 - 一个或多个预处理记号的序列<br>字符串字面量 - 一个字符串字面量<br>h记号序列 - 一个或多个除了 &gt; 以外的预处理记号的序列</p>
<p>这个特性是因为社区对头文件有了更深的理解才诞生的。<br>实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;optional&gt;</span>)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> has_optional 1</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">optional_t</span> = std::optional&lt;T&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __has_include(<span class="string">&lt;experimental/optional&gt;</span>)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;experimental/optional&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> has_optional -1</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">optional_t</span> = std::experimental::optional&lt;T&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> has_optional 0</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">optional_t</span></span><br><span class="line">    &#123;</span><br><span class="line">        V v&#123;&#125;;</span><br><span class="line">        <span class="type">bool</span> has&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">optional_t</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="built_in">optional_t</span>(V&amp;&amp; v) : <span class="built_in">v</span>(v), has&#123;<span class="literal">true</span>&#125; &#123;&#125;</span><br><span class="line">        <span class="function">V <span class="title">value_or</span><span class="params">(V&amp;&amp; alt)</span> <span class="type">const</span>&amp;</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> has ? v : alt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// etc.</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (has_optional &gt; <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;optional&gt; 存在\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (has_optional &lt; <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;experimental/optional&gt; 存在\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;optional&gt; 不存在\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">optional_t</span>&lt;<span class="type">int</span>&gt; op;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;op = &quot;</span> &lt;&lt; op.<span class="built_in">value_or</span>(<span class="number">-1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    op = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;op = &quot;</span> &lt;&lt; op.<span class="built_in">value_or</span>(<span class="number">-1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新的头文件"><a href="#新的头文件" class="headerlink" title="新的头文件"></a>新的头文件</h2><p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/any">&lt;any&gt;</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/charconv">&lt;charconv&gt;</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/execution">&lt;execution&gt;</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/filesystem">&lt;filesystem&gt;</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/memory_resource">&lt;memory_resource&gt;</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/optional">&lt;optional&gt;</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/string_view">&lt;string_view&gt;</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/variant">&lt;variant&gt;</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Wxy">
      <meta itemprop="description" content="故事开始于2025/2/24 15：47">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blogWxy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/undefined/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-01 11:06:37" itemprop="dateCreated datePublished" datetime="2025-04-01T11:06:37+08:00">2025-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-20 11:49:21" itemprop="dateModified" datetime="2025-02-20T11:49:21+08:00">2025-02-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c-14版本特性"><a href="#c-14版本特性" class="headerlink" title="c++14版本特性"></a>c++14版本特性</h1><h2 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/variable_template">变量模板</a></h2><p>变量模板可以认为是一种不确定的变量，就是泛型变量。</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; 形参列表 &gt; 变量声明</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>);</span><br></pre></td></tr></table></figure>

<p>在c++14之前只有模板函数和模板类，没有变量模板。</p>
<p>变量声明：变量的声明。声明的变量名成为模板名。<br>形参列表：非空的模板形参的逗号分隔列表，每项是非类型形参、类型形参、模板形参，或任何上述的形参包之一。</p>
<blockquote>
<p>介绍一下非类型形参、类型形参、模板形参是什么？<br>非类型形参：就是普通的形参，比如 template<int T> 在写变量的时候就可以在&lt;&gt;中写一个int类型的变量。(T纯右值不可改，在编译期间就确定了，除非T是左值引用类型)<br>类型形参：就是模板形参，比如 template<typename T> 在写变量的时候就可以在&lt;&gt;中写一个类型变量。<br>模板形参：就是模板形参，比如 template&lt;template<typename> class T&gt; 在写变量的时候就可以在&lt;&gt;中写一个模板变量。<br>模板实参：就是模板实参，比如 template<typename T> 在写变量的时候就可以在&lt;&gt;中写一个具体的类型，可以是类等自定义的类型。</p>
</blockquote>
<p>官方文档提供的几种案例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 基础使用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>); <span class="comment">// 变量模板</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">circular_area</span><span class="params">(T r)</span> <span class="comment">// 函数模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pi&lt;T&gt; * r * r; <span class="comment">// pi&lt;T&gt; 是变量模板实例化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.在类作用域中使用时，变量模板声明一个静态数据成员模板。</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix_constants</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">using</span> pauli = hermitian_matrix&lt;T, <span class="number">2</span>&gt;; <span class="comment">// 别名模版</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 静态数据成员模板</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> pauli&lt;T&gt; sigmaX = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> pauli&lt;T&gt; sigmaY = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>i&#125;, &#123;<span class="number">1</span>i, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> pauli&lt;T&gt; sigmaZ = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3.与其他静态成员一样，静态数据成员模板的需要一个定义。这种定义可以在类定义外提供。处于命名空间作用域的静态数据成员的模板声明也可以是类模板的非模板数据成员的定义：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">limits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> T min; <span class="comment">// 静态数据成员模板的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T limits::min = &#123;&#125;; <span class="comment">// 静态数据成员模板的定义</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> T s; <span class="comment">// 类模板的非模板静态数据成员的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T X&lt;T&gt;::s = <span class="number">0</span>; <span class="comment">// 类模板的非模板静态数据成员的定义</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型-lambda"><a href="#泛型-lambda" class="headerlink" title="泛型 lambda"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/lambda">泛型 lambda</a></h2><p>泛型lambda表达式可以在其形参列表中使用 auto 或 decltype(auto) 来表示其形参的类型。 拓展了c++11的lambda表达式的使用范围。</p>
<p>语法样例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> genericLambda = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> intResult = <span class="built_in">genericLambda</span>(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">// OK: int + int</span></span><br><span class="line"><span class="type">double</span> doubleResult = <span class="built_in">genericLambda</span>(<span class="number">5.5</span>, <span class="number">10.2</span>); <span class="comment">// OK: double + double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上编译器眼中的泛型lambda表达式是这样的：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeCompilerGeneratedClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T t, U u)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t + u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 官方提供的样例</span></span><br><span class="line"><span class="comment">// 泛型 lambda，operator() 是有两个形参的模板</span></span><br><span class="line"><span class="keyword">auto</span> glambda = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span>&amp;&amp; b) &#123; <span class="keyword">return</span> a &lt; b; &#125;;</span><br><span class="line"><span class="type">bool</span> b = <span class="built_in">glambda</span>(<span class="number">3</span>, <span class="number">3.14</span>); <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 泛型 lambda，operator() 是有一个形参的模板</span></span><br><span class="line"><span class="keyword">auto</span> vglambda = [](<span class="keyword">auto</span> printer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span>&amp;&amp;... ts) <span class="comment">// 泛型 lambda，ts 是形参包</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printer</span>(std::forward&lt;<span class="keyword">decltype</span>(ts)&gt;(ts)...);</span><br><span class="line">        <span class="comment">// 零元 lambda （不接受形参）</span></span><br><span class="line">        <span class="keyword">return</span> [=] &#123; <span class="built_in">printer</span>(ts...); &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> p = <span class="built_in">vglambda</span>([](<span class="keyword">auto</span> v1, <span class="keyword">auto</span> v2, <span class="keyword">auto</span> v3)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">p</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3.14</span>); <span class="comment">// 输出 1a3.14</span></span><br><span class="line"><span class="built_in">q</span>();                      <span class="comment">// 输出 1a3.14</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：泛型lambda表达式允许在捕获列表中初始化新变量，支持移动捕获和表达式初始化。</p>
</blockquote>
<h2 id="lambda-初始化捕获"><a href="#lambda-初始化捕获" class="headerlink" title="lambda 初始化捕获"></a>lambda 初始化捕获</h2><p>lambda表达式允许在捕获列表中初始化新变量。这个特性允许你在lambda表达式内部通过任意的表达式来初始化被捕获的变量。</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[captured_var = init_expression] (parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// lambda body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用样例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [val = x + <span class="number">10</span>]() &#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; val &lt;&lt; std::endl; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>(); <span class="comment">// 输出: Value: 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 智能指针的捕获</span></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> lambda = [ptr = std::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(p)]() &#123; </span><br><span class="line">    <span class="keyword">if</span>(ptr) std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>(); <span class="comment">// 输出: Value: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变捕获变量的类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [num = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x)]() <span class="keyword">mutable</span> &#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double value: &quot;</span> &lt;&lt; num &lt;&lt; std::endl; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>(); <span class="comment">// 输出: Double value: 5.0</span></span><br></pre></td></tr></table></figure>

<h2 id="new-delete-消除"><a href="#new-delete-消除" class="headerlink" title="new&#x2F;delete 消除"></a>new&#x2F;delete 消除</h2><p>这个特性英文是：new&#x2F;delete elision。</p>
<p>这个特性的意思是：在某些情况下，编译器可以在不调用 new 或 delete 运算符的情况下分配和释放内存。</p>
<p>因为对这个描述比较少，我们可以理解为，编译器对于new和delete的调用进行了优化。</p>
<p>在以下情况下，编译器可以体现new&#x2F;delete的省略：</p>
<ol>
<li>NRVO (Named Return Value Optimization) 和 RVO (Return Value Optimization)：<br>这些优化允许编译器在函数返回局部对象时省略拷贝或移动操作。如果编译器能够确定对象的生命期并进行优化，则可能避免额外的构造、拷贝和析构操作，这间接减少了潜在的new&#x2F;delete调用。</li>
<li>移动语义：<br>C++11引入了移动语义，允许资源从临时对象高效转移而不是复制。当一个对象被移动而不是被复制时，通常不需要分配新的内存，这减少了new操作的需求，并且通过释放旧的对象来减少delete操作。</li>
<li>自动存储持续时间 vs 动态存储持续时间：<br>尽量使用栈上的变量（具有自动存储持续时间），而不是堆上的动态分配（具有动态存储持续时间）。栈分配更快，且不需要手动管理内存（即显式的new和delete）。</li>
<li>智能指针：<br>使用如std::unique_ptr和std::shared_ptr等智能指针代替裸指针，可以帮助自动管理内存，减少手动调用new和delete的机会，并允许编译器更好地优化代码。</li>
</ol>
<h2 id="constexpr-函数上放松的限制"><a href="#constexpr-函数上放松的限制" class="headerlink" title="constexpr 函数上放松的限制"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/constexpr">constexpr 函数上放松的限制</a></h2><p>在C++14中，constexpr函数得到了显著的放松和增强，使其更加灵活和实用。根据你提供的来源，以下是C++14对constexpr函数放松的主要限制：</p>
<ol>
<li>允许更多的复杂操作：<br>在C++11中，constexpr函数被严格限制为只能包含一个返回语句。C++14放宽了这一限制，允许constexpr函数包含更复杂的控制流，包括循环（如while、for）和局部变量的声明。</li>
<li>非const成员函数可以是constexpr：<br>C++14允许非const成员函数也可以声明为constexpr。这意味着你可以定义修改对象状态的constexpr成员函数，只要这些修改可以在编译期完成。</li>
<li>支持局部变量：<br>constexpr函数现在可以包含局部变量的声明和使用，这增加了函数内部逻辑组织的灵活性。</li>
<li>不再强制所有声明都必须有constexpr说明符：<br>对于constexpr变量模板的所有声明来说，在C++14之前需要在每个声明处都加上constexpr说明符。C++14之后，不再要求这样做，提高了代码的可维护性。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// C++14 constexpr 函数可以包含局部变量和循环</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial_cxx14</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123; <span class="comment">// 循环</span></span><br><span class="line">        res *= n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非 const 成员函数可以是 constexpr</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">multiplyByTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">factorial_cxx14</span>(<span class="number">5</span>); <span class="comment">// 可以在编译期计算</span></span><br><span class="line">    <span class="built_in">static_assert</span>(result == <span class="number">120</span>, <span class="string">&quot;factorial calculation failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制字面量与数位分隔符"><a href="#二进制字面量与数位分隔符" class="headerlink" title="二进制字面量与数位分隔符"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/integer_literal">二进制字面量与数位分隔符</a></h2><p>在c++14之前，整数字面量只有十进制、八进制和十六进制。14之后，增加了二进制字面量。</p>
<p>二进制字面量的语法：要定义一个二进制字面量，你需要以0b或0B开头，后面跟随一个或多个二进制数字（0或1）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> binNumber = <span class="number">0b101010</span>; <span class="comment">// 等价于十进制的42</span></span><br><span class="line"><span class="type">int</span> binNumberUpper = <span class="number">0B101010</span>; <span class="comment">// 同样等价于十进制的42</span></span><br></pre></td></tr></table></figure>

<p>其他相关特性:除了直接支持二进制字面量外，C++14还允许在长整型字面量中使用二进制格式，并可以添加整数后缀来指定类型。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b101u</span> <span class="comment">//表示无符号整数。</span></span><br><span class="line"><span class="number">0b101L</span> <span class="comment">//表示长整数。</span></span><br><span class="line"><span class="number">0b101LL</span> <span class="comment">//表示长长整数。</span></span><br><span class="line"><span class="type">int</span> largeBinNumber = <span class="number">0b1&#x27;0101&#x27;0101</span>; <span class="comment">// 分隔符的使用</span></span><br></pre></td></tr></table></figure>

<p>此外，C++14还引入了单引号作为分隔符的功能，可以在较长的字面量中使用，以提高可读性。不过，这一功能主要针对视觉上的改善，并不影响字面量的实际值。</p>
<h2 id="函数的返回类型推导"><a href="#函数的返回类型推导" class="headerlink" title="函数的返回类型推导"></a><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/function#.E8.BF.94.E5.9B.9E.E7.B1.BB.E5.9E.8B.E6.8E.A8.E5.AF.BC_.28C.2B.2B14_.E8.B5.B7.29">函数的返回类型推导</a></h2><p>在c++11中auto作为函数的返回类型是一个占位符，必须要有尾随返回类型，但是在c++14中，auto可以作为函数的返回类型可以不写尾随返回类型，使代码变得更加简洁。</p>
<ol>
<li>使用auto进行返回类型推导<br>C++14允许使用auto作为函数的返回类型，编译器会根据函数体内的返回语句自动推导出实际的返回类型。这使得编写模板和泛型代码变得更加简洁。</li>
<li>decltype(auto)<br>除了直接使用auto，C++14还引入了decltype(auto)，它允许根据返回表达式的精确类型来推导返回类型，而不是根据值类别进行调整。这对于返回引用或指针时特别有用。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用auto时，返回类型基于值类别被调整：</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14f</span>; &#125; <span class="comment">// 返回类型是 float</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用decltype(auto)时，返回类型基于表达式的声明类型：</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125; <span class="comment">// 返回类型是 const int&amp;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>尾随返回类型的改进<br>虽然尾随返回类型（trailing return type）在C++11中就已经存在，但在C++14中与auto结合使用变得更加灵活和强大。例如，可以轻松地定义复杂的返回类型：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span>; <span class="comment">// C++11风格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在C++14中可以直接写成：</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123; <span class="keyword">return</span> t + u; &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>单返回语句的简单推导<br>如果一个函数只有一条返回语句，并且这条语句的表达式类型可以明确推导出来，那么编译器可以根据这个表达式直接推导出函数的返回类型。这种情况下不需要显式指定返回类型。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125; <span class="comment">// 返回类型自动推导为 int</span></span><br></pre></td></tr></table></figure>

<h2 id="带默认成员初始化器的聚合类。"><a href="#带默认成员初始化器的聚合类。" class="headerlink" title="带默认成员初始化器的聚合类。"></a>带默认成员初始化器的聚合类。</h2><p>在C++标准中聚合类的定义，聚合类是指满足以下条件的类：</p>
<ul>
<li>没有私有或受保护的非静态数据成员。</li>
<li>没有用户声明的构造函数（即没有自定义的构造函数）。</li>
<li>没有虚函数。</li>
<li>没有基类。</li>
<li>没有虚基类。</li>
</ul>
<p>在C++14之前，聚合类不允许为成员变量提供默认初始化器。例如，下面的代码在C++11中是非法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// 默认成员初始化器，在C++11中非法</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>; <span class="comment">// 默认成员初始化器，在C++11中非法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++14放松了这个限制，允许聚合类拥有默认成员初始化器。这意味着你可以为聚合类的成员变量指定默认值，这些默认值会在对象被默认初始化时使用。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// 默认成员初始化器</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>; <span class="comment">// 默认成员初始化器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个特性看编译器是否支持，比如clion用cmake构建项目，声明的是c++11版本也支持这个特性。</p>
</blockquote>
<p>注意事项</p>
<ul>
<li>初始化顺序：如果使用列表初始化，成员变量会按照它们在类中声明的顺序进行初始化，而不是按照初始化列表中的顺序。</li>
<li>兼容性：虽然可以为聚合类的成员提供默认初始化器，但这并不意味着聚合类的行为完全等同于带有构造函数的类。聚合类仍然不能有用户定义的构造函数、虚函数或基类。</li>
<li>混合初始化：如果你部分提供了初始化值，未提供的成员将会使用默认初始化器。例如：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wxy"
      src="/images/%E5%A4%B4%E5%83%8F.jpg">
  <p class="site-author-name" itemprop="name">Wxy</p>
  <div class="site-description" itemprop="description">故事开始于2025/2/24 15：47</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wxy</span>
</div>
  <div class="powered-by">
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
